<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>分类: CppDev - Hello, NilEra :-)</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hello, NilEra :-)"><meta name="msapplication-TileImage" content="/img/StarLogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hello, NilEra :-)"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="努力做自己喜欢的事"><meta property="og:type" content="blog"><meta property="og:title" content="Hello, NilEra :-)"><meta property="og:url" content="https://hello-nilera.com/"><meta property="og:site_name" content="Hello, NilEra :-)"><meta property="og:description" content="努力做自己喜欢的事"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hello-nilera.com/img/og_image.png"><meta property="article:author" content="NilEra"><meta property="article:tag" content="Hello NilEra"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hello-nilera.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hello-nilera.com"},"headline":"Hello, NilEra :-)","image":["https://hello-nilera.com/img/og_image.png"],"author":{"@type":"Person","name":"NilEra"},"publisher":{"@type":"Organization","name":"Hello, NilEra :-)","logo":{"@type":"ImageObject","url":"https://hello-nilera.com/img/StarLogo.svg"}},"description":"努力做自己喜欢的事"}</script><link rel="icon" href="/img/StarLogo.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?249654dcf9a3bf70708fdfc6e2b1ec2b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="F6BD78C6BD0096D2218CF88334111125"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/me">我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">CppDev</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-07-29T07:32:17.000Z" title="2024/7/29 15:32:17">2024-07-29</time>发表</span><span class="level-item"><time dateTime="2024-07-30T13:16:11.993Z" title="2024/7/30 21:16:11">2024-07-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></span><span class="level-item">23 分钟读完 (大约3400个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/29/Cpp-Muti-Threaded/">Cpp_Muti_Threaded</a></p><div class="content"><h2 id="🔱-C-多线程编程"><a href="#🔱-C-多线程编程" class="headerlink" title="🔱 C++ 多线程编程"></a>🔱 C++ 多线程编程</h2><p>[TOC]</p>
<h3 id="🧶-1-进程和线程的基本概念"><a href="#🧶-1-进程和线程的基本概念" class="headerlink" title="🧶 1. 进程和线程的基本概念"></a>🧶 1. 进程和线程的基本概念</h3><p><strong>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</strong>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道、文件、套接字等。</p>
<p><strong><u>线程</u>是进程的进程。</strong>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程的最大数量取决于CPU的核心数。</p>
<p>线程与进程的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写这些栈内存。</p>
<p>线程是进程的一个实体，是进程的一条执行路径。</p>
<p>线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。</p>
<h3 id="🧶-2-C-11-Windows-线程库的基本使用"><a href="#🧶-2-C-11-Windows-线程库的基本使用" class="headerlink" title="🧶 2. C++ 11 Windows 线程库的基本使用"></a>🧶 2. C++ 11 Windows 线程库的基本使用</h3><p><strong>C++ 11 线程库头文件</strong> <code>#include &lt;thread&gt;</code></p>
<ul>
<li><p>创建线程</p>
<p>可以使用 <code>std::thread</code> 来创建线程，这其实是使用线程类 <code>std::thread</code> 声明一个线程实例 <code>printThread</code> 的过程。这里我们直接这样创建线程，生成应用程序之后运行输出结果：<code>Hello World - I&#39;m NilEra @-@</code>，但是运行之后会出现错误。</p>
<p>这里出现错误的原因是：当我们启动了 <code>thread_print</code> 线程，此时程序不会在这里等待线程执行完成，而是会继续向下执行，导致出现程序已经执行到 <code>return 0</code> 时，线程还没有执行完成，因此这里会产生报错。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printThread</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World - I&#x27;m NilEra @-@&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printThread)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主程序等待线程执行完毕</p>
<p>为了解决上述出现的问题，我们需要让主程序等待的线程执行完毕再进行退出，这时我们就需要用到 <code>join()</code> 函数。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    thread_print.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分离线程</p>
<p>上述的问题还可以使用 <code>detach()</code> 函数来进行解决。当执行下面的程序时，控制台不会又任何输出，直接退出程序。</p>
<p>这是因为线程执行完线程的创建之后，紧接着执行了 <code>detach()</code>，此时线程的具体操作还未来得及执行就进行了线程的分离。进程结束之后，<code>thread_print</code> 线程还在后台运行。但是因为此时进程已经结束，线程执行的过程中不会有输出。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程分离</span></span><br><span class="line">    thread_print.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用如下代码可以更清晰的看到执行 detach() 的效果, 以及 join() 和 detach() 的区别</span></span><br><span class="line"><span class="comment">// join() 是阻塞的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">    thread_print.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断线程是否可以合并</p>
<p>有时我们需要对线程判断其是否可以进行 <code>join()</code> 操作，此时我们可以调用 <code>joinable()</code> 函数，<code>joinable()</code> 会返回一个 <code>bool</code> 值，用于判断线程是否可以进行 <code>join()</code> 操作。</p>
<p>如果我们对一个不可使用 <code>join()</code> 或者 <code>detach()</code> 的线程进行了 <code>join()</code> 和 <code>detach()</code> 操作，会出现一个 <code>SystemError</code>，在一些比较严谨的项目中，会先使用 <code>joinable()</code> 进行判断。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> isJoin = thread_print.<span class="built_in">joinable</span>();</span><br><span class="line">    <span class="keyword">if</span> (isJoin) &#123;</span><br><span class="line">        thread_print.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧶-3-线程函数中的数据未定义错误"><a href="#🧶-3-线程函数中的数据未定义错误" class="headerlink" title="🧶 3. 线程函数中的数据未定义错误"></a>🧶 3. 线程函数中的数据未定义错误</h3><h4 id="3-1-传递临时变量问题"><a href="#3-1-传递临时变量问题" class="headerlink" title="3.1 传递临时变量问题"></a>3.1 传递临时变量问题</h4><ul>
<li><p>错误示例：如下使用 <code>std::thread</code> 类时，传入线程函数 <code>foo</code> 和 参数 <code>a</code>，这里的参数 <code>a</code> 会被作为值传递，即传递的不是 <code>a</code> 的引用，而是 <code>a</code> 所存储的值 <code>1</code>。但是如果是值传递的话，这里调用的实际上是 <code>foo((int&amp;) 1)</code> 会产生编译错误，因为 <code>1</code> 实际上是一个右值，而<strong>非常量引用的初始值必须为左值</strong>，所以这里会产生编译错误。</p>
<p>我们平时调用 <code>foo</code> 时，可以使用 <code>foo(a)</code>，实际上我们进行了隐式转换，执行的实际上是 <code>foo((int&amp;) a)</code>。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus</span><span class="params">(foo, a)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拓展 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">const_foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;const_foo param x is : &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus_const</span><span class="params">(const_foo, a)</span></span>;</span><br><span class="line">	thread_plus.<span class="built_in">join</span>();</span><br><span class="line">	thread_plus_const.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-传递指针或引用指向局部变量的问题"><a href="#3-2-传递指针或引用指向局部变量的问题" class="headerlink" title="3.2 传递指针或引用指向局部变量的问题"></a>3.2 传递指针或引用指向局部变量的问题</h4><ul>
<li><p>错误示例：在下面的程序中，我们定义了一个全局线程变量，并且在 <code>test</code> 函数被调用时开启了这个线程 <code>t</code>，在 <code>main</code> 函数中，执行了 <code>test</code> 函数，在执行到 <code>t = std::thread(foo, std::ref(a));</code> 时，线程启动。这时会出现两种情况：</p>
<p>① （大概率出现）在线程启动的时候，<code>test</code> 函数已经结束了运行，而局部变量 <code>a</code> 的内存被释放，此时出现空指针错误；</p>
<p>② （小概率出现）程序正常执行，这是因为线程执行的比 <code>test</code> 函数更快，当线程执行结束时，<code>a</code> 还没有被释放。我们可以在 <code>t = std::thread(foo, std::ref(a));</code> 下添加 <code>Sleep(10)</code>，使程序暂停 <code>10 ms</code>，保证线程结束的时候 <code>test</code> 还未执行完成来观察这一现象。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	t = std::<span class="built_in">thread</span>(foo, std::<span class="built_in">ref</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;		<span class="comment">// 延长 a 的声明周期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// int a = 1;</span></span><br><span class="line">	t = std::<span class="built_in">thread</span>(foo, std::<span class="built_in">ref</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拓展 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	t = std::<span class="built_in">thread</span>(foo, std::<span class="built_in">ref</span>(a));</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-传递指针或引用指向已经释放的内存问题"><a href="#3-3-传递指针或引用指向已经释放的内存问题" class="headerlink" title="3.3 传递指针或引用指向已经释放的内存问题"></a>3.3 传递指针或引用指向已经释放的内存问题</h4><ul>
<li><p>错误示例：这个问题和上面的问题是差不多的问题，这里有可能会① 直接报编译错误；② 通过编译，但是给出不期待的结果；③ 极小概率出现正常执行的情况。</p>
<p>当我们启动线程后，手动释放 <code>ptr_a</code>，此时若线程 <code>t</code> 的执行在释放内存之前（小概率），不会出现不期待的访问结果；但是如果线程 <code>t</code> 在释放内存之后执行（大概率），则会出现不期待的结果。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">	*x += <span class="number">1</span>;</span><br><span class="line">	std::cout &lt;&lt; *x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* ptr_a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);		<span class="comment">// 定义一个指针类型的变量 ptr_a</span></span><br><span class="line">									<span class="comment">// 初始化为其内存中存储的值为 1</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(foo, ptr_a)</span></span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr_a;					<span class="comment">// 这里手动释放 ptr_a</span></span><br><span class="line"></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">	*x += <span class="number">1</span>;</span><br><span class="line">	std::cout &lt;&lt; *x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* ptr_a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);		<span class="comment">// 定义一个指针类型的变量 ptr_a</span></span><br><span class="line">									<span class="comment">// 初始化为其内存中存储的值为 1</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(foo, ptr_a)</span></span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">10</span>);						<span class="comment">// 启动线程后等待 10 ms, 此时线程大概率已经执行完毕</span></span><br><span class="line">	<span class="keyword">delete</span> ptr_a;					<span class="comment">// 这里手动释放 ptr_a</span></span><br><span class="line"></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-类成员作为入口函数，类对象被提前释放"><a href="#3-4-类成员作为入口函数，类对象被提前释放" class="headerlink" title="3.4 类成员作为入口函数，类对象被提前释放"></a>3.4 类成员作为入口函数，类对象被提前释放</h4><ul>
<li><p>错误示例：这个错误和上面的错误基本上没有区别，只不过是将要 <code>int</code> 型换成了<em>类</em> 类型。</p>
<p>在 <code>main</code> 函数中，创建了一个 <code>MyClass</code> 类型的对象 <code>obj</code>。接着，启动了一个线程 <code>t</code>，这个线程执行 <code>MyClass::func</code>，并传递 <code>obj</code> 的地址 <code>&amp;obj</code> 给它，这里的 <code>&amp;obj</code> 为 <code>this</code> 指针。当 <code>t</code> 线程启动时，它会在后台执行 <code>MyClass::func</code>，但是，<code>main</code> 函数在启动线程后立即返回，而没有等待线程完成。此时，局部变量 <code>obj</code> 会被销毁。如果 <code>t</code> 线程还没有执行完 <code>MyClass::func</code>，则它将尝试访问一个已经销毁的对象，导致未定义行为和运行时错误。</p>
<p>我们可以使用智能指针的方式来防止出现指针提前释放的情况，使用 <code>std::shared_ptr&lt;MyClass&gt;</code> 创建并管理 <code>MyClass</code> 对象的生命周期。<code>std::make_shared&lt;MyClass&gt;()</code> 创建一个 <code>shared_ptr</code>，并返回一个指向堆上分配的 <code>MyClass</code> 对象的共享指针。传递 <code>obj</code>（<code>shared_ptr</code>）给 <code>std::thread</code> 的构造函数时，会增加引用计数，确保 <code>MyClass</code> 对象在 <code>obj</code> 和线程中都有效。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Started...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Finished...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	MyClass obj;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, &amp;obj)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 正确修改 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Started...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Finished...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针</span></span><br><span class="line">	std::shared_ptr&lt;MyClass&gt; obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证线程运行结束再退出主程序</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧶-4-互斥量解决多线程数据共享问题"><a href="#🧶-4-互斥量解决多线程数据共享问题" class="headerlink" title="🧶 4. 互斥量解决多线程数据共享问题"></a>🧶 4. 互斥量解决多线程数据共享问题</h3><p><strong>数据共享问题：</strong>在多个线程中共享数据时，需要注意 <em><strong>线程安全</strong></em> 问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现<strong>数据竞争</strong>问题。数据竞争可能导致程序崩溃、产生未定义错误或者得到错误的结果。</p>
<p>为了避免数据竞争问题，需要使用<strong>同步机制</strong>来确保多个线程之间对共享数据的访问量是安全的。常见的同步机制包括<strong>互斥量</strong>、<strong>条件操作</strong>、<strong>原子操作</strong>等。</p>
<p>可以看到下面这张图，来体会一下没有锁的情况下导致的多线程数据共享的问题。我们有两个线程 <code>Thread 1</code> 和 <code>Thread 2</code>，这两个线程都在执行的过程中，其操作都是 <code>a += 1</code>。具体过程如下：<br>① 此时我们有一个变量 <code>a = 1</code>，首先 <code>Thread 1</code> 获取到了 <code>a</code>，执行操作后 <code>a=2</code>；</p>
<p>② <code>Thread 2</code> 获取到了 <code>a</code>，执行操作后 <code>a=3</code>；</p>
<p>③ <code>Thread 1</code> 获取到了 <code>a</code>，执行操作后 <code>a=4</code>；</p>
<p>④ <code>Thread 2</code> 获取到了 <code>a</code>，执行操作后 <code>a=5</code>；</p>
<p>⑤ <code>Thread 1</code> 和 <code>Thread 2</code> 同时获取到了 <code>a</code>，同时执行操作后 <code>a=6</code>；</p>
<p>一共执行了 <code>6</code> 次操作，<code>a</code> 应该由 <code>1</code> 变成 <code>7</code>。但是实际上他最终的结果是 <code>6</code> 。</p>
<img src="./Cpp_Muti_Threaded/ThreadWithNoMutex.png" style="zoom: 50%;" >

<p><strong>下面演示这种错误：</strong></p>
<p>在这个案例中，我们运行了两个线程 <code>t1</code> 和 <code>t2</code>，每个线程都让 <code>a</code> 加 <code>50,000</code>，因此我们期待的结果是 <code>100,000</code>。但是实际上运行的结果一般是小于 <code>100,000</code> 的。比如我运行了几次，分别是：<code>78,301</code>、<code>61603</code>、<code>54843</code>。说明两个线程多个瞬间同时获取到了变量 <code>a</code>。</p>
<p>当然，循环次数较小的时候也许会出现结果正确的问题，这是因为编译器帮我们汇编成了原子操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们可以使用 <strong>互斥量<code>mutex</code></strong> 对变量进行上锁操作。**互斥量的头文件是：<code>#include &lt;mutex&gt;</code>**。</p>
<p>我们修改程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;		<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();		<span class="comment">// 加锁操作</span></span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();	<span class="comment">// 解锁操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何判断线程是否是安全的</strong>：当多线程程序每一次运行的结果和你的单线程程序运行的结果相同时，则认为你的线程是安全的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-23T04:27:44.000Z" title="2024/6/23 12:27:44">2024-06-23</time>发表</span><span class="level-item"><time dateTime="2024-06-24T08:40:14.154Z" title="2024/6/24 16:40:14">2024-06-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/Gaming/">Gaming</a></span><span class="level-item">5 分钟读完 (大约756个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/23/CppGamingDEV-PVZ-BASE-EASYX/">CppGamingDEV_PVZ_BASE_EASYX</a></p><div class="content"><h2 id="🎮-从零开始进行-C-游戏开发"><a href="#🎮-从零开始进行-C-游戏开发" class="headerlink" title="🎮 从零开始进行 C++ 游戏开发"></a>🎮 从零开始进行 C++ 游戏开发</h2><p>[TOC]</p>
<h3 id="游戏场景概念"><a href="#游戏场景概念" class="headerlink" title="游戏场景概念"></a>游戏场景概念</h3><ul>
<li><strong>什么是场景?</strong><br>如果将要游戏程序比作是一场有玩家参与的盛大演出，那场景就是演出过程中的一幕。在不同的幕中，会有不同的剧本逻辑，也可能会有不同的角色登场，这些角色即游戏开发中常提到的 <code>GameObject</code> 的概念。<br>不论是玩家、敌人还是子弹、道具等，这些从概念上讲都是 <code>GameObject</code> 的范畴。他们接受着不同的场景剧本的指挥，进行着不同逻辑的演出。<br>了解了这些，我们就可以对程序的流程进行宏观的划分，游戏的主菜单是一个场景，玩家角色选择界面也是一个场景，游戏局内的逻辑也需要放置在一个单独的场景中。<br>所以我们就可以定义一个 <code>Scene</code> 场景基类，<strong>主菜单</strong>、<strong>角色选择</strong>、<strong>局内游戏</strong> 作为新类分别继承 <code>Scene</code> 类。</li>
</ul>
<h3 id="游戏主循环框架概念"><a href="#游戏主循环框架概念" class="headerlink" title="游戏主循环框架概念"></a>游戏主循环框架概念</h3><ul>
<li><strong>什么是游戏主循环框架?</strong><br>游戏程序的主体是一个永不停歇的死循环。在每次循环中，我们读取玩家的操作信息，并根据这些操作，处理玩家数据更新，在最后的绘图阶段将游戏画面根据这些更新后的数据渲染出来。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    读取操作();</span><br><span class="line">    处理数据();</span><br><span class="line">    绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">施放资源;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++ 头文件"></a>C++ 头文件</h3><ul>
<li>为什么需要头文件卫士?<br>如果不使用头文件卫士，可能会导致出现重定义的问题。例如，我们有一个头文件 <code>A.h</code> ，有一个头文件 <code>B.h</code>，头文件 <code>B.h</code> 中使用了 <code>A.h</code> 的内容。当我们在主函数里面使用了 <code>A.h</code> 和 <code>B.h</code> 的时候，使用 <code>#include</code> 时会将头文件中的内容全部<strong>复制</strong>到 <code>#include</code> 的部分。这样的话如果不加头文件卫士，就会导致重定义的问题，如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span>      <span class="comment">// int a;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span>      <span class="comment">// int a;</span></span></span><br><span class="line">                    <span class="comment">// int b;</span></span><br><span class="line">                    <span class="comment">// 出现重定义错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误信息如下</span></span><br><span class="line">In file included from B.h:<span class="number">1</span>,</span><br><span class="line">             from main.cpp:<span class="number">2</span>:</span><br><span class="line">A.h:<span class="number">1</span>:<span class="number">5</span>: error: redefinition of <span class="string">&#x27;int a&#x27;</span></span><br><span class="line">    <span class="number">1</span> | <span class="type">int</span> a;</span><br><span class="line">      |     ^</span><br><span class="line">In file included from main.cpp:<span class="number">1</span>:</span><br><span class="line">A.h:<span class="number">1</span>:<span class="number">5</span>: note: <span class="string">&#x27;int a&#x27;</span> previously declared here</span><br><span class="line">    <span class="number">1</span> | <span class="type">int</span> a;</span><br><span class="line">      |     ^</span><br></pre></td></tr></table></figure>
在 <code>MSVC</code> 编译器中，头文件卫士如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>
在其他的一些编译器中，常写为这样：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HEADER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HEADER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="场景管理器"><a href="#场景管理器" class="headerlink" title="场景管理器"></a>场景管理器</h3><p>游戏程序是一个巨大的死循环，也是一个巨大的状态机。不同的游戏场景代表着不同的状态，管理着这些状态的“状态机”，在游戏开发中有一个特殊的名字——场景管理器。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T13:50:18.000Z" title="2024/5/22 21:50:18">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-07-29T07:32:26.196Z" title="2024/7/29 15:32:26">2024-07-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/QT6/">QT6</a></span><span class="level-item">23 分钟读完 (大约3452个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Better-QT/">Better QT</a></p><div class="content"><p>[TOC]</p>
<h2 id="🍞-Better-QT"><a href="#🍞-Better-QT" class="headerlink" title="🍞 Better QT"></a>🍞 Better QT</h2><h3 id="🍦-1-Qt-的一些常用技巧"><a href="#🍦-1-Qt-的一些常用技巧" class="headerlink" title="🍦 1. Qt 的一些常用技巧"></a>🍦 1. Qt 的一些常用技巧</h3><h4 id="1-1-快捷键"><a href="#1-1-快捷键" class="headerlink" title="1.1 快捷键"></a>1.1 快捷键</h4><ul>
<li>快捷键 <code>Ctrl + Tab</code> 可以切换文件；</li>
<li>快捷键 <code>Alt + ENTER</code> 弹出代码生成提示，可以快速提示错误修改方案，类似于 IDEA 的 <code>Alt + ENTER</code>；</li>
<li>快捷键 <code>Alt + 鼠标</code> 同时输入；</li>
<li>快捷键 <code>Ctrl + R</code> 运行程序；</li>
<li>快捷键 <code>Ctrl + M</code> 创建书签（Bookmark），或者直接在某行代码前右键添加书签；</li>
<li>快捷键 <code>Ctrl + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + Shift + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + I</code> 代码对齐；</li>
<li>快捷键 <code>Ctrl + ;</code> 格式化代码；</li>
<li>快捷键 <code>Shift + Delete</code> 剪切当前行，可以当删除用；</li>
<li>快捷键 <code>Ctrl + Shift + R</code> 局部变量统一修改；</li>
<li>快捷键 <code>Ctrl + Shift + V</code> 复制历史；</li>
<li>用键盘模拟鼠标操作：  <table>
    <tr>
        <td colspan="3">功能键</td> 
        <td colspan="3">方向键</td> 
        <td>备注</td>
    </tr>
    <tr>
          <td>Ctrl</td>
          <td>Shift</td>
          <td>Alt</td>
          <td>左/右</td>
          <td>上/下</td>
          <td>Home/End</td>
          <td>方向键具有移动光标的作用</td>
    </tr>
    <tr>
          <td>×</td>
          <td>×</td>
          <td>×</td>
          <td>字符</td>
          <td>字符</td>
          <td>行首/行尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>×</td>
          <td>单词</td>
          <td>滚动条</td>
          <td>文件头/尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>单词</td>
          <td>移动</td>
          <td>行首/行尾</td>
          <td>Shift具有选中文本的作用</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>√</td>
          <td>-</td>
          <td>向上/下复制选中部分</td>
          <td>-</td>
          <td>-</td>
    </tr>
  </table></li>
<li>快捷键 <code>F1</code> 查看帮助、文档</li>
<li>快捷键 <code>F2</code> 快速到变量或者函数间切换</li>
<li>快捷键 <code>F4</code> 快速在<code>.cpp</code>文件和<code>.h</code>文件间切换</li>
<li>快捷键 <code>Ctrl + Shift + U</code> 查找所有使用该符号的地方</li>
<li>快捷键 <code>Ctrl + K</code> 打开定位器</li>
<li>快捷键 <code>Ctrl + L</code> 跳转到某一行</li>
<li>快捷键 <code>Ctrl + [Shift] + F</code> 查找&#x2F;替换当前文件[项目]当前选中的内容</li>
<li>快捷键 <code>[Shift] + F3</code> 查找下[上]一个</li>
<li>快捷键 <code>Ctrl + B</code> 编译工程</li>
<li>快捷键 <code>Ctrl + R</code> 运行工程</li>
<li>快捷键 <code>F5</code> 调试运行</li>
<li>快捷键 <code>Ctrl + Shift + F5</code> 重启调试</li>
<li>快捷键 <code>F9</code> 设置和取消断点</li>
<li>快捷键 <code>F10</code> 单步跳过</li>
<li>快捷键 <code>F11</code> 单步进入</li>
</ul>
<h4 id="1-2-Creator-片段"><a href="#1-2-Creator-片段" class="headerlink" title="1.2 Creator 片段"></a>1.2 Creator 片段</h4><p>片段简单理解一下就是已经写好的一些模式化的代码，用户可以使用内置片段或者根据自己的需要自定义片段。</p>
<ol>
<li>自带片段示例<br><img src="/./BetterQT/QtQuickSnippets.png" alt="Qt Quick Part"></li>
<li>自定义片段<br>一个用户的自定义片段需要以下几个内容：<br>$$片段 &#x3D; 一级标题 + 二级标题 + 片段文本$$<br>需要通过：编辑（Edit）→首选项（Preferences）→文本编辑器（Text Editor）→片段（Snippets）进行设置<br><img src="/./BetterQT/Qt_Custom_Snippets.png" alt="Qt Custom Snippets"><br>比如我要添加一个自定义片段 <code>note</code>，用来表示文件注释，可以选择 <code>Group</code> 为 <code>C++</code>，然后选择 <code>Add</code>，添加指定的内容：<br><img src="/./BetterQT/AddCustomSnippets.png" alt="Add Custom Snippets"></li>
</ol>
<h3 id="🍦-2-Qt-代码-文件解释"><a href="#🍦-2-Qt-代码-文件解释" class="headerlink" title="🍦 2. Qt 代码&#x2F;文件解释"></a>🍦 2. Qt 代码&#x2F;文件解释</h3><p>Qt的源代码和文件解释</p>
<h4 id="2-1-Qt-代码"><a href="#2-1-Qt-代码" class="headerlink" title="2.1 Qt 代码"></a>2.1 Qt 代码</h4><ul>
<li><p><code>hellocosbrowser.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOCOSBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOCOSBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span> : <span class="keyword">public</span> QWidget  <span class="comment">// QWidget 是所有应用程序窗口的基类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// Qt的宏, 支持 Qt 的特性, 如信号与槽、对象树、元对象等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里 HelloCOSBrowser 指定父窗口指针为 nullptr, 则它会作为一个独立的窗口进行展示, 否则则会作为父窗口的一个控件</span></span><br><span class="line">    <span class="comment">// 关于这个父窗口指针, 一个很典型的应用就是 微信</span></span><br><span class="line">    <span class="comment">// 当我们创建新窗口的时候, 如果不指定父窗口, 就会弹出一个独立的新窗口, 即电脑任务栏的图标会多出来一个</span></span><br><span class="line">    <span class="comment">// 如果指定了父窗口, 则不会创建一个独立的窗口, 即电脑任务栏处的图标不会增加</span></span><br><span class="line">    <span class="built_in">HelloCOSBrowser</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">HelloCOSBrowser</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::HelloCOSBrowser *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLOCOSBROWSER_H</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-Qt-工程文件解释"><a href="#2-2-Qt-工程文件解释" class="headerlink" title="2.2 Qt 工程文件解释"></a>2.2 Qt 工程文件解释</h4><p>文件列表</p>
<table>
<thead>
<tr>
<th align="center">文件名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>pro</code> 文件</td>
<td align="center">该文件是 Qt 的项目文件，qmake工具可以根据此文件生成 Makefile</td>
</tr>
<tr>
<td align="center"><code>pro.user</code> 文件</td>
<td align="center">该文件包含和用户相关的项目信息（用户不需要关注此文件）</td>
</tr>
<tr>
<td align="center"><code>ui</code> 文件</td>
<td align="center">Qt 的设计师界面文件</td>
</tr>
<tr>
<td align="center"><code>.cpp</code> 文件</td>
<td align="center">C++ 源文件</td>
</tr>
<tr>
<td align="center"><code>.h</code> 文件</td>
<td align="center">C++ 头文件</td>
</tr>
</tbody></table>
<h3 id="🍦-3-MOC编译器"><a href="#🍦-3-MOC编译器" class="headerlink" title="🍦 3. MOC编译器"></a>🍦 3. MOC编译器</h3><p>MOC(Meta-Object Compiler)编译器<br>C++ 编译器本身不支持 Qt 的某些机制，Qt 希望对 C++ 代码进行自动扩展，这里就需要用到宏（例如：<code>Q_Object</code>）和继承。<br>此外为了方便用户使用，希望用户无感知，可以将这一操作直接集成到框架中。</p>
<h4 id="3-1-Qt-编译过程"><a href="#3-1-Qt-编译过程" class="headerlink" title="3.1 Qt 编译过程"></a>3.1 Qt 编译过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 目标</span><br><span class="line">  ↑</span><br><span class="line">  +-------------------------+</span><br><span class="line">                            ↑</span><br><span class="line">拓展代码 -&gt; MOC编译器 -&gt; 新CPP代码</span><br></pre></td></tr></table></figure>
<p>通过上述方式，实现 Qt 的某些特性。我们可以发现，当我们写完代码进行编译后，会产生一个 <code>debug</code> 文件夹，此时我们进入该文件夹，会看到一些元对象编译器编译的文件，如 <code>moc_xxxx.cpp</code> 或 <code>moc_xxx.h</code> 等文件。</p>
<h4 id="3-2-MOC-的使用方法"><a href="#3-2-MOC-的使用方法" class="headerlink" title="3.2 MOC 的使用方法"></a>3.2 MOC 的使用方法</h4><ol>
<li>MOC 编译工具由 Qt 框架自动调用</li>
<li>扫描 C++ 头文件，寻找 <code>Q_OBJECT</code> 宏</li>
<li>生成拓展 C++ 代码，再进行预编译</li>
<li>程序员在使用时，需要继承 QObject 类或者是 QObject 子类，并且包含 <code>Q_OBJECT</code> 宏。</li>
</ol>
<h3 id="🍦-4-Qt应用程序开发"><a href="#🍦-4-Qt应用程序开发" class="headerlink" title="🍦 4. Qt应用程序开发"></a>🍦 4. Qt应用程序开发</h3><h4 id="4-1-Qt-Designer-设计师界面使用"><a href="#4-1-Qt-Designer-设计师界面使用" class="headerlink" title="4.1 Qt Designer 设计师界面使用"></a>4.1 Qt Designer 设计师界面使用</h4><p><img src="/./BetterQT/Qt_Designer.png" alt="Qt Designer"><br>① Qt 控件编辑模式<br>② Qt 信号与槽编辑模式<br>③ Qt 伙伴关系编辑模式<br>④ Qt Tab 顺序编辑模式：可以设置按下 Tab 键的高亮顺序</p>
<h4 id="4-2-Qt-核心——信号与槽"><a href="#4-2-Qt-核心——信号与槽" class="headerlink" title="4.2 Qt 核心——信号与槽"></a>4.2 Qt 核心——信号与槽</h4><p><strong>信号与槽的基本概念</strong><br><img src="/./BetterQT/QtSignalsSlots.drawio.png" alt="Qt Signals and Slots"></p>
<ul>
<li>Qt 中的信号和槽是支持多对多的，即一个信号可以对应多个槽，一个槽可以由多个信号触发。</li>
<li>Qt 中的信号无需实现，可以由函数（普通函数或者槽函数）通过 <code>emit</code> 关键字发送信号传递参数。</li>
</ul>
<h5 id="4-2-1-Qt中如何定义信号"><a href="#4-2-1-Qt中如何定义信号" class="headerlink" title="4.2.1 Qt中如何定义信号"></a>4.2.1 Qt中如何定义信号</h5><ol>
<li>继承 <code>QObject</code> 类或其派生类，同时包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>signals</code> 声明函数信号函数，不需要具体实现信号函数</li>
<li>使用 <code>emit</code> 关键字发送信号</li>
</ol>
<h5 id="4-2-2-Qt中如何定义槽函数"><a href="#4-2-2-Qt中如何定义槽函数" class="headerlink" title="4.2.2 Qt中如何定义槽函数"></a>4.2.2 Qt中如何定义槽函数</h5><ol>
<li>必须包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>[public/protected/private] slots</code> 声明函数</li>
<li>需要具体实现声明的槽函数</li>
</ol>
<h5 id="4-2-3-Qt中如何连接信号与槽（三种写法）"><a href="#4-2-3-Qt中如何连接信号与槽（三种写法）" class="headerlink" title="4.2.3 Qt中如何连接信号与槽（三种写法）"></a>4.2.3 Qt中如何连接信号与槽（三种写法）</h5><ol>
<li><code>SIGNAL/SLOT</code> 宏写法：<br><code>QObject::connect(this, SIGNAL(...), this, SLOT(...));</code></li>
<li>函数指针写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, &amp;SlotFunction)</code></li>
<li>lambda 表达式写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, [=]() &#123; qDebug() &lt;&lt; &quot;...&quot;; &#125;)</code></li>
</ol>
<p>三种写法的比较：</p>
<table>
    <tr>
        <td rowspan="2" colspan="3">连接信号与槽</td> 
        <td colspan="2">宏</td>
        <td colspan="2">函数指针</td>
    </tr>
    <tr>
        <td>编译</td>
        <td>运行</td>
        <td>编译</td>
        <td>运行</td>
    </tr>
    <tr>
        <td rowspan="4">参数类型</td>
        <td colspan="2">完全相同</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td rowspan="2">隐式转换</td>
        <td>向上</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td>向下</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">不可以隐式转换</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
        <tr>
        <td rowspan="3">参数个数</td>
        <td colspan="2">信号=槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号>槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号<槽</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
</table>

<ul>
<li>这样看来好像宏写法相对于函数指针的写法来说，可能会带来一些问题，因为有时候宏写法通过编译后，在运行阶段可能会出现一些问题；而函数指针写法可以在出现这一问题之前（编译阶段）提前发现这一问题，使得程序无法通过编译。</li>
<li>但是事实上，宏写法还是存在一定的好处，当信号函数出现重载时，使用函数指针时，无法直接进行连接（会产生报错），只能使用类型转换来进行函数指针类型的转换，如<code>static_cast&lt;void QSpinBox::*)(int)&gt;</code>。</li>
<li>一般情况下，推荐使用函数指针方式连接信号与槽。</li>
<li>当面对信号与槽函数有重载的情况时，推荐使用宏方式连接。</li>
<li>对于短小的槽函数的调用且功能不被复用时，推荐使用 lambda 方式连接。</li>
</ul>
<h5 id="4-2-4-其他连接信号与槽的方式"><a href="#4-2-4-其他连接信号与槽的方式" class="headerlink" title="4.2.4 其他连接信号与槽的方式"></a>4.2.4 其他连接信号与槽的方式</h5><ul>
<li>使用 Qt Designer 连接信号与槽<br><img src="/./BetterQT/Designer_Connect.png" alt="Qt Designer Connect"></li>
<li>使用”转到槽”方式</li>
<li>信号与槽自动绑定<br>使用 <code>void on_&lt;对象名&gt;_&lt;信号名&gt;(信号参数);</code> 时可以不使用 <code>connect</code> 进行连接，但是当对象名、信号名或参数发生变化时，连接将会失效，且编译不会有错误提示。</li>
</ul>
<h4 id="4-3-Qt-窗口"><a href="#4-3-Qt-窗口" class="headerlink" title="4.3 Qt 窗口"></a>4.3 Qt 窗口</h4><h5 id="4-3-1-窗口的类型"><a href="#4-3-1-窗口的类型" class="headerlink" title="4.3.1 窗口的类型"></a>4.3.1 窗口的类型</h5><p><strong>顶层窗口、次级窗口（父、子窗口）</strong><br><img src="/./BetterQT/Qt_Windows.png" alt="Qt Windows"><br>在该图中，①可以称为顶层窗口（父窗口），②可以称为次级窗口（子窗口）。窗口中的某些按钮、输入框…等就是控件。</p>
<h5 id="4-3-2-设置窗口标志"><a href="#4-3-2-设置窗口标志" class="headerlink" title="4.3.2 设置窗口标志"></a>4.3.2 设置窗口标志</h5><p>在 Qt 中可以使用 <code>setWindowFlags()</code> 来设置窗口标志</p>
<ol>
<li><p>设置窗口无标题栏<br><img src="/./BetterQT/Window_With_No_Title.png" alt="Window With No Title"></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint);</span><br></pre></td></tr></table></figure></li>
<li><p>设置窗口无边框<br><img src="/./BetterQT/Window_With_No_Frame.png" alt="Window With No Frame"></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure></li>
<li><p>设置窗口置顶</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
<p> 如果按照上述方式依次设置窗口标志，我们会发现当设置第 $3$ 步时前面两步的操作都失效了，这是因为设置窗口置顶时，会覆盖前面的设置。我们可以使用“或”符连接这些标志，解决这一问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-4-窗口坐标系与几何布局"><a href="#4-4-窗口坐标系与几何布局" class="headerlink" title="4.4 窗口坐标系与几何布局"></a>4.4 窗口坐标系与几何布局</h4><h5 id="4-4-1-窗口的坐标系"><a href="#4-4-1-窗口的坐标系" class="headerlink" title="4.4.1 窗口的坐标系"></a>4.4.1 窗口的坐标系</h5><img src="./BetterQT/CoordinateSystem.png" alt="Window Coordinate System" style="zoom:50%;" />

<h5 id="4-4-2-窗口的几何布局"><a href="#4-4-2-窗口的几何布局" class="headerlink" title="4.4.2 窗口的几何布局"></a>4.4.2 窗口的几何布局</h5><img src="./BetterQT/WindowLayout.png" alt="Window Layout" style="zoom:50%;" />

<h4 id="4-5-添加图标"><a href="#4-5-添加图标" class="headerlink" title="4.5 添加图标"></a>4.5 添加图标</h4><h5 id="4-5-1-为窗口添加图标"><a href="#4-5-1-为窗口添加图标" class="headerlink" title="4.5.1 为窗口添加图标"></a>4.5.1 为窗口添加图标</h5><ol>
<li>准备图标文件</li>
<li>调用 <code>setWindowIcon</code> 方法</li>
</ol>
<h5 id="4-5-2-为应用程序添加图标（一般使用这种方式）"><a href="#4-5-2-为应用程序添加图标（一般使用这种方式）" class="headerlink" title="4.5.2 为应用程序添加图标（一般使用这种方式）"></a>4.5.2 为应用程序添加图标（一般使用这种方式）</h5><ol>
<li>准备图标文件 <code>logo.ico</code></li>
<li>修改 pro 工程文件 <code>RC_ICONS = &lt;Path&gt;</code></li>
<li>通过此种方式修改图标，可执行程序 <code>.exe</code> 的图标会修改，且不需要额外单独设置窗口图标。</li>
</ol>
<h4 id="4-6-部署产品的三种方式"><a href="#4-6-部署产品的三种方式" class="headerlink" title="4.6 部署产品的三种方式"></a>4.6 部署产品的三种方式</h4><ol>
<li><p>手动部署（不常用，比较繁琐）<br>进入 <code>.exe</code> 文件所在的文件夹（<code>debug</code>目录），双击运行 <code>.exe</code> 文件，会提示缺少的文件（包括<code>dll</code>动态库、<code>plugin</code>插件等），然后找到对应的文件移动到 <code>.exe</code> 文件的同级目录下即可，如下：<br><img src="/./BetterQT/EXE_File_Dictionary.png" alt="EXE File Dictionary"><br>如果配置了环境变量则大概率不会出现报错提示缺少库的问题，那么这种方式就会失效。</p>
</li>
<li><p>使用 windeployqt 部署<br>① 查找 <code>windeployqt.exe</code> 程序<br>② 将 <code>windeployqt.exe</code> 加入环境变量<br>③ 再命令行界面执行命令 <code>windeployqt.exe &lt;exe_file_dir&gt;</code> 完成操作<br><img src="/./BetterQT/WIN_DEPLOY_QT_1.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_2.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_3.png" alt="WIN DEPLOY QT"></p>
</li>
<li><p>使用creator 部署<br>① 项目导航窗口→运行→部署→添加自定义部署<br><img src="/./BetterQT/CREATOR_DEPLOY_1.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_2.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_3.png" alt="CREATOR DEPLOY"><br>② 输入 <code>windeployqt.exe</code> 程序及对应的命令行参数<br><img src="/./BetterQT/CREATOR_DEPLOY_4.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_5.png" alt="CREATOR DEPLOY"><br>③ 执行部署命令<br><img src="/./BetterQT/CREATOR_DEPLOY_6.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_OK.png" alt="CREATOR DEPLOY OK"></p>
</li>
</ol>
<h3 id="🍦-5-Qt-常用控件"><a href="#🍦-5-Qt-常用控件" class="headerlink" title="🍦 5. Qt 常用控件"></a>🍦 5. Qt 常用控件</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/index.html">Qt 6.7</a></p>
<p>一个不错的 Qt 中文文档：<a target="_blank" rel="noopener" href="http://qt5.digitser.top/5.15/zh-CN/">Qt 中文文档 5.15.1 版本</a></p>
<h4 id="5-1-QLabel-标签控件"><a href="#5-1-QLabel-标签控件" class="headerlink" title="5.1 QLabel 标签控件"></a>5.1 <code>QLabel</code> 标签控件</h4><p><code>QLabel</code> 的本质其实就是显示数据。其可以显示文本数据、图片数据。</p>
<img src="./BetterQT/QLabelShowData.png" style="zoom: 20%;" >

<p>了解了这些我们再来看 <code>QLabel</code> 的一些常用属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#text-prop"><code>text</code></a></strong><code>: QString</code></td>
<td align="left">文本内容：纯文本</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#openExternalLinks-prop"><code>openExternalLinks</code></a></strong><code>:bool</code></td>
<td align="left">文本内容：超链接</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#textFormat-prop"><code>textFormat</code></a></strong> <code>: Qt::TextFormat</code></td>
<td align="left">文本内容：不同类型的文本，如富文本等</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#alignment-prop"><code>alignment</code></a></strong><code>: Qt::Alignment</code></td>
<td align="left">文本格式：对齐方式</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#indent-prop"><code>indent</code></a></strong><code>: int</code></td>
<td align="left">文本格式：缩进</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#margin-prop"><code>margin</code></a></strong><code> : int</code></td>
<td align="left">文本格式：边距</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#wordWrap-prop"><code>wordWrap</code></a></strong><code>: bool</code></td>
<td align="left">文本格式：换行</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#pixmap-prop"><code>pixmap</code></a></strong><code>: QPixmap</code></td>
<td align="left">图片内容：显示图片</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#hasSelectedText-prop"><code>hasSelectedText</code></a></strong><code>: const bool</code></td>
<td align="left">方法：文本是否被选中</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#scaledContents-prop"><code>scaledContents</code></a></strong><code>: bool</code></td>
<td align="left">方法：是否缩放内容</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#selectedText-prop"><code>selectedText</code></a></strong><code>: const QString</code></td>
<td align="left">方法：获取选中的内容</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#textInteractionFlags-prop"><code>textInteractionFlags</code></a></strong><code>: Qt::TextInteractionFlags</code></td>
<td align="left">方法：指定标签应如何与用户输入交互，若它显示文本</td>
</tr>
</tbody></table>
<h4 id="5-2-QLineEdit-单行输入框控件"><a href="#5-2-QLineEdit-单行输入框控件" class="headerlink" title="5.2 QLineEdit 单行输入框控件"></a>5.2 <code>QLineEdit</code> 单行输入框控件</h4><p><code>QLineEdit</code> 的本质是用于不确定的输入，如用户的手机号、用户的密码。这样就给了用户一定的自由，但是我们同时需要制定一系列的规则，以校验用户的输入。例如用户输入手机号，我们需要制定一个长度为 <code>11</code> 位的规则，并且输入字符中不包含字母等，以方便开发人员进行校验。当然我们也可以配合一些其他操作来优化用户体验，如：清空（如：快速清空内容）、提示（如：提示输入格式）、记忆（如：记忆之前的输入）等。</p>
<img src="./BetterQT/QLineEditGetData.png" style="zoom: 20%;" >

<p>了解了这些我们可以看一下 <code>QLineEdit</code> 的一些常用属性（不完全，具体还是需要看文档）：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qlineedit.html#clearButtonEnabled-prop"><code>clearButtonEnabled</code></a></strong><code>: bool</code></td>
<td>清空文本框内容<br />该属性保存行编辑不为空时是否显示清除按钮。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlineedit.html#placeholderText-prop"><code>placeholderText</code></a></strong><code>: QString</code></td>
<td>占位符文本，可以用于提示输入内容。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qlineedit.html#inputMask-prop"><code>inputMask</code></a></strong><code>: QString</code></td>
<td>掩码</td>
</tr>
</tbody></table>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarMyself.jpg" alt="NilEra"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">NilEra</p><p class="is-size-6 is-block">C/C++ Developer!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jinan Shandong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">30</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/NilEra-K" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/NilEra-K" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://nano.chemtian.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Thymol Blue</span></span><span class="level-right"><span class="level-item tag">nano.chemtian.top</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CppDev/"><span class="level-start"><span class="level-item">CppDev</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/Gaming/"><span class="level-start"><span class="level-item">Gaming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/QT6/"><span class="level-start"><span class="level-item">QT6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">多线程编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="level-start"><span class="level-item">软件源</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">大数据技术</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/"><span class="level-start"><span class="level-item">ECharts</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/"><span class="level-start"><span class="level-item">HBase</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"><span class="level-start"><span class="level-item">数据可视化</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Axure-RP-9/"><span class="level-start"><span class="level-item">Axure RP 9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构/算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/"><span class="level-start"><span class="level-item">哈希(Hash)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/"><span class="level-start"><span class="level-item">栈(Stack)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/"><span class="level-start"><span class="level-item">树(Tree)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"><span class="level-start"><span class="level-item">PyTorch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/"><span class="level-start"><span class="level-item">闲聊</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/%E8%AE%A1%E5%88%92/"><span class="level-start"><span class="level-item">计划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-29T07:32:17.000Z">2024-07-29</time></p><p class="title"><a href="/2024/07/29/Cpp-Muti-Threaded/">Cpp_Muti_Threaded</a></p><p class="categories"><a href="/categories/CppDev/">CppDev</a> / <a href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-29T07:29:04.000Z">2024-07-29</time></p><p class="title"><a href="/2024/07/29/Cpp-Network-Programming/">Cpp_Network_Programming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-24T02:38:18.000Z">2024-07-24</time></p><p class="title"><a href="/2024/07/24/NginxQuickIN/">NginxQuickIN</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-22T08:18:39.000Z">2024-07-22</time></p><p class="title"><a href="/2024/07/22/DockerQuickIN/">DockerQuickIN</a></p><p class="categories"><a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a> / <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/">Docker</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-23T04:27:44.000Z">2024-06-23</time></p><p class="title"><a href="/2024/06/23/CppGamingDEV-PVZ-BASE-EASYX/">CppGamingDEV_PVZ_BASE_EASYX</a></p><p class="categories"><a href="/categories/CppDev/">CppDev</a> / <a href="/categories/CppDev/Gaming/">Gaming</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Axure-RP-9/"><span class="tag">Axure RP 9</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CppDev/"><span class="tag">CppDev</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECharts/"><span class="tag">ECharts</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EasyX/"><span class="tag">EasyX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GameDev/"><span class="tag">GameDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kaggle/"><span class="tag">Kaggle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QT6/"><span class="tag">QT6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/R/"><span class="tag">R</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tomcat/"><span class="tag">Tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span class="tag">多线程编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="tag">大数据技术</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E5%88%92/"><span class="tag">计划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="tag">软件源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%B2%E8%81%8A/"><span class="tag">闲聊</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE/"><span class="tag">项目</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a><p class="is-size-7"><span>&copy; 2024 NilEra</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024 前方⚡高能</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdnjs.loli.net/ajax/libs/algoliasearch/4.0.3/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdnjs.loli.net/ajax/libs/instantsearch.js/4.3.1/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"2TB5ZZYPCO","apiKey":"00a43f1d62ca7b24c8b78d5f0223c065","indexName":"dev_nilera_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>