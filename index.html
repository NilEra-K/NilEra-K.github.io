<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>Hello, NilEra :-)</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hello, NilEra :-)"><meta name="msapplication-TileImage" content="/img/StarLogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hello, NilEra :-)"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="努力做自己喜欢的事"><meta property="og:type" content="blog"><meta property="og:title" content="Hello, NilEra :-)"><meta property="og:url" content="https://hello-nilera.com/"><meta property="og:site_name" content="Hello, NilEra :-)"><meta property="og:description" content="努力做自己喜欢的事"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hello-nilera.com/img/og_image.png"><meta property="article:author" content="NilEra"><meta property="article:tag" content="Hello NilEra"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hello-nilera.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hello-nilera.com"},"headline":"Hello, NilEra :-)","image":["https://hello-nilera.com/img/og_image.png"],"author":{"@type":"Person","name":"NilEra"},"publisher":{"@type":"Organization","name":"Hello, NilEra :-)","logo":{"@type":"ImageObject","url":"https://hello-nilera.com/img/StarLogo.svg"}},"description":"努力做自己喜欢的事"}</script><link rel="icon" href="/img/StarLogo.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?249654dcf9a3bf70708fdfc6e2b1ec2b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="F6BD78C6BD0096D2218CF88334111125"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/me">我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-12T07:13:57.000Z" title="2024/6/12 15:13:57">2024-06-12</time>发表</span><span class="level-item"><time dateTime="2024-06-17T08:13:32.360Z" title="2024/6/17 16:13:32">2024-06-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/">Spark</a></span><span class="level-item">32 分钟读完 (大约4742个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/12/SparkQuickIN/">SparkQuickIN</a></p><div class="content"><h2 id="快速入门-Spark"><a href="#快速入门-Spark" class="headerlink" title="快速入门 Spark"></a>快速入门 Spark</h2><p>[TOC]</p>
<h3 id="⛳︎-1-开始-Spark"><a href="#⛳︎-1-开始-Spark" class="headerlink" title="⛳︎ 1. 开始 Spark"></a>⛳︎ 1. 开始 Spark</h3><p><strong>Spark官网</strong>：<a target="_blank" rel="noopener" href="https://spark.apache.org/">Apache Spark™ - Unified Engine for large-scale data analytics</a></p>
<h4 id="1-1-什么是Spark"><a href="#1-1-什么是Spark" class="headerlink" title="1.1 什么是Spark"></a>1.1 什么是Spark</h4><p>Spark官网的解释：Apache Spark™ is a unified analytics engine for large-scale data processing.</p>
<p><strong>Apache Spark</strong> 是专为大规模数据处理而设计的快速通用的计算引擎。<code>Spark</code>是加州大学伯克利分校的 <em><strong>AMP实验室</strong></em> 所开源的类 <code>Hadoop MapReduce</code> 的通用并行计算框架，<code>Spark</code> 拥有 <code>Hadoop MapReduce</code> 所具有的优点，但不同于 <code>MapReduce</code> 的是：<code>Job</code> 中间输出结果可以缓存在内存中，从而不再需要读写 <code>HDFS</code>，减少磁盘数据交互，因此 <code>spark</code> 能更好地适用于数据挖掘与机器学习等需要迭代的算法。</p>
<p><code>Spark</code>是 <code>Scala</code> 编写，方便快速编程。</p>
<p><strong>其特点是</strong>：高速、使用简单、通用、可以在多处运行。</p>
<h4 id="1-2-总体技术栈讲解"><a href="#1-2-总体技术栈讲解" class="headerlink" title="1.2 总体技术栈讲解"></a>1.2 总体技术栈讲解</h4><img src="./SparkQuickIN/TechStack.png" style="zoom: 33%;" />

<p><code>Spark</code> 提供了 <code>Sparkcore RDD</code>、<code>Spark SQL</code>、<code>Spark Streaming</code>、<code>Spark MLlib</code>、<code>Spark GraphX</code>等技术组件，可以一站式的完成大数据领域的离线批处理、交互式查询、流式计算、机器学习、图计算等常见的任务。这就是<code>Spark</code>一站式开发的特点。</p>
<h4 id="1-3-Spark-和-MapReduce-的区别"><a href="#1-3-Spark-和-MapReduce-的区别" class="headerlink" title="1.3 Spark 和 MapReduce 的区别"></a>1.3 <code>Spark</code> 和 <code>MapReduce</code> 的区别</h4><h5 id="1-3-1-MapReduce-的原理"><a href="#1-3-1-MapReduce-的原理" class="headerlink" title="1.3.1 MapReduce 的原理"></a>1.3.1 MapReduce 的原理</h5><p><code>MapReduce</code> 在运算时需要多次进行磁盘 I&#x2F;O。下面是一个简单的 <code>MapReduce</code> 过程：</p>
<p>视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TB4y1i7kk/">https://www.bilibili.com/video/BV1TB4y1i7kk/</a></p>
<p>在这个视频中，可以看出<code>MapReduce</code> 过程中需要多次磁盘 I&#x2F;O，落地到<code>HDFS</code>上。</p>
<h5 id="1-3-2-Spark-是如何做的"><a href="#1-3-2-Spark-是如何做的" class="headerlink" title="1.3.2 Spark 是如何做的"></a>1.3.2 Spark 是如何做的</h5><img src="./SparkQuickIN/MapReduce_VS_Spark.png" style="zoom: 40%;" >

<p>可以看到，<code>MapReduce</code> 的多个 <code>Job</code> 之间相互独立，每个 <code>Job</code> 完成后的数据都需要存储到文件系统中。每个 <code>Job</code> 中也可能会存在大量的磁盘 I&#x2F;O ，这样会使得 <code>MapReduce</code> 的速度很慢。相比于 <code>MapReduce</code>，<code>Spark</code>使用了 <code>DAG</code> 有向无环图。使多个任务串联起来，将结果存储在内存中（当然内存不够还是要将数据缓存在磁盘中）直接进行运算，避免了大量的磁盘I&#x2F;O。</p>
<h5 id="1-3-3-Spark-和-MapReduce-的一些联系"><a href="#1-3-3-Spark-和-MapReduce-的一些联系" class="headerlink" title="1.3.3 Spark 和 MapReduce 的一些联系"></a>1.3.3 <code>Spark</code> 和 <code>MapReduce</code> 的一些联系</h5><p><code>Spark</code> 和 <code>MapReduce</code> 都是分布式计算框架，<code>Spark</code> 计算中间结果基于内存缓存，<code>MapReduce</code> 基于<code>HDFS</code>存储。也正因此，<code>Spark</code>处理数据的能力一般是 <code>MapReduce</code>的三到五倍以上，<code>Spark</code> 中除了基于内存计算这一个计算快的原因，还有<code>DAG(DAG Schedule)</code>有向无环图来切分任务的执行先后顺序。</p>
<h4 id="1-4-Spark-API"><a href="#1-4-Spark-API" class="headerlink" title="1.4 Spark API"></a>1.4 Spark API</h4><p>Spark API 有多种语言支持，分别包括：<code>Scala</code>、<code>Java</code>、<code>Python</code>、<code>R</code>、<code>SQL</code> 等。</p>
<h4 id="1-5-Spark-的运行模式"><a href="#1-5-Spark-的运行模式" class="headerlink" title="1.5 Spark 的运行模式"></a>1.5 Spark 的运行模式</h4><ul>
<li><code>Local</code>：多用于本地测试，如在：<code>Eclipse</code>、<code>IDEA</code> 中编写测试程序等。</li>
<li><code>Standalone</code>：<code>Spark</code> 自带的资源调度框架，它支持完全分布式。<code>Standalone</code>模式也叫作<strong>独立模式</strong>，<strong>其自带完整的服务，可单独部署到一个集群中，无序依赖任何其他资源管理系统。</strong> 从一定程度上来说，该模式是 <code>Local</code> 模式和 <code>Yarn</code> 模式的基础。</li>
<li><code>Yarn</code>： Hadoop 生态圈里的一种资源调度框架，<code>Spark</code>也是可以基于 <code>Yarn</code> 来计算的。 若要使用 <code>Yarn</code> 来进行资源调度，必须实现<code>ApplicationMaster</code> 接口，<code>Spark</code> 实现了这个接口，所以可以基于 <code>Yarn</code> 来进行资源调度。</li>
<li><code>Mesos</code>：也是一种资源调度框架（了解即可）。</li>
</ul>
<h3 id="🥑-2-SparkCore"><a href="#🥑-2-SparkCore" class="headerlink" title="🥑 2. SparkCore"></a>🥑 2. SparkCore</h3><h4 id="2-1-RDD"><a href="#2-1-RDD" class="headerlink" title="2.1 RDD"></a>2.1 RDD</h4><h5 id="2-1-1-RDD-的概念"><a href="#2-1-1-RDD-的概念" class="headerlink" title="2.1.1 RDD 的概念"></a>2.1.1 RDD 的概念</h5><p><code>RDD(Resilient Distribute Dataset)</code>：弹性分布式数据集。</p>
<p><code>RDD</code> → <code>算子</code> → <code>Other RDD</code>，<code>RDD</code> 经过算子的运算会变成其他的 <code>RDD</code>。</p>
<p>（重点）<code>RDD</code>的特点：① 分区的；② 并行操作的；③ 不可变的。</p>
<h5 id="2-1-2-RDD-的五大特性"><a href="#2-1-2-RDD-的五大特性" class="headerlink" title="2.1.2 RDD 的五大特性"></a>2.1.2 RDD 的五大特性</h5><ol>
<li>每个<code>RDD</code> 由一系列的 <code>Partition</code> 组成。</li>
<li>函数是作用在每一个 <code>Partition (Split)</code> 上的。</li>
<li><code>RDD</code> 中有一系列的依赖关系，或者说每个<code>RDD</code>都会依赖其他一系列的<code>RDD</code>。</li>
<li>分区器是作用在 <code>&lt;K, V&gt;</code> 格式的 <code>RDD</code> 上，即：<code>&lt;K, V&gt;</code> 的 <code>RDD</code> 可以通过 <code>Partition</code> 进行自定义分区。</li>
<li><code>RDD</code>提供一系列的最佳计算位置。数据在哪里，计算就在哪里，移动数据不如移动计算。</li>
</ol>
<h5 id="2-1-3-RDD-理解图"><a href="#2-1-3-RDD-理解图" class="headerlink" title="2.1.3 RDD 理解图"></a>2.1.3 RDD 理解图</h5><img src="./SparkQuickIN/SparkRDD.png" style="zoom:40%;" >



<p><code>Spark</code> 中读取文件是使用 <code>SparkContext</code> 对象调用 <code>textFile</code> 方法，实际上底层和 <code>MapReduce</code> 读取 <code>HDFS</code> 文件的方式是相同的，读取之前先要进行 <code>split</code> 切片。默认情况下 <code>Split</code> 的大小和 <code>Block</code> 块的大小相同。</p>
<p>一些问题：</p>
<ol>
<li><p><code>RDD</code>的分布式体现在那些方面？</p>
<p><code>RDD</code> 由一系列的 <code>Partition</code> 构成，并且 <code>Partition</code> 是分布在不同的节点上的。这就体现了 <code>RDD</code> 的分布式。</p>
</li>
<li><p>哪里体现了 <code>RDD</code> 的弹性？</p>
<p><code>RDD</code> 由一系列的 <code>Partition</code> 组成，其大小和数量都是可以改变的。默认情况下，<code>Partition</code> 的个数和 <code>Block</code> 块的个数相同。</p>
</li>
<li><p>哪里体现了 <code>RDD</code> 的容错？</p>
<p><code>RDD</code> 之间存在一系列的依赖关系，<code>子RDD</code> 可以找到对应的<code>父RDD</code> ，然后通过一系列计算得到得出响应的结果，这就是容错的体现。</p>
<p><code>RDD</code> 提供计算最佳位置，体现了数据本地化，体现了大数据中<strong>”移动数据不如移动计算“</strong>的理念。</p>
</li>
</ol>
<p>一些注意事项：</p>
<ol>
<li><code>textFile</code> 方法底层封装的是 <code>MapReduce</code> 读取文件的方式，读取文件之前先进行 <code>Split</code> 切片，默认 <code>Split</code>  大小是一个 <code>Block</code> 的大小。</li>
<li><code>RDD</code> 实际上不存储数据，但是为了方便理解，可以理解为存储数据。</li>
<li>什么是 <code>&lt;K, V&gt;</code> 格式的 <code>RDD</code>，如果 <code>RDD</code> 里面存储的数据都是二元组对象，那么这个 <code>RDD</code> 我们就叫做 <code>&lt;K, V&gt;</code> 格式的 <code>RDD</code>。</li>
</ol>
<h5 id="2-1-4-SparkRDD-编程模型"><a href="#2-1-4-SparkRDD-编程模型" class="headerlink" title="2.1.4 SparkRDD 编程模型"></a>2.1.4 SparkRDD 编程模型</h5><ol>
<li><p>创建 <code>SparkContext</code> 对象</p>
</li>
<li><p>创建 <code>RDD</code></p>
</li>
<li><p>计算 <code>RDD</code></p>
</li>
<li><p>输出结果（如控制台打印测试，存储等）</p>
</li>
<li><p>关闭 <code>SparkContext</code></p>
</li>
</ol>
<h5 id="2-1-5-WordCount-案例"><a href="#2-1-5-WordCount-案例" class="headerlink" title="2.1.5 WordCount 案例"></a>2.1.5 <code>WordCount</code> 案例</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 第一步: 创建 SparkContext 对象</span></span><br><span class="line">        <span class="comment">// 对于每个 Spark 程序来说, 最重要的就是两个对象: SparkConf 和 SparkContext</span></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="type">SparkConf</span>()</span><br><span class="line">        conf.setAppName(<span class="string">&quot;WordCount&quot;</span>).setMaster(<span class="string">&quot;Local&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sparkContext = <span class="type">SparkContext</span>(conf)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 RDD</span></span><br><span class="line">        <span class="keyword">val</span> line: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;files/order.csv&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 RDD</span></span><br><span class="line">        <span class="keyword">val</span> word: <span class="type">RDD</span>[<span class="type">String</span>] = sc.flatMap(x =&gt; x.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> pair: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = word.map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// val result: RDD[(String, Int)] = pair.reduceByKey((x, y) =&gt; &#123;x + y&#125;)</span></span><br><span class="line">        <span class="keyword">val</span> result: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = pair.reduceByKey((x, y) =&gt; &#123;</span><br><span class="line">            println(x + <span class="string">&quot;:&quot;</span> + y)</span><br><span class="line">            x + y</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 RDD</span></span><br><span class="line">        result.foreach(println)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭 SparkContext</span></span><br><span class="line">        sparkContext.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Spark-任务执行原理"><a href="#2-2-Spark-任务执行原理" class="headerlink" title="2.2 Spark 任务执行原理"></a>2.2 Spark 任务执行原理</h4><p>从下图中，我们可以看到 <strong>Spark</strong> 的主要角色：</p>
<img src="./SparkQuickIN/SparkExecutor.png" alt="SparkExecutor" style="zoom:33%;" />

<p>一些名词的解释：</p>
<ul>
<li><code>Master Node</code> 主节点</li>
<li><code>Worker Node</code> 从节点</li>
<li><code>Driver</code> 驱动程序</li>
<li><code>Executor</code> 执行节点</li>
<li><code>Cluster Manager</code> 集群管理者</li>
</ul>
<h5 id="2-2-1-Spark-架构的类比"><a href="#2-2-1-Spark-架构的类比" class="headerlink" title="2.2.1 Spark 架构的类比"></a>2.2.1 Spark 架构的类比</h5><p>我们可以简单的将这个架构和 <strong>YARN</strong> 对比一下：<code>Master</code> 就相当于 <code>YARN</code> 中的 <code>ResourceManager</code>，<code>Worker</code> 就相当于 <code>YARN</code> 中的 <code>NodeManager</code>，<code>Driver</code> 相当于 <code>YARN</code> 中的 <code>Application</code>。</p>
<h5 id="2-2-2-Spark-执行原理详细说明"><a href="#2-2-2-Spark-执行原理详细说明" class="headerlink" title="2.2.2 Spark 执行原理详细说明"></a>2.2.2 Spark 执行原理详细说明</h5><ol>
<li><p><code>Master</code> 和 <code>Worker</code> 节点</p>
<p>搭建 <strong>Spark</strong> 集群的时候我们就已经设置好了 <code>Master</code> 节点和 <code>Worker</code> 节点，一个集群有多个<code>Master</code>节点和多个<code>Worker</code>节点。</p>
<ul>
<li><p><code>Master</code> 节点常驻 <code>Master</code> 守护进程，负责管理 <code>Worker</code> 节点，我们从 <code>Master</code> 节点提交应用。</p>
</li>
<li><p><code>Worker</code> 节点常驻 <code>Worker</code> 守护进程，与 <code>Master</code> 节点通信，并且管理 <code>Executor</code> 进程。</p>
</li>
</ul>
<p>一台机器可以同时作为 <code>Master</code> 和 <code>Worker</code> 节点（e.g. 有四台机器，可以选择一台设置为 <code>Master</code>节点，然后剩下三台设为 <code>Worker</code>节点，也可以把四台都设为 <code>Worker</code> 节点，这种情况下，有一个机器既是 <code>Master</code> 节点又是 <code>Worker</code> 节点）。</p>
<p>一个 <code>Spark</code> 应用程序分为一个驱动程序 <code>Driver</code> 和多个执行程序 <code>Executors</code> 两种。</p>
</li>
<li><p><code>Driver</code> 和 <code>Executor</code> 进程<br><code>Driver</code> 进程就是应用的 <code>main()</code> 函数并且构建 <code>SparkContext</code> 对象，当我们提交了应用之后，便会启动一个对应的 <code>Driver</code> 进程，<code>Driver</code> 本身会根据我们设置的参数占有一定的资源（主要指 <em><strong>CPU Core</strong></em> 和 <em><strong>Memory</strong></em>）。</p>
<p>根据部署模式的不同，<code>Driver</code> 可以运行在 <code>Master</code> 上，也可以运行 <code>Worker</code>上，<code>Driver</code> 与集群节点之间有频繁的通信。上图展示了 <code>Driver</code> 在 <code>Master</code> 上的部署的情况。</p>
<ul>
<li><p>如上图所示，<code>Driver</code>首先会向**集群管理者<code>Cluster Manager</code>**，如<code>Standalone</code>、<code>Yarn</code>、<code>Mesos</code> 申请 <strong>Spark</strong> 应用所需的资源，也就是<code>Executor</code>，然后集群管理者会根据 <strong>Spark</strong> 应用所设置的参数在各个 <code>Worker</code> 上分配一定数量的 <code>Executor</code>，每个 <code>Executor</code> 都占用一定数量的 <code>CPU</code>和 <code>Memory</code>。</p>
</li>
<li><p>在申请到应用所需的资源以后，<code>Driver</code> 就开始调度和执行我们编写的应用代码了。<code>Driver</code> 进程会将我们编写的 <code>Spark</code> 应用代码拆分成多个 <code>Stage</code>，每个<code>Stage</code> 执行一部分代码片段，并为每个 <code>Stage</code> 创建一批 <code>Tasks</code>，然后将这些 <code>Tasks</code>分配到各个 <code>Executor</code>中执行。这一步即 <code>Driver ---Task--&gt; Worker</code>。</p>
</li>
<li><p><code>Executor</code> 进程宿主在 <code>worker</code> 节点上，一个 <code>Worker</code>可以有多个 <code>Executor</code>。每个 <code>Executor</code> 持有一个线程池，每个线程可以执行一个 <code>Task</code>，<code>Executor</code> 执行完 <code>Task</code> 以后将结果返回给 <code>Driver</code>，每个 <code>Executor</code> 执行的 <code>Task</code> 都属于同一个应用。此外 <code>Executor</code> 还有一个功能就是为应用程序中要求缓存的 <code>RDD</code> 提供内存式存储，<code>RDD</code> 是直接缓存在 <code>Executor</code>进程内的，因此任务可以在运行时充分利用缓存数据加速运算。这一步即 <code>Worker ---Result--&gt; Driver</code>。</p>
</li>
<li><p><code>Driver</code> 负责<strong>任务 <code>Tasks</code> 的分发</strong>和<strong>结果<code>Results</code>的回收</strong>，即任务的调度。如果 <code>Task</code> 的计算结果非常大就不要回收了，会造成<code>OOM</code>（我们在执行程序时可以通过参数指定 <code>Driver</code> 的内存大小，如 <code>1G</code>，如果一个 <code>Worker</code> 的结果是 <code>510M</code>，那么两个接节点上的结果就会超过 <code>1G</code>，导致 <code>OOM</code>）。</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-RDD-算子"><a href="#2-2-RDD-算子" class="headerlink" title="2.2 RDD 算子"></a>2.2 RDD 算子</h4><p><strong>RDD有两种操作算子：</strong>分别为<strong>转换算子(Transformation)</strong> 和 **行动算子(Action)**。算子其实就是函数，只不过在 <strong>Scala</strong> 中称为算子。</p>
<p>下面表格列出了部分 <strong>RDD 算子</strong>，完整内容可以查看 <em><strong>[SparkRDD](<a target="_blank" rel="noopener" href="https://spark.apache.org/docs/3.0.1/rdd-programming-guide.html">RDD Programming Guide - Spark 3.0.1 Documentation (apache.org)</a>)</strong></em> 文档。</p>
<img src="D:\Blog\source\_posts\SparkQuickIN\DocLocation.jpg"  />

<table>
    <tr>
        <th>算子类型</th>
        <th>算子方法</th>
        <th>算子转换</th>
    </tr>
    <tr>
        <td rowspan="14">Transformations</td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">map(f: T=>U)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[U]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">filter(f: T=>Bool)</code>
        </td>
         <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[T]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">flatMap(f: T=>Seq[U])</code> 
        </td>
         <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[U]</code> 
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">sample(fraction: Float)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[T](Deterministic sampling)</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">groupByKey()</code>
        </td>
          <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, Seq[V])]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">reduceByKey(f: (V, V)=>V)</code>
        </td>
         <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, V)]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">union()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[T], RDD[T]) => RDD[T]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">join()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[(K, V)], RDD[(K, W)]) => RDD[(K, (V, W))]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">cogroup()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[(K, V)], RDD[(K, W)]) => RDD([K, (Seq[V], Seq[W])])</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">crossProduct()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[T], RDD[U]) => (RDD[(T, U)])</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">mapValues(f: V=>W)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, W)](Preserves Partitioning)</code>
        </td>        
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">sort(c: Comparator[K])</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, V)]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">partitionBy(p: Partitioner[K])</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, V)]</code>
        </td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td rowspan="7">Actions</td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">count()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => Long</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">collect()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => Seq[T]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">reduce(f: (T, T)=>T)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => T</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">lookup(k: K)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => Seq[V](On hash/range partitioned RDDs)</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">save(path: String)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">Outputs RDD to a Storage System, e.g. HDFS</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">foreach(func)</code>
        </td>
        <td>-</td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<h5 id="2-2-1-Transformation-转换算子"><a href="#2-2-1-Transformation-转换算子" class="headerlink" title="2.2.1 Transformation 转换算子"></a>2.2.1 Transformation 转换算子</h5><p>点击快速跳转到转换算子列表：<a target="_blank" rel="noopener" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#transformations">Transformations</a></p>
<p><strong>Transformation 转换算子</strong>有延迟执行的特点，具有**懒加载(Lazy)**的特性。</p>
<p>下面列出常用的行动算子及用法：</p>
<ul>
<li><code>map(func)</code> 返回一个新的分布式数据集，由每个原元素经过<code>func</code>函数转换后组成。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;MapDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list, <span class="number">5</span>)</span><br><span class="line">        listRDD.foreach(println)</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">val</span> retRDD = listRDD.map(num =&gt; num * <span class="number">7</span>)</span><br><span class="line">        retRDD.foreach(num =&gt; println(num))</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mapPartition(func)</code> 将函数用在每个<code>RDD</code>的分区上</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MapPartitionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;MapPartitionDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list, <span class="number">3</span>)	<span class="comment">// 设置三个分区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对比 map 和 mapPartition 的区别</span></span><br><span class="line">        listRDD.map( x =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;Map 执行一次&quot;</span>)</span><br><span class="line">            x + <span class="number">1</span></span><br><span class="line">        &#125;).foreach(println)</span><br><span class="line"></span><br><span class="line">        println()</span><br><span class="line"></span><br><span class="line">        listRDD.mapPartitions( x =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;MapPartition 执行一次&quot;</span>)</span><br><span class="line">            x.map(x =&gt; &#123;println(<span class="string">&quot;mapPartition 里的map&quot;</span>); x + <span class="number">1</span>&#125;)  <span class="comment">// 这个 map 不是 RDD 里的 map, 而是 Iterator 中的 map</span></span><br><span class="line">        &#125;).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filter(func)</code>返回一个新的数据集，由经过<code>func</code>函数后返回值为<code>true</code>的元素组成。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FilterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;FilterDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list)</span><br><span class="line">        <span class="keyword">val</span> retRDD = listRDD.filter(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        retRDD.foreach(println)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flatMap(func)</code>类似于<code>map</code>，但是每一个输入元素，会被映射为 <code>0</code> 到多个输出元素（因此，<code>func</code> 函数的返回值是一个 <code>Seq</code>，而不是单一元素）。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FlatMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;FlatMapDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">&quot;hello you&quot;</span>, <span class="string">&quot;hello he&quot;</span>, <span class="string">&quot;hello me&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list)</span><br><span class="line">        <span class="keyword">val</span> wordsRDD = listRDD.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        wordsRDD.foreach(println)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sample(withReplacement, frac, seed)</code>根据给定的随机种子 <code>seed</code>，随机抽样出数量为 <code>frac</code> 的数据。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>union(otherDataset)</code>返回一个新的数据集，由原数据集和参数联合而成。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>groupByKey([numTasks])</code>在一个由 <code>&lt;K, V&gt;</code> 对组成的数据集上调用，返回一个 <code>&lt;K, Seq[V]&gt;</code> 对的数据集。注意：默认情况下，使用 <code>8</code> 个并行任务进行分组，你可以传入 <code>numTask</code> 可选参数，根据数据量设置不同数目的 <code>Task</code>。使用该算子可以将相同<code>Key</code>的元素聚集到一起，最终把所有相同<code>Key</code>的元素合并成一个元素，该元素的<code>Key</code>不变，<code>Value</code>则聚集到一个集合中。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>reduceByKey(func, [numTasks])</code>在一个<code>&lt;K, V&gt;</code>对的数据集上使用，返回一个<code>&lt;K, V&gt;</code>对的数据集，<code>key</code>相同的值，都被使用指定的<code>reduce</code>函数聚合到一起。和 <code>groupByKey</code>类似，任务的个数是可以通过第二个可选参数来配置的。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>join(otherDataset, [numTasks])</code>在类型为<code>&lt;K, V&gt;</code>和<code>&lt;K, W&gt;</code>类型的数据集上调用，返回一个<code>&lt;K, &lt;V, W&gt;&gt;</code>对，每个<code>key</code>中的所有元素都在一起的数据集。</li>
<li><code>sortByKey()</code> 和 <code>sortBy()</code>，<code>sortByKey()</code> 函数需要在类型为 <code>&lt;K, V&gt;</code> 类型的数据集上调用。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SortByKeyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;SortByKeyDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(</span><br><span class="line">            <span class="string">&quot;1,李  磊,22,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;2,刘银鹏,23,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3,齐彦鹏,22,180&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4,杨  柳,22,168&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5,敦  鹏,20,175&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> listRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.parallelize(list)</span><br><span class="line">        listRDD.foreach(println)</span><br><span class="line">        println()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3,齐彦鹏,22,180</span></span><br><span class="line">        <span class="comment">// 1,李磊,22,175</span></span><br><span class="line">        <span class="comment">// 2,刘银鹏,23,175</span></span><br><span class="line">        <span class="keyword">val</span> resultRDD = listRDD.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields = x.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            println(fields(<span class="number">0</span>) + <span class="string">&quot; &quot;</span> + fields(<span class="number">1</span>) + <span class="string">&quot; &quot;</span> + fields(<span class="number">2</span>) + <span class="string">&quot; &quot;</span> + fields(<span class="number">3</span>) + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            (fields(<span class="number">0</span>), fields(<span class="number">1</span>), fields(<span class="number">2</span>), fields(<span class="number">3</span>))</span><br><span class="line">        &#125;).map(x =&gt; &#123;(x._3, x._1)&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分区数会影响最终打印结果, 设置分区为 2, 所有分区最终会聚合为两个分区, 打印时显示每个分区的排序</span></span><br><span class="line">        <span class="comment">// 这就可能导致打印输出时出现不同分区排序数据交叉的情况。</span></span><br><span class="line">        <span class="comment">// 所以我们一般设置分区为 1, 表示排序结果聚合到一个分区</span></span><br><span class="line">        resultRDD.sortByKey(<span class="literal">true</span>, <span class="number">2</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">val</span> sortBy_RDD = listRDD.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields = x.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="comment">// println(fields(0) + &quot; &quot; + fields(1) + &quot; &quot; + fields(2) + &quot; &quot; + fields(3) + &quot; &quot;)</span></span><br><span class="line">            (fields(<span class="number">0</span>), fields(<span class="number">1</span>), fields(<span class="number">2</span>), fields(<span class="number">3</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">        println(<span class="string">&quot;SortBy_001&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._1, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;SortBy_002&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._2, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;SortBy_003&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._3, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;SortBy_004&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._4, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-Action-行动算子"><a href="#2-2-2-Action-行动算子" class="headerlink" title="2.2.2 Action 行动算子"></a>2.2.2 Action 行动算子</h5><p><strong>Action 行动算子</strong>具有触发执行的特点，一个 <code>Application</code> 应用程序有几个 <code>Action</code> 类算子执行，就有几个 <code>Job</code> 运行。</p>
<p>点击快速跳转到 SparkRDD Action 列表： <a target="_blank" rel="noopener" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#actions">Actions</a></p>
<p>下面列出常用的行动算子及用法：</p>
<ul>
<li><p><code>reduce(func)</code> 通过函数 <code>func</code> 聚集数据集中的所有元素。<code>func</code> 函数接受 <code>2</code> 个参数，返回 <code>1</code> 个值。这个函数必须是关联性的，确保可以被正确的并发执行。关于 <code>reduce</code> 的执行过程，可以对比 <strong>Scala</strong> 中类似的 <code>reduce</code>函数。</p>
<p>不同于 <code>Transformation</code> 算子，执行后结果是<code>RDD</code>，执行 <code>Action</code> 算子之后，其结果不再是 <code>RDD</code>，而是一个<strong>标量</strong>。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Action_Reduce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;Action_Reduce&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">        <span class="comment">// val list = List(0, 5, 15, 20, 25, 30) // 如果用这个 list 输出为: 95</span></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(</span><br><span class="line">            <span class="string">&quot;1,李  磊,22,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;2,刘银鹏,23,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3,齐彦鹏,22,180&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4,杨  柳,22,168&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5,敦  鹏,20,175&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list)</span><br><span class="line">        listRDD.foreach(println)</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">val</span> ret = listRDD.reduce(</span><br><span class="line">            (v1, v2) =&gt; &#123;</span><br><span class="line">                println(<span class="string">&quot;[LOGS] v1      &gt; &quot;</span> + v1 + <span class="string">&quot; &quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;[LOGS] v2      &gt; &quot;</span> + v2 + <span class="string">&quot; &quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;[LOGS] v1 + v2 &gt; &quot;</span> + (v1 + v2))</span><br><span class="line">                v1 + v2</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;ret: &quot;</span> + ret)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输出如下：</span><br><span class="line">3,齐彦鹏,22,180</span><br><span class="line">1,李  磊,22,175</span><br><span class="line">4,杨  柳,22,168</span><br><span class="line">2,刘银鹏,23,175</span><br><span class="line">5,敦  鹏,20,175</span><br><span class="line"></span><br><span class="line">[LOGS] v1      &gt; 3,齐彦鹏,22,180 </span><br><span class="line">[LOGS] v2      &gt; 4,杨  柳,22,168 </span><br><span class="line">[LOGS] v1 + v2 &gt; 3,齐彦鹏,22,1804,杨  柳,22,168</span><br><span class="line">[LOGS] v1      &gt; 3,齐彦鹏,22,1804,杨  柳,22,168 </span><br><span class="line">[LOGS] v2      &gt; 5,敦  鹏,20,175 </span><br><span class="line">[LOGS] v1 + v2 &gt; 3,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175</span><br><span class="line">[LOGS] v1      &gt; 1,李  磊,22,175 </span><br><span class="line">[LOGS] v2      &gt; 2,刘银鹏,23,175 </span><br><span class="line">[LOGS] v1 + v2 &gt; 1,李  磊,22,1752,刘银鹏,23,175</span><br><span class="line">[LOGS] v1      &gt; 1,李  磊,22,1752,刘银鹏,23,175 </span><br><span class="line">[LOGS] v2      &gt; 3,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175 </span><br><span class="line">[LOGS] v1 + v2 &gt; 1,李  磊,22,1752,刘银鹏,23,1753,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175</span><br><span class="line">ret: 1,李  磊,22,1752,刘银鹏,23,1753,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175</span><br></pre></td></tr></table></figure>



<ul>
<li><code>collect</code> 在 <code>Driver</code> 的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用 <code>filter</code> 或者其它操作后，返回一个足够小的数据子集再使用，直接将整个 <code>RDD</code> 集 <code>Collect</code>返回，很可能会让 <code>Driver</code> 程序 <code>OOM</code>，这点尤其需要注意。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>count</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>take</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>saveAsTextFile</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>foreach</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>saveAsNewAPIHadoopFile</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-其他算子"><a href="#2-2-3-其他算子" class="headerlink" title="2.2.3 其他算子"></a>2.2.3 其他算子</h5><p>Spark中还有许多其他种类的算子，体现了 <code>Spark</code> 算子的灵活性，其中包括将数据进行持久化的算子。</p>
<ul>
<li><code>cache</code>：懒加载执行的，必须有一个 <code>Action</code> 触发算子触发执行。 </li>
<li><code>persist</code>：懒加载执行的，必须有一个 <code>Action</code> 触发算子触发执行。 </li>
<li><code>checkpoint</code>：算子不仅能将 <code>RDD</code> 持久化到磁盘，还能切断 <code>RDD</code> 之间的依赖关系。</li>
</ul>
<h5 id="2-2-3-宽依赖和窄依赖"><a href="#2-2-3-宽依赖和窄依赖" class="headerlink" title="2.2.3 宽依赖和窄依赖"></a>2.2.3 宽依赖和窄依赖</h5><ol>
<li><p>宽依赖</p>
<p>① 子 <code>RDD</code> 的每个分区依赖于所有的父 <code>RDD</code> 分区 </p>
<p>② 对单个 <code>RDD</code> 基于 <code>Key</code>进行重组和 <code>Reduce</code>，如 <code>groupByKey</code>、<code>reduceByKey</code></p>
<p>③ 对两个 <code>RDD</code> 基于 <code>Key</code> 进行 <code>join</code> 和重组，如 <code>join</code></p>
<p>④ 经过大量 <code>shuffle</code> 生成的 <code>RDD</code>，建议进行缓存。这样避免失败后重新计算带来的开销。</p>
</li>
<li><p>窄依赖</p>
<p>① 子<code>RDD</code>的每个分区依赖于常数个父分区（与数据规模无关）</p>
<p>② 输入输出一对一的算子，且结果<code>RDD</code>的分区结构不变。主要是<code>map/flatmap</code></p>
<p>③ 输入输出一对一的算子，但结果<code>RDD</code>的分区结构发生了变化，如<code>union/coalesce</code></p>
<p>④ 从输入中选择部分元素的算子，如 <code>filter</code>、<code>distinct</code>、<code>substract</code>、<code>sample</code></p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-11T08:03:22.000Z" title="2024/6/11 16:03:22">2024-06-11</time>发表</span><span class="level-item"><time dateTime="2024-06-21T07:31:50.570Z" title="2024/6/21 15:31:50">2024-06-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/">项目</a></span><span class="level-item">1 小时读完 (大约10206个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/11/OnlineTravelBigdataPlatform/">OnlineTravelBigdataPlatform</a></p><div class="content"><h2 id="🌳-在线旅游大数据平台项目"><a href="#🌳-在线旅游大数据平台项目" class="headerlink" title="🌳 在线旅游大数据平台项目"></a>🌳 在线旅游大数据平台项目</h2><p>
    <label for="file">完成度：</label>
    <progress max="100" value="100"> 100% </progress>
</p>


<p><strong>日期任务清单</strong></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
项目开始日期: 2024-06-11</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解项目的背景以及整个系统的架构</li>
<li><input checked="" disabled="" type="checkbox"> 了解系统需要完成的主要功能</li>
<li><input checked="" disabled="" type="checkbox"> 了解系统整个架构</li>
<li><input checked="" disabled="" type="checkbox"> 完成数据服务端的部署</li>
<li><input checked="" disabled="" type="checkbox"> 完成数据客户端的部署</li>
<li><input checked="" disabled="" type="checkbox"> 了解数据集</li>
<li><input checked="" disabled="" type="checkbox"> 认识消息队列 Kafka</li>
<li><input checked="" disabled="" type="checkbox"> 完成消息队列 Kafka 的部署</li>
<li><input checked="" disabled="" type="checkbox"> 了解消息队列 Kafka 的基本应用</li>
<li><input checked="" disabled="" type="checkbox"> 使用 Flume 收集数据到 Kafka</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-12</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解实时数据分析所用到的技术</li>
<li><input checked="" disabled="" type="checkbox"> 了解 <code>SparkStreaming</code> 和 <code>Flink</code></li>
<li><input checked="" disabled="" type="checkbox"> 了解 <code>SparkStreaming</code> 的核心概念</li>
<li><input checked="" disabled="" type="checkbox"> 了解数据源</li>
<li><input checked="" disabled="" type="checkbox"> 借助<code>netcat</code>实践<code>Kafka</code></li>
<li><input checked="" disabled="" type="checkbox"> 了解转换操作</li>
<li><input checked="" disabled="" type="checkbox"> 具体实施任务：处理数据</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-13 </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解数据库连接池</li>
<li><input checked="" disabled="" type="checkbox"> 了解如何向 MySQL 数据库中写入数据</li>
<li><input checked="" disabled="" type="checkbox"> 借助 <code>alibaba Druid</code> 库实现一个数据库连接工具类 </li>
<li><input checked="" disabled="" type="checkbox"> 编写案例：<code>WordCount</code></li>
<li><input checked="" disabled="" type="checkbox"> 具体实施任务，将代码中生成的数据写入<code>MySQL</code>。</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-14</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解什么是 Kafka Offset</li>
<li><input checked="" disabled="" type="checkbox"> 维护 Kafka Offset</li>
<li><input checked="" disabled="" type="checkbox"> 具体实施任务，将 Kafka 的 Offset 配合 <code>MySQL</code> 用代码进行维护。</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-17</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 进行后端开发</li>
<li><input checked="" disabled="" type="checkbox"> 进行前端开发</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-18</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 进行热力图的绘制</li>
<li><input checked="" disabled="" type="checkbox"> 进行人流量柱状图的绘制</li>
<li><input checked="" disabled="" type="checkbox"> 进行人流量趋势图的绘制</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-19 项目结束日期</p>
</li>
</ul>
<p><strong>文件目录</strong></p>
<p>[TOC]</p></div><a class="article-more button is-small is-size-7" href="/2024/06/11/OnlineTravelBigdataPlatform/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-10T09:32:28.000Z" title="2024/6/10 17:32:28">2024-06-10</time>发表</span><span class="level-item"><time dateTime="2024-06-22T07:38:15.039Z" title="2024/6/22 15:38:15">2024-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/">Scala</a></span><span class="level-item">30 分钟读完 (大约4556个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/10/ScalaQuickIN/">ScalaQuickIN</a></p><div class="content"><h2 id="快速入门-Scala"><a href="#快速入门-Scala" class="headerlink" title="快速入门 Scala"></a>快速入门 Scala</h2><p>[TOC]</p>
<!-- toc --></div><a class="article-more button is-small is-size-7" href="/2024/06/10/ScalaQuickIN/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-02T14:43:53.000Z" title="2024/6/2 22:43:53">2024-06-02</time>发表</span><span class="level-item"><time dateTime="2024-06-22T07:32:50.275Z" title="2024/6/22 15:32:50">2024-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/">HBase</a></span><span class="level-item">1 小时读完 (大约6723个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/02/QuickPassHBase/">QuickPassHBase</a></p><div class="content"><h2 id="快速上手HBase"><a href="#快速上手HBase" class="headerlink" title="快速上手HBase"></a>快速上手HBase</h2><p>[TOC]</p>
<h3 id="⚙-1-HBase简介"><a href="#⚙-1-HBase简介" class="headerlink" title="⚙ 1. HBase简介"></a>⚙ 1. HBase简介</h3><h4 id="1-1-HBase的定义"><a href="#1-1-HBase的定义" class="headerlink" title="1.1 HBase的定义"></a>1.1 HBase的定义</h4><p><strong>Apache HBase</strong> 是以 HDFS 为数据存储的，一种分布式、可扩展的 NoSQL 数据库。</p>
<p>HBase 的设计理念依据 Google 的 BigTable 论文，论文中对于数据模型的首句介绍。</p>
<p><strong>BigTable是一个稀疏的、分布式的、持久的多维排序映射(Map)。该映射由行键、列键和时间戳索引作为键(Key)，映射中的每个值(Value)都是一个未解释的字节数组。</strong></p>
<p>HBase 使用与 BigTable 非常相似的数据模型。用户将数据行存储在带标签的表中。数据行具有可排序的键和任意数量的列。该表存储稀疏，因此如果用户喜欢，同一表中的行可以具有疯狂变化的列。</p>
<h4 id="1-2-HBase的数据模型"><a href="#1-2-HBase的数据模型" class="headerlink" title="1.2 HBase的数据模型"></a>1.2 HBase的数据模型</h4><h5 id="1-2-1-HBase-的逻辑结构"><a href="#1-2-1-HBase-的逻辑结构" class="headerlink" title="1.2.1 HBase 的逻辑结构"></a>1.2.1 HBase 的逻辑结构</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;row_key1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;personal_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZhangSan&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;156****0000&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;office_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;tel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010-1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shandong&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;row_key11&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;personal_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;133****0000&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;office_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;tel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010-1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;row_key2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>列族→</td>
        <td colspan="3">personal_info</td> 
        <td colspan="3">office_info</td> 
    </tr>
    <tr>
        <td>RowKey↓</td>
        <td>name</td> 
        <td>city</td>
        <td>phone</td>
        <td>tel</td>
        <td>address</td>
    </tr>
    <tr>
        <td>row_key1</td>
        <td>ZhangSan</td> 
        <td>Beijing</td>
        <td>156****0000</td>
        <td>010-1234567</td>
        <td>Shandong</td>
    </tr>
    <tr>
        <td>row_key11</td>
        <td></td> 
        <td>Shanghai</td>
        <td>131****0000</td>
        <td>010-1234567</td>
        <td></td>
    </tr>
    <tr>
        <td>row_key2</td>
        <td>...</td> 
        <td>...</td>
        <td>...</td>
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>在上面的表格中：</p>
<ul>
<li><code>personal_info</code>、<code>office_info</code>称为<strong>列族</strong></li>
<li><code>name</code>、<code>city</code>、<code>phone</code>、<code>tel</code>、<code>address</code>称为<strong>列</strong></li>
<li><code>row_key1</code>、<code>row_key11</code>称为<strong>行键</strong>。</li>
<li>将一整张大表按照<strong>行</strong>进行拆分，拆分为多个表，拆分后的每个表称为**块(Region)**，用于实现分布式结构。</li>
<li>将一整张大表按照<strong>列族</strong>进行拆分，拆分为多个**存储(Store)**，用于在底层存储到不同的文件夹中，便于文件对应。</li>
</ul>
<p>存储数据<strong>稀疏</strong>，数据存储<strong>多维</strong>，不同的行具有不同的列。数据存储整体有序，按照RowKey的字典序排列，RowKey为一个Byte数组。</p>
<h5 id="1-2-2-HBase-的物理结构"><a href="#1-2-2-HBase-的物理结构" class="headerlink" title="1.2.2 HBase 的物理结构"></a>1.2.2 HBase 的物理结构</h5><p>物理存储结构即为数据映射关系，而在概念视图的空单元格，底层实际根本不存储。</p>
<p>在HDFS中划分好的存储Store如下：</p>
<table>
    <tr>
        <td></td>
        <td colspan="3">personal_info</td> 
    </tr>
    <tr>
        <td>RowKey</td>
        <td>name</td> 
        <td>city</td>
        <td>phone</td>
    </tr>
    <tr>
        <td>row_key1</td>
        <td>ZhangSan</td> 
        <td>Beijing</td>
        <td>156****0000</td>
    </tr>
    <tr>
        <td>row_key11</td>
        <td></td> 
        <td>Shanghai</td>
        <td>131****0000</td>
    </tr>
    <tr>
        <td>row_key2</td>
        <td>...</td> 
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>其底层一定是以映射(Map)的方式进行存储的，格式为**<code>(Key, Value)</code><strong>，<code>Value</code>一定是</strong>“ZhangSan”**这种字段。那么<code>Key</code>是什么呢？</p>
<p>为了确定<code>Value</code>值**”ZhangSan”<strong>，我们需要用</strong>Key<strong>对应到</strong>Value**，于是得到存储如下：</p>
<table>
<thead>
<tr>
<th>Row Key</th>
<th>Column Family</th>
<th>Column Qualifier</th>
<th>Timestamp</th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>row_key1</td>
<td>personal_info</td>
<td>name</td>
<td>t1</td>
<td>Put</td>
<td>ZhangSan</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>city</td>
<td>t2</td>
<td>Put</td>
<td>Beijing</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t3</td>
<td>Put</td>
<td>156****0000</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t4</td>
<td>Put</td>
<td>156****0001</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t5</td>
<td>Delete</td>
<td>156****0001</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>因为 HDFS 是无法修改数据的，而 HBase 需要修改数据，那么就需要解决这一问题，于是就有了**时间戳(Timestamp)**。不同版本（version）的数据根据 <strong>Timestamp</strong> 进行区分，读取数据默认读取最新的版本。</p>
<p>在上面的表格中，<code>t4</code>相对于<code>t3</code>来说就是进行了修改，将<code>t3</code>时的**<code>phone</code><strong>从<code>156****0000</code>修改为<code>t4</code>时的<code>156****0001</code>，读取时默认读取<code>t4</code>时的</strong><code>phone</code>**值，通过这种方式完成了修改。</p>
<p>同样的，我们也不好删除数据，因此我们只需要插入一条**<code>Type</code>**为<code>Delete</code>的数据即可。</p>
<h5 id="1-2-3-数据模型"><a href="#1-2-3-数据模型" class="headerlink" title="1.2.3 数据模型"></a>1.2.3 数据模型</h5><ul>
<li><p><strong>Name Space</strong> 命名空间</p>
<p>类似于关系型数据库的 <strong>Database</strong> 概念，每个命名空间下有多个表。HBase 两个自带的命名空间，分别是 <code>hbase</code> 和<code>default</code>，<code>hbase</code> 中存放的是 HBase 内置的表，<code>default</code>表是用户默认使用的命名空间。</p>
</li>
<li><p><strong>Table</strong></p>
<p>类似于关系型数据库的<strong>表</strong>概念。不同的是，HBase 定义表时<strong>只需要声明列族</strong>即可，<strong>不需要声明具体的列</strong>。因为数据存储时稀疏的，所有往HBase写入数据时，字段<strong>可以动态、按需指定</strong>。因此，和关系型数据库相比，HBase能够轻松应对字段变更的场景。</p>
<p>需要注意的是，<strong>列族</strong>的存在是<strong>动态</strong>添加列（或称字段）的基础。</p>
</li>
<li><p><strong>Row</strong></p>
<p>HBase 表中的每行数据都由<em>*一个行键(RowKey)<strong>和</strong>多个列(Column)<strong>组成，数据是按照 RowKey的字典顺序存储的，</strong>*并且查询数据时只能根据 RowKey进行检索</em>**，所以RowKey的设计十分重要。</p>
</li>
<li><p><strong>Column</strong></p>
<p>HBase 中的每个列都由<strong>列族(Column Family)<strong>和</strong>列限定符(Column Qualifier)<strong>进行限定，例如<code>info:name, info:age</code>。建表时，只需指明列族，而</strong>列限定符无需预先定义</strong>。列限定符听起来很高端，其实就是列名的意思。</p>
</li>
<li><p><strong>Time Stamp</strong></p>
<p>用于标识数据的**不同版本(Version)**，每条数据写入时，系统会自动为其加上该字段，其值为写入 HBase 的时间。</p>
</li>
<li><p><strong>Cell</strong></p>
<p>由 <code>&#123;rowkey, Column Family: Column Qualifier, Timestamp&#125;</code> 唯一确定的单元，<code>Cell</code> 中的数据全部是字节码形式存储。</p>
</li>
</ul>
<h4 id="1-3-HBase-基本架构"><a href="#1-3-HBase-基本架构" class="headerlink" title="1.3 HBase 基本架构"></a>1.3 HBase 基本架构</h4><img src="./QuickPassHBase/HBaseStructure.png" alt="HBase基本架构" style="zoom:33%;" />

<ul>
<li><p><strong>Master</strong></p>
<p><strong>主要进程</strong>，具体实现类为<code>HMaster</code>，通常部署在<code>NameNode</code>上。</p>
<p><strong>主要功能</strong>：负责通过 <code>ZK</code> 监控 <code>RegionServer</code> 进程状态，同时是所有元数据变化的接口，内部启动监控执行 <code>region</code> 的故障转移和拆分的线程。</p>
<p><strong>功能的详细描述</strong>：</p>
<ul>
<li><p>管理元数据表格 <code>hbase:meta</code>：接收用户对表格创建、修改、删除的命令并执行。</p>
</li>
<li><p>监控 <code>RegionServer</code> 是否需要进行<strong>负载均衡</strong>、<strong>故障转移</strong>和<strong>Region拆分</strong>。通过启动多个后台线程监控实现上述功能：</p>
<ul>
<li><p><code>LoadBalancer</code> 负载均衡器</p>
<p>周期性监控 <code>region</code>分布在 <code>RegionServer</code> 上面是否均衡，由参数 <code>hbase.balancer.period</code>控制周期时间，默认5分钟。</p>
</li>
<li><p><code>CatalogJanitor</code>元数据管理器</p>
<p>定期检查和清理<code>hbase:meta</code>中的数据。</p>
</li>
<li><p><code>MasterProcWAL</code> Master 预写日志处理器</p>
<p>把Master需要执行的任务记录到预写日志WAL中，如果Master宕机，则让BackupMaster继续操作。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RegionServer</strong></p>
<p><strong>主要进程</strong>，具体实现类为<code>HRegionServer</code>，通常部署在<code>DataNode</code>上。</p>
<p><strong>功能</strong>：主要负责数据 <code>Cell</code> 的处理，同时在执行区域的拆分和合并的时候，由 <code>RegionServer</code> 来实际执行。</p>
<p><strong>功能的详细描述</strong>：</p>
<ul>
<li>负责数据 <code>Cell</code> 的处理，例如写入数据<code>put</code>，查询数据<code>get</code>等。</li>
<li>拆分合并 <code>region</code> 的实际执行者，有 <strong>Master</strong> 监控，有<code>RegionServer</code> 执行。</li>
</ul>
</li>
<li><p><strong>ZooKeeper</strong></p>
<p>HBase 通过 <code>ZooKeeper</code> 来做 <code>Master</code>的高可用、记录 <code>RegionServer</code> 的部署信息、并且存储有 <code>meta</code> 表的位置信息。<br>HBase 对于数据的读写操作时是直接访问 <code>ZooKeeper</code> 的，在 2.3 版本推出 <code>Master Registry</code> 模式，客户端可以直接访问 <code>Master</code>。使用此功能，会加大对 <code>Master</code>的压力，减轻对 <code>ZooKeeper</code> 的压力。</p>
</li>
<li><p><strong>HDFS</strong></p>
<p><code>HDFS</code> 为 HBase 提供最终的底层数据存储服务，同时为 HBase 提供高容错的支持。</p>
</li>
</ul>
<p>上图中的<code>Region</code>由三个<code>RegionServer</code>随机管理，尽量均衡。表名<code>hbase:meta</code>是一个特例，他存储在<strong>HDFS</strong>，但是由<strong>Master</strong>管理。</p>
<h3 id="🔧-2-快速上手"><a href="#🔧-2-快速上手" class="headerlink" title="🔧 2. 快速上手"></a>🔧 2. 快速上手</h3><h4 id="2-1-安装部署"><a href="#2-1-安装部署" class="headerlink" title="2.1 安装部署"></a>2.1 安装部署</h4><h5 id="2-1-1-分布式部署"><a href="#2-1-1-分布式部署" class="headerlink" title="2.1.1 分布式部署"></a>2.1.1 分布式部署</h5><ol>
<li><p>至少 3 台虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101</span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证 <strong>ZooKeeper</strong> 正常部署，并且启动 <strong>ZooKeeper</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证 <strong>Hadoop</strong> 正常部署，并且启动 <strong>Hadoop</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <strong>HBase</strong> 环境</p>
<p>① 下载 HBase 安装包（压缩包），这里假设为<code>hbase-2.4.11-bin.tar.gz</code></p>
<p>② 解压 HBase 安装包到一个文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /path/to/hbase-2.4.11-bin.tar.gz -C /path/to/module</span><br></pre></td></tr></table></figure>

<p>③ 在用户目录下，添加用户环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#HBase_HOME</span></span><br><span class="line"><span class="built_in">export</span> HBASE_HOME = /path/to/module/hbase-2.4.11</span><br><span class="line"><span class="built_in">export</span> PATH = <span class="variable">$PATH</span>:<span class="variable">$HBASE_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>④ 使环境变量生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure>

<p>⑤ 修改配置文件</p>
<ul>
<li><p><code>hbase-env.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示是否需要 HBase 管理维护一个自带的 ZooKeeper, 默认为 true</span></span><br><span class="line"><span class="comment"># 我们需要使用本机已经配置好的 ZooKeeper, 所以修改为 False</span></span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hbase-site.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101,hadoop102,hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase数据在HDFS中的存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase的运行模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- false为单机模式, HBase和ZooKeeper会运行在同一个JVM虚拟机中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- true 为分布式模式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper快照的存储位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里替换为自己的 /path/to/ZooKeeperDir --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/zookeeper-3.4.6/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- HBase 安全模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在分布式模式下, 设置为 false --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>regionservers</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101</span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br></pre></td></tr></table></figure></li>
</ul>
<p>⑥ 解决 <code>log4j</code> 不兼容的问题，移除 <code>HBase</code>或者 <code>Hadoop</code>的 <code>.jar</code>包</p>
<p>⑦ 使用 <code>scp</code> 命令同步 HBase 配置，需要提前设置好免密登录。或者使用 <code>xsync</code></p>
</li>
<li><p>启动 HBase 服务</p>
<ul>
<li><p>单点启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单点启动HMaster</span></span><br><span class="line">hbase-daemon.sh start master</span><br><span class="line"><span class="comment">#单点启动HRegionServer</span></span><br><span class="line">hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>集群启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="2-1-2-高可用服务"><a href="#2-1-2-高可用服务" class="headerlink" title="2.1.2 高可用服务"></a>2.1.2 高可用服务</h5><ol>
<li><p>如果 HBase 已经启动，先关闭HBase</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件 <code>backup-masters</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用touch命令或者echo命令均可</span></span><br><span class="line"><span class="built_in">touch</span> /path/to/hbase-2.1.4/conf/backup-masters</span><br><span class="line">vim /path/to/hbase-2.1.4/conf/backup-masters</span><br></pre></td></tr></table></figure>

<p>添加内容：<code>hadoop102</code></p>
</li>
<li><p>使用 <code>scp</code> 命令分发配置文件</p>
</li>
<li><p>启动HBase，正常启动进程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101 -&gt; HMaster HRegionServer</span><br><span class="line">hadoop102 -&gt; HMaster HRegionServer</span><br><span class="line">hadoop103 -&gt; HRegionServer</span><br></pre></td></tr></table></figure>

<p>其中，<code>hadoop101</code> 的 <code>HMaster</code> 先启动作为主节点，<code>hadoop102</code> 的 <code>HMaster</code>后启动，作为**备用节点(Backup-Master)**。</p>
</li>
</ol>
<h4 id="2-2-使用操作"><a href="#2-2-使用操作" class="headerlink" title="2.2 使用操作"></a>2.2 使用操作</h4><h5 id="2-2-1-Shell操作"><a href="#2-2-1-Shell操作" class="headerlink" title="2.2.1 Shell操作"></a>2.2.1 Shell操作</h5><p>使用命令 <code>hbase shell</code> 启动 HBase 的 <code>Shell</code> 命令界面，所有命令均可以使用 <code>help</code> 查到。</p>
<p>当我们在 <code>hbase shell</code>中输入<code>help</code>命令时，将会弹出HBase的使用提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; help</span><br><span class="line">HBase Shell, version 2.1.8, rd8333e556c8ed739cf39dab58ddc6b43a50c0965, Tue Nov 19 15:29:04 UTC 2019</span><br><span class="line">Type &#x27;help &quot;COMMAND&quot;&#x27;, (e.g. &#x27;help &quot;get&quot;&#x27; -- the quotes are necessary) for help on a specific command.</span><br><span class="line">Commands are grouped. Type &#x27;help &quot;COMMAND_GROUP&quot;&#x27;, (e.g. &#x27;help &quot;general&quot;&#x27;) for help on a command group.</span><br><span class="line"></span><br><span class="line">COMMAND GROUPS:</span><br><span class="line">  Group name: general</span><br><span class="line">  Commands: processlist, status, table_help, version, whoami</span><br><span class="line"></span><br><span class="line">  Group name: ddl</span><br><span class="line">  Commands: alter, alter_async, alter_status, clone_table_schema, create, describe, disable, disable_all, drop, drop_all, enable, enable_all, exists, get_table, is_disabled, is_enabled, list, list_regions, locate_region, show_filters</span><br><span class="line"></span><br><span class="line">  Group name: namespace</span><br><span class="line">  Commands: alter_namespace, create_namespace, describe_namespace, drop_namespace, list_namespace, list_namespace_tables</span><br><span class="line"></span><br><span class="line">  Group name: dml</span><br><span class="line">  Commands: append, count, delete, deleteall, get, get_counter, get_splits, incr, put, scan, truncate, truncate_preserve</span><br><span class="line"></span><br><span class="line">  Group name: tools</span><br><span class="line">  Commands: assign, balance_switch, balancer, balancer_enabled, catalogjanitor_enabled, catalogjanitor_run, catalogjanitor_switch, cleaner_chore_enabled, cleaner_chore_run, cleaner_chore_switch, clear_block_cache, clear_compaction_queues, clear_deadservers, close_region, compact, compact_rs, compaction_state, flush, hbck_chore_run, is_in_maintenance_mode, list_deadservers, major_compact, merge_region, move, normalize, normalizer_enabled, normalizer_switch, split, splitormerge_enabled, splitormerge_switch, stop_master, stop_regionserver, trace, unassign, wal_roll, zk_dump</span><br><span class="line"></span><br><span class="line">  Group name: replication</span><br><span class="line">  Commands: add_peer, append_peer_exclude_namespaces, append_peer_exclude_tableCFs, append_peer_namespaces, append_peer_tableCFs, disable_peer, disable_table_replication, enable_peer, enable_table_replication, get_peer_config, list_peer_configs, list_peers, list_replicated_tables, remove_peer, remove_peer_exclude_namespaces, remove_peer_exclude_tableCFs, remove_peer_namespaces, remove_peer_tableCFs, set_peer_bandwidth, set_peer_exclude_namespaces, set_peer_exclude_tableCFs, set_peer_namespaces, set_peer_replicate_all, set_peer_serial, set_peer_tableCFs, show_peer_tableCFs, update_peer_config</span><br><span class="line"></span><br><span class="line">  Group name: snapshots</span><br><span class="line">  Commands: clone_snapshot, delete_all_snapshot, delete_snapshot, delete_table_snapshots, list_snapshots, list_table_snapshots, restore_snapshot, snapshot</span><br><span class="line"></span><br><span class="line">  Group name: configuration</span><br><span class="line">  Commands: update_all_config, update_config</span><br><span class="line"></span><br><span class="line">  Group name: quotas</span><br><span class="line">  Commands: list_quota_snapshots, list_quota_table_sizes, list_quotas, list_snapshot_sizes, set_quota</span><br><span class="line"></span><br><span class="line">  Group name: security</span><br><span class="line">  Commands: grant, list_security_capabilities, revoke, user_permission</span><br><span class="line"></span><br><span class="line">  Group name: procedures</span><br><span class="line">  Commands: list_locks, list_procedures</span><br><span class="line"></span><br><span class="line">  Group name: visibility labels</span><br><span class="line">  Commands: add_labels, clear_auths, get_auths, list_labels, set_auths, set_visibility</span><br><span class="line"></span><br><span class="line">  Group name: rsgroup</span><br><span class="line">  Commands: add_rsgroup, balance_rsgroup, get_rsgroup, get_server_rsgroup, get_table_rsgroup, list_rsgroups, move_namespaces_rsgroup, move_servers_namespaces_rsgroup, move_servers_rsgroup, move_servers_tables_rsgroup, move_tables_rsgroup, remove_rsgroup, remove_servers_rsgroup</span><br><span class="line"></span><br><span class="line">SHELL USAGE:</span><br><span class="line">Quote all names in HBase Shell such as table and column names.  Commas delimit</span><br><span class="line">command parameters.  Type &lt;RETURN&gt; after entering a command to run it.</span><br><span class="line">Dictionaries of configuration used in the creation and alteration of tables are</span><br><span class="line">Ruby Hashes. They look like this:</span><br><span class="line"></span><br><span class="line">  &#123;&#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;, ...&#125;</span><br><span class="line"></span><br><span class="line">and are opened and closed with curley-braces.  Key/values are delimited by the</span><br><span class="line">&#x27;=&gt;&#x27; character combination.  Usually keys are predefined constants such as</span><br><span class="line">NAME, VERSIONS, COMPRESSION, etc.  Constants do not need to be quoted.  Type</span><br><span class="line">&#x27;Object.constants&#x27; to see a (messy) list of all constants in the environment.</span><br><span class="line"></span><br><span class="line">If you are using binary keys or values and need to enter them in the shell, use</span><br><span class="line">double-quote&#x27;d hexadecimal representation. For example:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\x03\x3f\xcd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\003\023\011&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">put <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;test\xef\xff&quot;</span>, <span class="string">&#x27;f1:&#x27;</span>, <span class="string">&quot;\x01\x33\x40&quot;</span></span></span><br><span class="line"></span><br><span class="line">The HBase shell is the (J)Ruby IRB with the above HBase-specific commands added.</span><br><span class="line">For more on the HBase Shell, see http://hbase.apache.org/book.html</span><br></pre></td></tr></table></figure>

<p>根据上述信息，我们可以进一步的操作 HBase 数据库。我们实际开发中常用的**命令组(COMMAND GROUPS)**有：<code>general</code>、<code>namespace</code>、<code>ddl</code>、<code>dml</code>等，下面依次介绍这些内容：</p>
<ul>
<li><p><strong>通用命令 <code>general</code></strong></p>
<ul>
<li><p>查看 HBase 状态 <code>status</code>，提供 HBase 的状态，如服务器的数量等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; status</span><br><span class="line">1 active master, 0 backup masters, 1 servers, 0 dead, 4.0000 average load</span><br><span class="line">Took 0.5268 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 HBase 版本 <code>version</code>，提供正在使用 HBase 版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; version</span><br><span class="line">2.1.8, rd8333e556c8ed739cf39dab58ddc6b43a50c0965, Tue Nov 19 15:29:04 UTC 2019</span><br><span class="line">Took 0.0002 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>表引用命令提供帮助 <code>table_help</code></p>
</li>
<li><p>提供有关用户的信息 <code>whoami</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; whoami</span><br><span class="line">nilera (auth:SIMPLE)</span><br><span class="line">    groups: nilera</span><br><span class="line">Took 0.0283 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>操作命名空间 <code>Namespace</code></strong></p>
<p>**命名空间(Namespace)**，相当于MySQL数据库中的DataBase。<code>Namespace</code> 命令包括：<code>alter namespace</code>、<code>create_namespace</code>、<code>describe_namespace</code>、<code>drop_namespace</code>、<code>list_namespace</code>、<code>list_namespace_tables</code>。下面将对一些常用命令进行介绍：</p>
<ul>
<li><p>查看全部命名空间 <code>list_namespace</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.5484 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建命名空间 <code>create_namespace</code></p>
<p>用法：<code>create_namespace &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create_namespace &#x27;bigdata&#x27;</span><br><span class="line">Took 0.0432 seconds</span><br><span class="line">hbase(main):002:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">bigdata</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0224 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除命名空间 <code>drop_namespace</code></p>
<p>用法：<code>drop_namespace &#39;ns&#39;</code>，删除命名空间时，命名空间必须为空。</p>
</li>
<li><p>查看命名空间 <code>describe_namespace</code></p>
<p>用法：<code>describe_namespace &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; describe_namespace &#x27;bigdata&#x27;</span><br><span class="line">DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;bigdata&#x27;&#125;</span><br><span class="line">Took 0.0068 seconds</span><br><span class="line">=&gt; 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看命名空间下的表 <code>list_namespace_tables</code></p>
<p>用法：<code>list_namespace_tables &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace_tables &#x27;default&#x27;</span><br><span class="line">TABLE</span><br><span class="line">logs</span><br><span class="line">user</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.3790 seconds</span><br><span class="line">=&gt; [&quot;logs&quot;, &quot;user&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据定义语言 <code>ddl</code></strong></p>
<p><strong>DDL(Data Definition Language)数据定义语言</strong>，主要是进行定义&#x2F;改变表的结构、数据类型、表之间的链接等操作。<code>ddl</code> 相关命令如下：<code>alter</code>、<code>alter_async</code>、<code>alter_status</code>、<code>clone_table_schema</code>、<code>create</code>、<code>describe</code>、<code>disable</code>、<code>disable_all</code>、<code>drop</code>、<code>drop_all</code>、<code>enable</code>、<code>enable_all</code>、<code>exists</code>、<code>get_table</code>、<code>is_disabled</code>、<code>is_enabled</code>、<code>list</code>、<code>list_regions</code>、<code>locate_region</code>、<code>show_filters</code>。下面将对一些常用命令进行介绍：</p>
<ul>
<li><p>创建表 <code>create</code></p>
<p><strong>常见用法：</strong></p>
<p>① <code>create &#39;ns:tb&#39;, &#123;NAME =&gt; &#39;cf&#39;, VERSION =&gt; 5&#125;</code></p>
<p>​	在命名空间 <code>ns</code> 下，创建一张表 <code>tb</code>，定义一个列族 <code>cf</code>。</p>
<p>② 当在默认命名空间<code>default</code>下创建表时，可以省略 <code>ns</code></p>
<p>③ <code>create &#39;tb&#39;, &#39;cf1&#39;, &#39;cf2&#39;</code></p>
<p>​	在默认命名空间<code>default</code>下，创建一张表<code>tb</code>，并定义两个列族 <code>cf1</code>、<code>cf2</code></p>
<p>④ <code>create &#39;tb&#39;, &#123;NAME =&gt; &#39;cf1&#39;, VERSION =&gt; 5&#125;, &#123;NAME =&gt; &#39;cf2&#39;, VERSION =&gt; 5&#125;</code></p>
<p>​	在默认命名空间<code>default</code>下，创建一张表<code>tb</code>，并定义两个列族 <code>cf1</code>、<code>cf2</code>，并同时指定两个列族的版本为 <code>5</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create &#x27;bigdata:person&#x27;, &#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; 5&#125;, &#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; 5&#125;</span><br><span class="line">Created table bigdata:person</span><br><span class="line">Took 1.5638 seconds</span><br><span class="line">=&gt; Hbase::Table - bigdata:person</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表的详细信息 <code>describe</code></p>
<p><strong>用法</strong>：<code>describe &#39;tb&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.1536 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表 <code>alter</code></p>
<p>表名创建时写的所有和列族相关的信息，都可以后续通过<code>alter</code>修改，包括<strong>增加</strong>、<strong>删除</strong>列族。</p>
<p>① 增加列族和修改信息都使用覆盖的方法</p>
<p>​	修改列族的版本，<code>VERSIONS =&gt; 6</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; 6</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 4.0145 seconds</span><br></pre></td></tr></table></figure>

<p>​	添加列族 <code>tel</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;tel&#x27;, VERSIONS =&gt; 6</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.4498 seconds</span><br></pre></td></tr></table></figure>

<p>​	查看修改后的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; &#x27;6&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#123;NAME =&gt; &#x27;tel&#x27;, VERSIONS =&gt; &#x27;6&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0795 seconds</span><br></pre></td></tr></table></figure>

<p>② 删除列族</p>
<p>​	删除列族可以用以下两种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;tel&#x27;, METHOD =&gt; &#x27;delete&#x27;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.1046 seconds</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; alter &#x27;bigdata:person&#x27;, &#x27;delete&#x27; =&gt; &#x27;msg&#x27;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.9721 seconds</span><br></pre></td></tr></table></figure>

<p>​	然后查询修改后的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0391 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用表 <code>disable</code></p>
<p><strong>用法</strong>： <code>disable &#39;ns:tb&#39;</code>或<code>disable &#39;tb&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; disable &#x27;bigdata:person&#x27;</span><br><span class="line">Took 0.9384 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表 <code>drop</code></p>
<p><strong>用法</strong>： <code>drop &#39;ns:tb&#39;</code>或<code>drop &#39;tb&#39;</code>，删除表时需要保证表是禁用的，否则会出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; drop &#x27;bigdata:person&#x27;</span><br><span class="line"></span><br><span class="line">ERROR: Table bigdata:person is enabled. Disable it first.</span><br><span class="line"></span><br><span class="line">For usage try &#x27;help &quot;drop&quot;&#x27;</span><br><span class="line"></span><br><span class="line">Took 0.0248 seconds</span><br></pre></td></tr></table></figure>

<p>​	禁用表后再删除表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; drop &#x27;bigdata:person&#x27;</span><br><span class="line">Took 1.7106 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据操纵语言 <code>dml</code></strong></p>
<p><strong>DML(Data Manipulation Language)数据操纵语言</strong>，主要是对数据进行增加、删除、修改操作。</p>
<ul>
<li><p>写入数据 <code>put</code></p>
<p>在 HBase 中如果想要写入数据，只能添加结构中最底层的 <code>Cell</code>。可以手动写入时间戳指定 <code>Cell</code> 的版本，推荐不写，默认使用当前的系统时间。如果重复写入相同 <code>rowKey</code>，相同列的数据，会写入多个版本进行覆盖。所以他同时兼具<strong>写入</strong>和<strong>修改</strong>的功能。</p>
<p><strong>用法</strong>：</p>
<p>① <code>put &#39;ns:tb&#39;, &#39;rk&#39;, &#39;col&#39;, &#39;value&#39;</code></p>
<p>​	向命名空间<code>ns</code>中的<code>tb</code>表中的行键为<code>rk</code>，列为<code>col</code>的位置写入值<code>value</code>。其中<code>col</code>为<code>cf:col</code>（即<code>列族:列名</code>）的格式。</p>
<p>​	如果重复向相同行号<code>rk</code>，相同<code>col</code>写数据，则会进行覆盖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">Took 0.2415 seconds</span><br><span class="line">hbase(main):002:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">Took 0.0121 seconds</span><br><span class="line">hbase(main):003:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;wangwu&#x27;</span><br><span class="line">Took 0.0342 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1002&#x27;, &#x27;info:name&#x27;, &#x27;zhaoliu&#x27;</span><br><span class="line">Took 0.0082 seconds</span><br><span class="line">hbase(main):005:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#x27;info:age&#x27;, &#x27;10&#x27;</span><br><span class="line">Took 0.0050 seconds</span><br><span class="line">hbase(main):006:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#x27;info:sex&#x27;, &#x27;male&#x27;</span><br><span class="line">Took 0.0054 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>put &#39;t1&#39;, &#39;r1&#39;, &#39;c1&#39;, &#39;value&#39;</code>用法同上。</p>
</li>
<li><p>读取数据 <code>get/scan</code></p>
<p>读取数据的方法有两个：<code>get</code> 和 <code>scan</code></p>
<ul>
<li><p><code>get</code>最大范围是一行数据，也可以进行列的过滤，读取数据的结果为多行 <code>Cell</code>。</p>
</li>
<li><p><code>scan</code>是扫描数据，能够读取多行数据，不建议扫描过多数据，推荐使用 <code>startRow</code> 和 <code>stopRow</code> 来控制读取的数据，默认范围左闭右开。</p>
</li>
</ul>
<p>① <code>get</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>											<span class="comment">#查看&#x27;r1&#x27;的数据</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;TIMERANGE =&gt; [ts1, ts2]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>&#125;							<span class="comment">#过滤单列, 只显示 &#x27;c1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>]&#125;			<span class="comment">#过滤多列, 只显示 &#x27;c1&#x27;, &#x27;c2&#x27;, &#x27;c3&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMESTAMP =&gt; ts1&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMERANGE =&gt; [ts1, ts2], VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMESTAMP =&gt; ts1, VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;FILTER =&gt; <span class="string">&quot;ValueFilter(=, &#x27;binary:abc&#x27;)&quot;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;c1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;CONSISTENCY =&gt; <span class="string">&#x27;TIMELINE&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;CONSISTENCY =&gt; <span class="string">&#x27;TIMELINE&#x27;</span>, REGION_REPLICA_ID =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1001&#x27;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:name                               timestamp=1717580289267, value=wangwu</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0645 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):002:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#123;COLUMN =&gt; &#x27;info:name&#x27;&#125;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:name                               timestamp=1717580289267, value=wangwu</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0107 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):003:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#123;COLUMN =&gt; &#x27;info:age&#x27;&#125;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:age                                timestamp=1717580366636, value=10</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0185 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>scan</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;hbase:meta&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;hbase:meta&#x27;</span>, &#123;COLUMNS =&gt; <span class="string">&#x27;info:regioninfo&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;ns1:t1&#x27;</span>, &#123;COLUMNS =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">&#x27;xyz&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;COLUMNS =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">&#x27;xyz&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;COLUMNS =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMERANGE =&gt; [1303668804000, 1303668904000]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;REVERSED =&gt; <span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;ALL_METRICS =&gt; <span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;METRICS =&gt; [<span class="string">&#x27;RPC_RETRIES&#x27;</span>, <span class="string">&#x27;ROWS_FILTERED&#x27;</span>]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;ROWPREFIXFILTER =&gt; <span class="string">&#x27;row2&#x27;</span>, FILTER =&gt; <span class="string">&quot;</span></span></span><br><span class="line">    (QualifierFilter (&gt;=, &#x27;binary:xyz&#x27;)) AND (TimestampsFilter ( 123, 456))&quot;&#125;</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;FILTER =&gt;</span></span></span><br><span class="line">    org.apache.hadoop.hbase.filter.ColumnPaginationFilter.new(1, 0)&#125;</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;CONSISTENCY =&gt; &#x27;TIMELINE&#x27;&#125;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;ISOLATION_LEVEL =&gt; &#x27;READ_UNCOMMITTED&#x27;&#125;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;MAX_RESULT_SIZE =&gt; 123456&#125;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717580289267, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0338 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):025:0&gt; scan &#x27;bigdata:student&#x27;, &#123;STARTROW =&gt; &#x27;1001&#x27;, STOPROW =&gt; &#x27;1003&#x27;&#125;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717580289267, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.0118 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据 <code>delete/deleteall</code></p>
<p>删除数据的方式有两个：<code>delete</code>和<code>deleteall</code></p>
<ul>
<li><code>delete</code> 表示删除一个版本的数据，即为 <code>1</code> 个 <code>Cell</code>，不填写版本默认删除最新的一个版本。</li>
<li><code>deleteall</code> 表示删除所有版本的数据，即为当前行当前列的多个 <code>Cell</code>。执行命令会标记数据为要删除，不会直接彻底删除，删除只在特定时期清理磁盘时进行。</li>
</ul>
<p>① <code>delete</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">Took 0.3910 seconds</span><br><span class="line">hbase(main):002:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">Took 0.2024 seconds</span><br><span class="line">hbase(main):003:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;wangwu&#x27;</span><br><span class="line">Took 0.1559 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717584831277, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0083 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):005:0&gt; delete &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;</span><br><span class="line">Took 0.0055 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):006:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717584831277, value=lisi</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0087 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>deleteall</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="2-2-2-API操作"><a href="#2-2-2-API操作" class="headerlink" title="2.2.2 API操作"></a>2.2.2 API操作</h5><p>根据官方 API 介绍，<strong>HBase</strong> 的客户端连接由 <code>ConnectionFactory</code> 类来创建，用户使用完成之后需要手动关闭连接。同时连接是一个<strong>重量级</strong>的，推荐一个进程使用一个连接。对 <strong>HBase</strong> 的命令通过连接中的两个属性 <code>Admin</code> 和 <code>Table</code> 来实现。其中 <code>Admin</code> 主要管理 <strong>HBase</strong> 的元数据，如创建、修改表格信息，也就是 <code>DDL</code> 操作；<code>Table</code> 主要用于表格的增加、删除数据，也就是 <code>DML</code> 操作。</p>
<ul>
<li><p>环境搭建</p>
<p>使用 <code>IDEA</code> 创建 <code>Maven</code> 项目，并修改 <code>pom.xml</code> 文件，添加 <code>HBase</code> 所需要用到的依赖。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果报错, 需要排除 javax.el 拓展 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 因为 2.4.11 对应的是一个测试版本的 javax.el 包 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 需要先排除这个包后再添加正式版的 javax.el 包 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加正式版的 javax.el 包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1-b06<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>单线程使用连接</p>
<p>下面展示了一种单线程使用连接的方式，实际开发中实际上很少这样做。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdutcm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.AsyncConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接配置对象</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加配置参数</span></span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;bigdata&quot;</span>);      <span class="comment">// 这些配置都写在 hbase-site.xml 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="comment">// 默认创建同步连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以创建异步连接: 不推荐使用异步连接</span></span><br><span class="line">        CompletableFuture&lt;AsyncConnection&gt; asyncConnection = ConnectionFactory.createAsyncConnection(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用连接</span></span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多线程使用连接</p>
<p>实际开发中，因为 <strong>HBase</strong> 的连接是重量级的，所以我们在每个客户端中一般只创建一个（类似于单例模式）。所以我们对代码进行修改，如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdutcm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.AsyncConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseConnection</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接配置对象: 当完成 resources 目录的配置后, 我们可以直接注释掉创建配置的部分</span></span><br><span class="line">        <span class="comment">// 直接进行创建连接操作</span></span><br><span class="line">        <span class="comment">// Configuration conf = new Configuration();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加配置参数</span></span><br><span class="line">        <span class="comment">// 实际开发中, 不应该在代码中显式的写参数, 而是将参数写在 resources 下的配置文件中</span></span><br><span class="line">        <span class="comment">// 将虚拟机的 hbase-site.xml 放到 resources 目录下</span></span><br><span class="line">        <span class="comment">// conf.set(&quot;hbase.zookeeper.quorum&quot;, &quot;bigdata&quot;);      // 这些配置都写在 hbase-site.xml 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="comment">// 默认创建同步连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里修改为无参构造</span></span><br><span class="line">            <span class="comment">// connection = ConnectionFactory.createConnection(conf);</span></span><br><span class="line">            <span class="comment">// 这里通过查看 ConnectionFactory.createConnection() -&gt; 查看 create() -&gt; 可以发现 HBase 官方文档添加了两个配置文件</span></span><br><span class="line">            <span class="comment">// 分别为 hbase-default.xml 和 hbase-site.xml</span></span><br><span class="line">            <span class="comment">// 所以我们可以直接复制虚拟机的 hbase-site.xml 添加到 resources 目录下, 并且将这里改为无参构造</span></span><br><span class="line">            <span class="comment">// 无参则默认使用读取本地 hbase-site.xml 文件的方式添加参数</span></span><br><span class="line">            connection = ConnectionFactory.createConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 判断连接是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 直接使用创建好的连接, 不要在 main 线程里面单独创建连接</span></span><br><span class="line">        System.out.println(HBaseConnection.connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用完连接后需要关闭连接</span></span><br><span class="line">        HBaseConnection.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 <code>Admin</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Admin</span></span><br><span class="line"><span class="comment">// Admin 的连接式轻量级的, 不是线程安全的, 不推荐池化或者缓存这个连接</span></span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br></pre></td></tr></table></figure>

<ul>
<li>创建命名空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdutcm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.NamespaceDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Admin;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseDDL</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个静态属性, 这样我们可以在不同的类中, 调用到同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> HBaseConnection.connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@brief</span> 创建命名空间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> namespace 命名空间名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createNamespace</span><span class="params">(String namespace)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 Admin</span></span><br><span class="line">        <span class="comment">// Admin 的连接式轻量级的, 不是线程安全的, 不推荐池化或者缓存这个连接</span></span><br><span class="line">        <span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用方法创建命名空间</span></span><br><span class="line">        <span class="comment">// 2.1 创建命名空间描述</span></span><br><span class="line">        NamespaceDescriptor.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> NamespaceDescriptor.create(namespace);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 给命名空间添加需求</span></span><br><span class="line">        builder.addConfiguration(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;sdutcm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3 使用 builder 构造出对应的添加完参数的对象, 完成创建</span></span><br><span class="line">        admin.createNamespace(builder.build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 admin</span></span><br><span class="line">        admin.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 测试创建命名空间</span></span><br><span class="line">        createNamespace(<span class="string">&quot;sdutcm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;其他代码&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 HBase 连接</span></span><br><span class="line">        HBaseConnection.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">sdutcm		&lt;&lt;&lt; 可以看到 sdutcm 已经被创建出来了</span><br><span class="line">3 row(s)</span><br><span class="line">Took 8.0120 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):002:0&gt; describe_namespace &quot;sdutcm&quot;</span><br><span class="line">DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;sdutcm&#x27;, user =&gt; &#x27;sdutcm&#x27;&#125;	&lt;&lt;&lt; 这里是我们添加的描述</span><br><span class="line">Took 0.7576 seconds</span><br><span class="line">=&gt; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>多异常处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>判断表格是否存在</li>
<li>创建表格</li>
</ul>
<h3 id="📕-3-底层原理"><a href="#📕-3-底层原理" class="headerlink" title="📕 3. 底层原理"></a>📕 3. 底层原理</h3><h4 id="3-1-进程架构"><a href="#3-1-进程架构" class="headerlink" title="3.1 进程架构"></a>3.1 进程架构</h4><h5 id="3-1-1-Master架构"><a href="#3-1-1-Master架构" class="headerlink" title="3.1.1 Master架构"></a>3.1.1 Master架构</h5><h5 id="3-1-2-RegionServer架构"><a href="#3-1-2-RegionServer架构" class="headerlink" title="3.1.2 RegionServer架构"></a>3.1.2 RegionServer架构</h5><h4 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h4><h5 id="3-2-1-写入顺序"><a href="#3-2-1-写入顺序" class="headerlink" title="3.2.1 写入顺序"></a>3.2.1 写入顺序</h5><h5 id="3-2-2-刷新机制"><a href="#3-2-2-刷新机制" class="headerlink" title="3.2.2 刷新机制"></a>3.2.2 刷新机制</h5><h4 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h4><h5 id="3-3-1-读取顺序"><a href="#3-3-1-读取顺序" class="headerlink" title="3.3.1 读取顺序"></a>3.3.1 读取顺序</h5><h5 id="3-3-2-合并数据优化"><a href="#3-3-2-合并数据优化" class="headerlink" title="3.3.2 合并数据优化"></a>3.3.2 合并数据优化</h5><h4 id="3-4-文件合并"><a href="#3-4-文件合并" class="headerlink" title="3.4 文件合并"></a>3.4 文件合并</h4><h5 id="3-4-1-大合并"><a href="#3-4-1-大合并" class="headerlink" title="3.4.1 大合并"></a>3.4.1 大合并</h5><h5 id="3-4-2-小合并"><a href="#3-4-2-小合并" class="headerlink" title="3.4.2 小合并"></a>3.4.2 小合并</h5><h4 id="Region拆分"><a href="#Region拆分" class="headerlink" title="Region拆分"></a>Region拆分</h4><h5 id="自定义预分区"><a href="#自定义预分区" class="headerlink" title="自定义预分区"></a>自定义预分区</h5><h5 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h5><h3 id="🔧-企业开发"><a href="#🔧-企业开发" class="headerlink" title="🔧 企业开发"></a>🔧 企业开发</h3><h4 id="TSDB模式"><a href="#TSDB模式" class="headerlink" title="TSDB模式"></a>TSDB模式</h4><h4 id="基础表格模式"><a href="#基础表格模式" class="headerlink" title="基础表格模式"></a>基础表格模式</h4><h5 id="自定义API"><a href="#自定义API" class="headerlink" title="自定义API"></a>自定义API</h5><h5 id="整合框架"><a href="#整合框架" class="headerlink" title="整合框架"></a>整合框架</h5><h6 id="Phoenix-读写数据"><a href="#Phoenix-读写数据" class="headerlink" title="Phoenix 读写数据"></a>Phoenix 读写数据</h6><h6 id="Hive-分析数据"><a href="#Hive-分析数据" class="headerlink" title="Hive 分析数据"></a>Hive 分析数据</h6></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-27T10:18:43.000Z" title="2024/5/27 18:18:43">2024-05-27</time>发表</span><span class="level-item"><time dateTime="2024-05-27T10:18:43.645Z" title="2024/5/27 18:18:43">2024-05-27</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/27/Evaluation-Indicators-in-AI/">Evaluation Indicators in AI</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T13:50:18.000Z" title="2024/5/22 21:50:18">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-06-14T01:24:41.107Z" title="2024/6/14 09:24:41">2024-06-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/QT6/">QT6</a></span><span class="level-item">18 分钟读完 (大约2771个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Better-QT/">Better QT</a></p><div class="content"><p>[TOC]</p>
<h2 id="Qt-的一些常用技巧"><a href="#Qt-的一些常用技巧" class="headerlink" title="Qt 的一些常用技巧"></a>Qt 的一些常用技巧</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>快捷键 <code>Ctrl + Tab</code> 可以切换文件；</li>
<li>快捷键 <code>Alt + ENTER</code> 弹出代码生成提示，可以快速提示错误修改方案，类似于 IDEA 的 <code>Alt + ENTER</code>；</li>
<li>快捷键 <code>Alt + 鼠标</code> 同时输入；</li>
<li>快捷键 <code>Ctrl + R</code> 运行程序；</li>
<li>快捷键 <code>Ctrl + M</code> 创建书签（Bookmark），或者直接在某行代码前右键添加书签；</li>
<li>快捷键 <code>Ctrl + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + Shift + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + I</code> 代码对齐；</li>
<li>快捷键 <code>Ctrl + ;</code> 格式化代码；</li>
<li>快捷键 <code>Shift + Delete</code> 剪切当前行，可以当删除用；</li>
<li>快捷键 <code>Ctrl + Shift + R</code> 局部变量统一修改；</li>
<li>快捷键 <code>Ctrl + Shift + V</code> 复制历史；</li>
<li>用键盘模拟鼠标操作：  <table>
    <tr>
        <td colspan="3">功能键</td> 
        <td colspan="3">方向键</td> 
        <td>备注</td>
    </tr>
    <tr>
          <td>Ctrl</td>
          <td>Shift</td>
          <td>Alt</td>
          <td>左/右</td>
          <td>上/下</td>
          <td>Home/End</td>
          <td>方向键具有移动光标的作用</td>
    </tr>
    <tr>
          <td>×</td>
          <td>×</td>
          <td>×</td>
          <td>字符</td>
          <td>字符</td>
          <td>行首/行尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>×</td>
          <td>单词</td>
          <td>滚动条</td>
          <td>文件头/尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>单词</td>
          <td>移动</td>
          <td>行首/行尾</td>
          <td>Shift具有选中文本的作用</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>√</td>
          <td>-</td>
          <td>向上/下复制选中部分</td>
          <td>-</td>
          <td>-</td>
    </tr>
  </table></li>
<li>快捷键 <code>F1</code> 查看帮助、文档</li>
<li>快捷键 <code>F2</code> 快速到变量或者函数间切换</li>
<li>快捷键 <code>F4</code> 快速在<code>.cpp</code>文件和<code>.h</code>文件间切换</li>
<li>快捷键 <code>Ctrl + Shift + U</code> 查找所有使用该符号的地方</li>
<li>快捷键 <code>Ctrl + K</code> 打开定位器</li>
<li>快捷键 <code>Ctrl + L</code> 跳转到某一行</li>
<li>快捷键 <code>Ctrl + [Shift] + F</code> 查找&#x2F;替换当前文件[项目]当前选中的内容</li>
<li>快捷键 <code>[Shift] + F3</code> 查找下[上]一个</li>
<li>快捷键 <code>Ctrl + B</code> 编译工程</li>
<li>快捷键 <code>Ctrl + R</code> 运行工程</li>
<li>快捷键 <code>F5</code> 调试运行</li>
<li>快捷键 <code>Ctrl + Shift + F5</code> 重启调试</li>
<li>快捷键 <code>F9</code> 设置和取消断点</li>
<li>快捷键 <code>F10</code> 单步跳过</li>
<li>快捷键 <code>F11</code> 单步进入</li>
</ul>
<h3 id="Creator-片段"><a href="#Creator-片段" class="headerlink" title="Creator 片段"></a>Creator 片段</h3><p>片段简单理解一下就是已经写好的一些模式化的代码，用户可以使用内置片段或者根据自己的需要自定义片段。</p>
<ol>
<li>自带片段示例<br><img src="/./BetterQT/QtQuickSnippets.png" alt="Qt Quick Part"></li>
<li>自定义片段<br>一个用户的自定义片段需要以下几个内容：<br>$$片段 &#x3D; 一级标题 + 二级标题 + 片段文本$$<br>需要通过：编辑（Edit）→首选项（Preferences）→文本编辑器（Text Editor）→片段（Snippets）进行设置<br><img src="/./BetterQT/Qt_Custom_Snippets.png" alt="Qt Custom Snippets"><br>比如我要添加一个自定义片段 <code>note</code>，用来表示文件注释，可以选择 <code>Group</code> 为 <code>C++</code>，然后选择 <code>Add</code>，添加指定的内容：<br><img src="/./BetterQT/AddCustomSnippets.png" alt="Add Custom Snippets"></li>
</ol>
<h2 id="Qt-代码-文件解释"><a href="#Qt-代码-文件解释" class="headerlink" title="Qt 代码&#x2F;文件解释"></a>Qt 代码&#x2F;文件解释</h2><p>Qt的源代码和文件解释</p>
<h3 id="Qt-代码"><a href="#Qt-代码" class="headerlink" title="Qt 代码"></a>Qt 代码</h3><ul>
<li><code>hellocosbrowser.h</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOCOSBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOCOSBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span> : <span class="keyword">public</span> QWidget  <span class="comment">// QWidget 是所有应用程序窗口的基类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// Qt的宏, 支持 Qt 的特性, 如信号与槽、对象树、元对象等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里 HelloCOSBrowser 指定父窗口指针为 nullptr, 则它会作为一个独立的窗口进行展示, 否则则会作为父窗口的一个控件</span></span><br><span class="line">    <span class="comment">// 关于这个父窗口指针, 一个很典型的应用就是 微信</span></span><br><span class="line">    <span class="comment">// 当我们创建新窗口的时候, 如果不指定父窗口, 就会弹出一个独立的新窗口, 即电脑任务栏的图标会多出来一个</span></span><br><span class="line">    <span class="comment">// 如果指定了父窗口, 则不会创建一个独立的窗口, 即电脑任务栏处的图标不会增加</span></span><br><span class="line">    <span class="built_in">HelloCOSBrowser</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">HelloCOSBrowser</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::HelloCOSBrowser *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLOCOSBROWSER_H</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Qt-工程文件解释"><a href="#Qt-工程文件解释" class="headerlink" title="Qt 工程文件解释"></a>Qt 工程文件解释</h3><p>文件列表</p>
<table>
<thead>
<tr>
<th align="center">文件名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>pro</code> 文件</td>
<td align="center">该文件是 Qt 的项目文件，qmake工具可以根据此文件生成 Makefile</td>
</tr>
<tr>
<td align="center"><code>pro.user</code> 文件</td>
<td align="center">该文件包含和用户相关的项目信息（用户不需要关注此文件）</td>
</tr>
<tr>
<td align="center"><code>ui</code> 文件</td>
<td align="center">Qt 的设计师界面文件</td>
</tr>
<tr>
<td align="center"><code>.cpp</code> 文件</td>
<td align="center">C++ 源文件</td>
</tr>
<tr>
<td align="center"><code>.h</code> 文件</td>
<td align="center">C++ 头文件</td>
</tr>
</tbody></table>
<h2 id="MOC编译器"><a href="#MOC编译器" class="headerlink" title="MOC编译器"></a>MOC编译器</h2><p>MOC(Meta-Object Compiler)编译器<br>C++ 编译器本身不支持 Qt 的某些机制，Qt 希望对 C++ 代码进行自动扩展，这里就需要用到宏（例如：<code>Q_Object</code>）和继承。<br>此外为了方便用户使用，希望用户无感知，可以将这一操作直接集成到框架中。</p>
<h3 id="Qt-编译过程"><a href="#Qt-编译过程" class="headerlink" title="Qt 编译过程"></a>Qt 编译过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 目标</span><br><span class="line">  ↑</span><br><span class="line">  +-------------------------+</span><br><span class="line">                            ↑</span><br><span class="line">拓展代码 -&gt; MOC编译器 -&gt; 新CPP代码</span><br></pre></td></tr></table></figure>
<p>通过上述方式，实现 Qt 的某些特性。我们可以发现，当我们写完代码进行编译后，会产生一个 <code>debug</code> 文件夹，此时我们进入该文件夹，会看到一些元对象编译器编译的文件，如 <code>moc_xxxx.cpp</code> 或 <code>moc_xxx.h</code> 等文件。</p>
<h3 id="MOC-的使用方法"><a href="#MOC-的使用方法" class="headerlink" title="MOC 的使用方法"></a>MOC 的使用方法</h3><ol>
<li>MOC 编译工具由 Qt 框架自动调用</li>
<li>扫描 C++ 头文件，寻找 <code>Q_OBJECT</code> 宏</li>
<li>生成拓展 C++ 代码，再进行预编译</li>
<li>程序员在使用时，需要继承 QObject 类或者是 QObject 子类，并且包含 <code>Q_OBJECT</code> 宏。</li>
</ol>
<h2 id="Qt应用程序开发"><a href="#Qt应用程序开发" class="headerlink" title="Qt应用程序开发"></a>Qt应用程序开发</h2><h3 id="Qt-Designer-设计师界面使用"><a href="#Qt-Designer-设计师界面使用" class="headerlink" title="Qt Designer 设计师界面使用"></a>Qt Designer 设计师界面使用</h3><p><img src="/./BetterQT/Qt_Designer.png" alt="Qt Designer"><br>① Qt 控件编辑模式<br>② Qt 信号与槽编辑模式<br>③ Qt 伙伴关系编辑模式<br>④ Qt Tab 顺序编辑模式：可以设置按下 Tab 键的高亮顺序</p>
<h3 id="Qt-核心——信号与槽"><a href="#Qt-核心——信号与槽" class="headerlink" title="Qt 核心——信号与槽"></a>Qt 核心——信号与槽</h3><p><strong>信号与槽的基本概念</strong><br><img src="/./BetterQT/QtSignalsSlots.drawio.png" alt="Qt Signals and Slots"></p>
<ul>
<li>Qt 中的信号和槽是支持多对多的，即一个信号可以对应多个槽，一个槽可以由多个信号触发。</li>
<li>Qt 中的信号无需实现，可以由函数（普通函数或者槽函数）通过 <code>emit</code> 关键字发送信号传递参数。</li>
</ul>
<h4 id="Qt中如何定义信号"><a href="#Qt中如何定义信号" class="headerlink" title="Qt中如何定义信号"></a>Qt中如何定义信号</h4><ol>
<li>继承 <code>QObject</code> 类或其派生类，同时包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>signals</code> 声明函数信号函数，不需要具体实现信号函数</li>
<li>使用 <code>emit</code> 关键字发送信号</li>
</ol>
<h4 id="Qt中如何定义槽函数"><a href="#Qt中如何定义槽函数" class="headerlink" title="Qt中如何定义槽函数"></a>Qt中如何定义槽函数</h4><ol>
<li>必须包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>[public/protected/private] slots</code> 声明函数</li>
<li>需要具体实现声明的槽函数</li>
</ol>
<h4 id="Qt中如何连接信号与槽（三种写法）"><a href="#Qt中如何连接信号与槽（三种写法）" class="headerlink" title="Qt中如何连接信号与槽（三种写法）"></a>Qt中如何连接信号与槽（三种写法）</h4><ol>
<li><code>SIGNAL/SLOT</code> 宏写法：<br><code>QObject::connect(this, SIGNAL(...), this, SLOT(...));</code></li>
<li>函数指针写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, &amp;SlotFunction)</code></li>
<li>lambda 表达式写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, [=]() &#123; qDebug() &lt;&lt; &quot;...&quot;; &#125;)</code></li>
</ol>
<p>三种写法的比较：</p>
<table>
    <tr>
        <td rowspan="2" colspan="3">连接信号与槽</td> 
        <td colspan="2">宏</td>
        <td colspan="2">函数指针</td>
    </tr>
    <tr>
        <td>编译</td>
        <td>运行</td>
        <td>编译</td>
        <td>运行</td>
    </tr>
    <tr>
        <td rowspan="4">参数类型</td>
        <td colspan="2">完全相同</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td rowspan="2">隐式转换</td>
        <td>向上</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td>向下</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">不可以隐式转换</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
        <tr>
        <td rowspan="3">参数个数</td>
        <td colspan="2">信号=槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号>槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号<槽</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
</table>

<ul>
<li>这样看来好像宏写法相对于函数指针的写法来说，可能会带来一些问题，因为有时候宏写法通过编译后，在运行阶段可能会出现一些问题；而函数指针写法可以在出现这一问题之前（编译阶段）提前发现这一问题，使得程序无法通过编译。</li>
<li>但是事实上，宏写法还是存在一定的好处，当信号函数出现重载时，使用函数指针时，无法直接进行连接（会产生报错），只能使用类型转换来进行函数指针类型的转换，如<code>static_cast&lt;void QSpinBox::*)(int)&gt;</code>。</li>
<li>一般情况下，推荐使用函数指针方式连接信号与槽。</li>
<li>当面对信号与槽函数有重载的情况时，推荐使用宏方式连接。</li>
<li>对于短小的槽函数的调用且功能不被复用时，推荐使用 lambda 方式连接。</li>
</ul>
<h4 id="其他连接信号与槽的方式"><a href="#其他连接信号与槽的方式" class="headerlink" title="其他连接信号与槽的方式"></a>其他连接信号与槽的方式</h4><ul>
<li>使用 Qt Designer 连接信号与槽<br><img src="/./BetterQT/Designer_Connect.png" alt="Qt Designer Connect"></li>
<li>使用”转到槽”方式</li>
<li>信号与槽自动绑定<br>使用 <code>void on_&lt;对象名&gt;_&lt;信号名&gt;(信号参数);</code> 时可以不使用 <code>connect</code> 进行连接，但是当对象名、信号名或参数发生变化时，连接将会失效，且编译不会有错误提示。</li>
</ul>
<h3 id="Qt-窗口"><a href="#Qt-窗口" class="headerlink" title="Qt 窗口"></a>Qt 窗口</h3><h4 id="窗口的类型"><a href="#窗口的类型" class="headerlink" title="窗口的类型"></a>窗口的类型</h4><p><strong>顶层窗口、次级窗口（父、子窗口）</strong><br><img src="/./BetterQT/Qt_Windows.png" alt="Qt Windows"><br>在该图中，①可以称为顶层窗口（父窗口），②可以称为次级窗口（子窗口）。窗口中的某些按钮、输入框…等就是控件。</p>
<h4 id="设置窗口标志"><a href="#设置窗口标志" class="headerlink" title="设置窗口标志"></a>设置窗口标志</h4><p>在 Qt 中可以使用 <code>setWindowFlags()</code> 来设置窗口标志</p>
<ol>
<li>设置窗口无标题栏<br><img src="/./BetterQT/Window_With_No_Title.png" alt="Window With No Title"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint);</span><br></pre></td></tr></table></figure></li>
<li>设置窗口无边框<br><img src="/./BetterQT/Window_With_No_Frame.png" alt="Window With No Frame"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure></li>
<li>设置窗口置顶 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
 如果按照上述方式依次设置窗口标志，我们会发现当设置第 $3$ 步时前面两步的操作都失效了，这是因为设置窗口置顶时，会覆盖前面的设置。我们可以使用“或”符连接这些标志，解决这一问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="窗口坐标系与几何布局"><a href="#窗口坐标系与几何布局" class="headerlink" title="窗口坐标系与几何布局"></a>窗口坐标系与几何布局</h3><h4 id="窗口的坐标系"><a href="#窗口的坐标系" class="headerlink" title="窗口的坐标系"></a>窗口的坐标系</h4><p><img src="/./BetterQT/CoordinateSystem.png" alt="Window Coordinate System"></p>
<h4 id="窗口的几何布局"><a href="#窗口的几何布局" class="headerlink" title="窗口的几何布局"></a>窗口的几何布局</h4><p><img src="/./BetterQT/WindowLayout.png" alt="Window Layout"></p>
<h3 id="为窗口添加图标"><a href="#为窗口添加图标" class="headerlink" title="为窗口添加图标"></a>为窗口添加图标</h3><ol>
<li>准备图标文件</li>
<li>调用 setWindowIcon 方法</li>
</ol>
<h3 id="为应用程序添加图标（一般使用这种方式）"><a href="#为应用程序添加图标（一般使用这种方式）" class="headerlink" title="为应用程序添加图标（一般使用这种方式）"></a>为应用程序添加图标（一般使用这种方式）</h3><ol>
<li>准备图标文件 <code>logo.ico</code></li>
<li>修改 pro 工程文件 <code>RC_ICONS = &lt;Path&gt;</code></li>
<li>通过此种方式修改图标，可执行程序 <code>.exe</code> 的图标会修改，且不需要额外单独设置窗口图标。</li>
</ol>
<h3 id="部署产品的三种方式"><a href="#部署产品的三种方式" class="headerlink" title="部署产品的三种方式"></a>部署产品的三种方式</h3><ol>
<li><p>手动部署（不常用，比较繁琐）<br>进入 <code>.exe</code> 文件所在的文件夹（<code>debug</code>目录），双击运行 <code>.exe</code> 文件，会提示缺少的文件（包括<code>dll</code>动态库、<code>plugin</code>插件等），然后找到对应的文件移动到 <code>.exe</code> 文件的同级目录下即可，如下：<br><img src="/./BetterQT/EXE_File_Dictionary.png" alt="EXE File Dictionary"><br>如果配置了环境变量则大概率不会出现报错提示缺少库的问题，那么这种方式就会失效。</p>
</li>
<li><p>使用 windeployqt 部署<br>① 查找 <code>windeployqt.exe</code> 程序<br>② 将 <code>windeployqt.exe</code> 加入环境变量<br>③ 再命令行界面执行命令 <code>windeployqt.exe &lt;exe_file_dir&gt;</code> 完成操作<br><img src="/./BetterQT/WIN_DEPLOY_QT_1.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_2.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_3.png" alt="WIN DEPLOY QT"></p>
</li>
<li><p>使用creator 部署<br>① 项目导航窗口→运行→部署→添加自定义部署<br><img src="/./BetterQT/CREATOR_DEPLOY_1.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_2.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_3.png" alt="CREATOR DEPLOY"><br>② 输入 <code>windeployqt.exe</code> 程序及对应的命令行参数<br><img src="/./BetterQT/CREATOR_DEPLOY_4.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_5.png" alt="CREATOR DEPLOY"><br>③ 执行部署命令<br><img src="/./BetterQT/CREATOR_DEPLOY_6.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_OK.png" alt="CREATOR DEPLOY OK"></p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T02:13:00.000Z" title="2024/5/22 10:13:00">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-05-22T04:33:42.112Z" title="2024/5/22 12:33:42">2024-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/">ECharts</a></span><span class="level-item">5 分钟读完 (大约751个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Build-Tomcat/">IDEA 2022 搭建 Tomcat 环境</a></p><div class="content"><p>[TOC]</p>
<h2 id="Tomcat-环境的搭建"><a href="#Tomcat-环境的搭建" class="headerlink" title="Tomcat 环境的搭建"></a>Tomcat 环境的搭建</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/what_how_why2020/article/details/114100385">参考教程</a></p>
<h3 id="下载-Tomcat"><a href="#下载-Tomcat" class="headerlink" title="下载 Tomcat"></a>下载 Tomcat</h3><p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/index.html">Tomcat官网地址</a><br><img src="https://img-blog.csdnimg.cn/direct/d5e359b939c040b8978dc243e260f662.png#pic_center" alt="Tomcat官网"><br>在 Tomcat 官网中下载指定版本的 Tomcat，左侧 Download 处有相应版本，这里推荐 Tomcat 9 版本（因为Tomcat 10 在配置时会出现一定的问题）。<br><img src="https://img-blog.csdnimg.cn/direct/30b899f91e23440abc83c30ac92a1ccd.png#pic_center" alt="TomcatDownload"><br>下载后解压到指定位置即可。</p>
<h3 id="配置环境变量即可"><a href="#配置环境变量即可" class="headerlink" title="配置环境变量即可"></a>配置环境变量即可</h3><p>配置 Tomcat 环境变量前一定要配置好 Java 的环境变量，尤其是JAVA_HOME，这里我一开始并没有配置 <code>JAVA_HOME</code>，我的环境变量是<code>JAVA_HOME_180=xxx</code>，这种方式Tomcat是找不到<code>JAVA_HOME</code>的，因此我又重新配置了<code>JAVA_HOME</code>。<br>我的 <code>JAVA_HOME</code> 环境变量为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=D:\JDK\jdk1.8.0_231</span><br></pre></td></tr></table></figure>
<p>下面是 Tomcat 的环境变量配置：<br>新建 <code>CATALINA_HOME</code> 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_HOME=D:\tomcat\apache-tomcat-9.0.89</span><br></pre></td></tr></table></figure>
<p>修改<code>Path</code>，在 <code>Path</code> 后添加（新建）如下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%CATALINA_HOME%\lib</span><br><span class="line">%CATALINA_HOME%\bin</span><br><span class="line">%CATALINA_HOME%\lib\servlet-api.jar</span><br></pre></td></tr></table></figure>

<h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>在命令行中，执行命令：<code>startup.bat</code>，若正常打印相关配置变量、且 Tomcat 进程被阻塞，即证明环境搭建成功。访问<code>localhost:8080</code>，出现以下界面即证明成功搭建。<br><img src="https://img-blog.csdnimg.cn/direct/28287d7ab3a145e396be286cc559d6e8.png#pic_center" alt="TomcatSuccess"><br>使用 <code>shutdown.bat</code> 命令即可使阻塞的 Tomcat 进程被关闭，推荐使用这种方式关闭 Tomcat。</p>
<h3 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h3><ol>
<li>协议处理程序初始化失败：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_59125846/article/details/122178889">参考教程</a><br>这个问题有可能是由于8080端口被占用了，在Windows中可以使用如下命令查看端口的占用情况： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|<span class="built_in">findstr</span> &quot;<span class="number">8080</span>&quot;</span><br></pre></td></tr></table></figure>
 如果确实被占用了，可以使用如下命令杀死端口号为 <code>&lt;PIDNUM&gt;</code> 的进程。 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> -PID &lt;PIDNUM&gt; -F</span><br></pre></td></tr></table></figure></li>
<li>闪退<br>可能原因是：环境变量配置不正确，仔细检查环境变量的配置。</li>
<li>乱码<br>问题描述：打开startup.bat后汉字乱码<br>解决方法：在.\apache-tomcat-9.0.43\conf下打开logging.properties文件<br>将<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>替换为<code>java.util.logging.ConsoleHandler.encoding = GBK</code></li>
</ol>
<h2 id="社区版-IDEA-如何配置-Tomcat"><a href="#社区版-IDEA-如何配置-Tomcat" class="headerlink" title="社区版 IDEA 如何配置 Tomcat"></a>社区版 IDEA 如何配置 Tomcat</h2><p>CSDN 上大多数教程使用 Maven 创建 Tomcat 项目，但是这种方法实在是过于麻烦，社区版和专业版又有些不同，找不到很多东西。</p>
<p>如何配置 IDEA 2022 社区版中的 Tomcat</p>
<ol>
<li>安装插件<br>在 File → Settings → Plugin 中安装插件，搜索 Tomcat，安装插件。<br><img src="https://img-blog.csdnimg.cn/direct/240fa059550945a28d84ff346ecfb0f7.png#pic_center" alt="SmartTomcat"></li>
<li>配置Tomcat路径<br>安装插件后，在 File → Settings → Plugin → Tomcat Server<br>添加配置如下：<br><img src="https://img-blog.csdnimg.cn/direct/0c4778a942504a91b01fcfbb42555f29.png#pic_center" alt="SmartTomcatConfig"></li>
<li>完成</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-19T08:33:06.000Z" title="2024/5/19 16:33:06">2024-05-19</time>发表</span><span class="level-item"><time dateTime="2024-05-22T01:49:59.850Z" title="2024/5/22 09:49:59">2024-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span> / </span><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/">Kaggle</a></span><span class="level-item">38 分钟读完 (大约5697个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/19/BELKA-2024/">BELKA_2024</a></p><div class="content"><p>[TOC]</p>
<h1 id="Leash-Bio-Predict-New-Medicines-with-BELKA"><a href="#Leash-Bio-Predict-New-Medicines-with-BELKA" class="headerlink" title="Leash Bio - Predict New Medicines with BELKA"></a>Leash Bio - Predict New Medicines with BELKA</h1><p>用 <em><strong>BELKA</strong></em> 预测新药</p>
<p>Predict small molecule-protein interactions using the Big Encoded Library for Chemical Assessment (BELKA)</p>
<p>使用化学评估大编码库（BELKA）预测小分子蛋白质相互作用</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>In this competition, you’ll develop machine learning (ML) models to predict the binding affinity of small molecules to specific protein targets – a critical step in drug development for the pharmaceutical industry that would pave the way for more accurate drug discovery. You’ll help predict which drug-like small molecules (chemicals) will bind to three possible protein targets.</p>
<p>在这场比赛中，你将开发机器学习（ML）模型来预测小分子与特定<strong>蛋白质靶标（目标蛋白）</strong>的结合亲和力——这是制药行业药物开发的关键一步，将为更准确的药物发现铺平道路。你将帮助预测哪种药物样的小分子（化学物质）将与三种可能的蛋白质靶点结合。</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Small molecule drugs are chemicals that interact with cellular protein machinery and affect the functions of this machinery in some way. Often, drugs are meant to inhibit the activity of single protein targets, and those targets are thought to be involved in a disease process. A classic approach to identify such candidate molecules is to physically make them, one by one, and then expose them to the protein target of interest and test if the two interact. This can be a fairly laborious and time-intensive process.</p>
<p><em>小分子药物是与细胞蛋白质机制相互作用并以某种方式影响该机制功能的化学物质。通常，药物旨在抑制单个蛋白质靶标的活性，而这些靶标被认为与疾病过程有关。识别这类候选分子的一种经典方法是一个接一个地进行物理制造，然后将其暴露于感兴趣的蛋白质靶点，并测试两者是否相互作用。这可能是一个相当费力和耗时的过程。</em></p>
<p>The US Food and Drug Administration (FDA) has approved roughly <a target="_blank" rel="noopener" href="https://www.fda.gov/drugs/development-approval-process-drugs/new-drugs-fda-cders-new-molecular-entities-and-new-therapeutic-biological-products">2,000 novel molecular entities</a> in its <a target="_blank" rel="noopener" href="https://www.fda.gov/about-fda/histories-fda-regulated-products/summary-nda-approvals-receipts-1938-present">entire history</a>. However, the number of chemicals in druglike space has been <a target="_blank" rel="noopener" href="https://www.nature.com/articles/432823a">estimated to be 10^60</a>, a space far too big to physically search. There are likely effective treatments for human ailments hiding in that chemical space, and better methods to find such treatments are desirable to us all.</p>
<p><em>美国食品药品监督管理局（FDA）已经批准了大约<a target="_blank" rel="noopener" href="https://www.fda.gov/drugs/development-approval-process-drugs/new-drugs-fda-cders-new-molecular-entities-and-new-therapeutic-biological-products">2000种新型分子实体</a>在其<a target="_blank" rel="noopener" href="https://www.fda.gov/about-fda/histories-fda-regulated-products/summary-nda-approvals-receipts-1938-present">整个历史</a>. 然而，类药物领域的化学物质数量<a target="_blank" rel="noopener" href="https://www.nature.com/articles/432823a">估计为$10^60$</a>，这个空间太大了，无法进行物理搜索。在这个化学空间里，可能有有效的治疗人类疾病的方法，而找到更好的治疗方法对我们所有人来说都是可取的。</em></p>
<p>To evaluate potential search methods in small molecule chemistry, competition host Leash Biosciences physically tested some 133M small molecules for their ability to interact with one of three protein targets using DNA-encoded chemical library (DEL) technology. This dataset, the Big Encoded Library for Chemical Assessment (BELKA), provides an excellent opportunity to develop predictive models that may advance drug discovery.</p>
<p><em>为了评估小分子化学中潜在的搜索方法，比赛主办方Leash Biosciences使用DNA编码化学文库（DEL）技术对约133M个小分子进行了物理测试，以确定它们与三个蛋白质靶标之一相互作用的能力。该数据集，即化学评估大编码库（BELKA），为开发可能促进药物发现的预测模型提供了极好的机会。</em></p>
<p>Datasets of this size are rare and restricted to large pharmaceutical companies. The current best-curated public dataset of this kind is perhaps <a target="_blank" rel="noopener" href="https://www.bindingdb.org/rwd/bind/index.jsp">bindingdb</a>, which, at 2.8M binding measurements, is much smaller than BELKA.</p>
<p><em>这种规模的数据集非常罕见，仅限于大型制药公司。目前这类最好的公共数据集可能是<a target="_blank" rel="noopener" href="https://www.bindingdb.org/rwd/bind/index.jsp">bindingdb</a>，在2.8M的结合测量值下，比BELKA小得多。</em></p>
<p>This competition aims to revolutionize small molecule binding prediction by harnessing ML techniques. Recent advances in ML approaches suggest it might be possible to search chemical space by inference using well-trained computational models rather than running <a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">laboratory</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">experiments</a>. Similar progress in <a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">other</a> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">fields</a> suggest using ML to search across vast spaces could be a generalizable approach applicable to many domains. We hope that by providing BELKA we will democratize aspects of computational drug discovery and assist the community in finding new lifesaving medicines.</p>
<p><em>这项竞赛旨在通过利用ML技术彻底改变小分子结合预测。ML方法的最新进展表明，使用训练有素的计算模型而不是进行<a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">实验室</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">实验</a>，通过推理搜索化学空间是可能的。<a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">其他</a> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">领域</a>的类似进展表明，使用ML在广阔的空间中搜索可能是一种适用于许多领域的通用方法。我们希望通过提供BELKA，我们将使计算药物发现的各个方面民主化，并帮助社区寻找新的救命药物。</em></p>
<p>Here, you’ll build predictive models to estimate the binding affinity of unknown chemical compounds to specified protein targets. You may use the training data provided; alternatively, there are a number of methods to make small molecule binding predictions without relying on empirical binding data (e.g. <a target="_blank" rel="noopener" href="https://github.com/gcorso/DiffDock">DiffDock</a>, and this contest was designed to allow for such submissions).</p>
<p><em>在这里，你将建立预测模型来估计未知化合物与特定蛋白质靶标的结合亲和力。您可以使用提供的培训数据；或者，有许多方法可以在不依赖经验结合数据的情况下进行小分子结合预测（例如<a target="_blank" rel="noopener" href="https://github.com/gcorso/DiffDock">DiffDock</a>，而本次竞赛旨在允许此类提交）。</em></p>
<p>Your work will contribute to advances in small molecule chemistry used to accelerate drug discovery.</p>
<p><em>你的工作将有助于促进用于加速药物发现的小分子化学的进步。</em></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>This metric for this competition is the average precision calculated for each (protein, split group) and then averaged for the final score. Please see this <a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/leash-BELKA/discussion/503232">forum post</a> for important details.</p>
<p><em>这项比赛的指标是为每个（蛋白质、分组）计算的平均精度，然后为最终得分取平均值。请参阅此<a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/leash-BELKA/discussion/503232">论坛帖子</a>了解重要细节。</em></p>
<p>Here’s the <a target="_blank" rel="noopener" href="https://www.kaggle.com/code/metric/leash-average-map">code</a> for the implementation.</p>
<p><em>这是<a target="_blank" rel="noopener" href="https://www.kaggle.com/code/metric/leash-average-map">代码</a>以供实施。</em></p>
<h3 id="Submission-File"><a href="#Submission-File" class="headerlink" title="Submission File"></a>Submission File</h3><p>For each <code>id</code> in the test set, you must predict a probability for the binary target <code>binds</code> target. The file should contain a header and have the following format:</p>
<p><em>对于测试集中的每个</em><code>id</code>，<em>您必须预测二进制目标“绑定”目标的概率。该文件应包含一个标头，并具有以下格式：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,binds</span><br><span class="line">295246830,0.5</span><br><span class="line">295246831,0.5</span><br><span class="line">295246832,0.5</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure>

<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul>
<li><strong>April 4, 2024</strong> - Start Date.</li>
<li><strong>July 1, 2024</strong> - Entry Deadline. You must accept the competition rules before this date in order to compete.</li>
<li><strong>July 1, 2024</strong> - Team Merger Deadline. This is the last day participants may join or merge teams.</li>
<li><strong>July 8, 2024</strong> - Final Submission Deadline.</li>
</ul>
<p>All deadlines are at 11:59 PM UTC on the corresponding day unless otherwise noted. The competition organizers reserve the right to update the contest timeline if they deem it necessary.</p>
<h2 id="Prizes"><a href="#Prizes" class="headerlink" title="Prizes"></a>Prizes</h2><ul>
<li>First Prize: $12,000</li>
<li>Second Prize: $10,000</li>
<li>Third Prize: $10,000</li>
<li>Fourth Prize: $8,000</li>
<li>Fifth Prize: $5,000</li>
<li>Top Student Group: $5,000 to the highest performing student team. A team would be considered a student team if majority members (e.g. at least 3 out of a 5 member team) are students enrolled in a high school or university degree. In the case of an even number of members, half of them must be students.</li>
</ul>
<h2 id="Competition-Host"><a href="#Competition-Host" class="headerlink" title="Competition Host"></a>Competition Host</h2><p><a target="_blank" rel="noopener" href="https://www.leash.bio/">Leash Biosciences</a> is a discovery-stage biotechnology company that seeks to improve medicinal chemistry with machine learning approaches and massive data collection. Leash is comprised of wet lab scientists and dry lab scientists in equal numbers, and is proudly headquartered in Salt Lake City, Utah, USA.</p>
<h2 id="Additional-Details"><a href="#Additional-Details" class="headerlink" title="Additional Details"></a>Additional Details</h2><h3 id="Chemical-Representations"><a href="#Chemical-Representations" class="headerlink" title="Chemical Representations"></a>Chemical Representations</h3><p>One of the goals of this competition is to explore and compare many different ways of representing molecules. Small molecules <a target="_blank" rel="noopener" href="https://jcheminf.biomedcentral.com/articles/10.1186/s13321-020-00460-5">have</a> <a target="_blank" rel="noopener" href="https://wires.onlinelibrary.wiley.com/doi/10.1002/wcms.1603">been</a> [represented](<a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acsinfocus.7e7006?ref=infocus/AI_&">https://pubs.acs.org/doi/10.1021/acsinfocus.7e7006?ref=infocus%2FAI_&amp;</a> Machine Learning) <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10689004/">with</a> SMILES, graphs, 3D structures, and more, including more esoteric methods <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1801.10130">such as spherical convolutional neural nets</a>. We encourage competitors to explore not only different methods of making predictions but also to try different ways of representing the molecules.</p>
<p>We provide the molecules in SMILES format.</p>
<p><em>这场比赛的目标之一是探索和比较许多不同的分子表现方式。小分子已经用SMILES、图形、3D结构等表示，包括更深奥的方法，如球形卷积神经网络。我们鼓励竞争对手不仅探索不同的预测方法，还尝试不同的分子表示方法。</em></p>
<p><em>我们提供SMILES格式的分子。</em></p>
<h3 id="SMILES"><a href="#SMILES" class="headerlink" title="SMILES"></a>SMILES</h3><p>SMILES is a concise string notation used to represent the structure of chemical molecules. It encodes the molecular graph, including atoms, bonds, connectivity, and stereochemistry as a linear sequence of characters, by traversing the molecule graph. SMILES is widely used in machine learning applications for chemistry, such as molecular property prediction, drug discovery, and materials design, as it provides a standardized and machine-readable format for representing and manipulating chemical structures.</p>
<p>The SMILES in this dataset should be sufficient to be translated into any other chemical representation format that you want to try. A simple way to perform some of these translations is with <a target="_blank" rel="noopener" href="https://www.rdkit.org/docs/GettingStartedInPython.html">RDKit</a>.</p>
<p><em>SMILES是一种简明的字符串表示法，用于表示化学分子的结构。它通过遍历分子图，将分子图（包括原子、键、连接性和立体化学）编码为线性字符序列。SMILES广泛用于化学的机器学习应用，如分子性质预测、药物发现和材料设计，因为它为表示和操纵化学结构提供了标准化和机器可读的格式。</em><br><em>该数据集中的SMILES应该足以转换为您想要尝试的任何其他化学表示格式。执行其中一些翻译的一种简单方法是使用<a target="_blank" rel="noopener" href="https://www.rdkit.org/docs/GettingStartedInPython.html">RDKit</a>.</em></p>
<h3 id="Details-about-the-experiments"><a href="#Details-about-the-experiments" class="headerlink" title="Details about the experiments"></a>Details about the experiments</h3><h3 id="DELs-are-libraries-of-small-molecules-with-unique-DNA-barcodes-covalently-attached"><a href="#DELs-are-libraries-of-small-molecules-with-unique-DNA-barcodes-covalently-attached" class="headerlink" title="DELs are libraries of small molecules with unique DNA barcodes covalently attached"></a>DELs are libraries of small molecules with unique DNA barcodes covalently attached</h3><p>Traditional <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nrd3368">high-throughput screening</a> requires keeping individual small molecules in separate, identifiable tubes and demands a lot of liquid handling to test each one of those against the protein target of interest in a separate reaction. The logistical overhead of these efforts tends to restrict screening collections, called libraries, to 50K-5M small molecules. A scalable solution to this problem, DNA-encoded chemical libraries, was <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">described in 2009</a>. As DNA sequencing got <a target="_blank" rel="noopener" href="https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost">cheaper and cheaper</a>, it became clear that DNA itself could be used as a label to identify, and deconvolute, collections of molecules in a complex mixture. <a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41573-023-00713-6">DELs</a> <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8369695/">leverage</a> this DNA sequencing technology.</p>
<p>These barcoded small molecules are in a pool (many in a single tube, rather than one tube per small molecule) and are exposed to the protein target of interest in solution. The protein target of interest is then rinsed to remove small molecules in the DEL that don’t bind the target, and the remaining binders are collected and their DNA sequenced.</p>
<p><strong>DEL是共价连接有独特DNA条形码的小分子库</strong><br><em>传统<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nrd3368">高通量筛选</a>需要将单个小分子保持在单独的、可识别的管中，并且需要大量的液体处理来在单独的反应中针对感兴趣的蛋白质靶标测试其中的每一个。这些工作的后勤开销往往将筛选收藏（称为文库）限制在5000万至500万个小分子以内。这个问题的一个可扩展的解决方案，DNA编码的化学文库，<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">在2009年描述</a>. 随着DNA测序变得<a target="_blank" rel="noopener" href="https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost">越来越便宜</a>，很明显，DNA本身可以用作标签来识别和消除复杂混合物中分子的聚集。<a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41573-023-00713-6%E5%BD%B1%E5%93%8D%E5%8A%9Bhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC8369695/">DELs</a>这种DNA测序技术。</em><br><em>这些条形码小分子在一个池中（许多在单管中，而不是每个小分子一管），并暴露于溶液中感兴趣的蛋白质靶标。然后冲洗感兴趣的蛋白质靶标，以去除DEL中不与靶标结合的小分子，收集剩余的结合物并对其DNA进行测序。</em></p>
<h3 id="DELs-are-manufactured-by-combining-different-building-blocks"><a href="#DELs-are-manufactured-by-combining-different-building-blocks" class="headerlink" title="DELs are manufactured by combining different building blocks"></a>DELs are manufactured by combining different building blocks</h3><p>An intuitive way to think about DELs is to imagine a Mickey Mouse head as an example of a small molecule in the DEL. We attach the DNA barcode to Mickey’s chin. Mickey’s left ear is connected by a zipper; Mickey’s right ear is connected by velcro. These attachment points of zippers and velcro are analogies to different chemical reactions one might use to construct the DEL.</p>
<p>We could purchase ten different Mickey Mouse faces, ten different zipper ears, and ten different velcro ears, and use them to construct our small molecule library. By creating every combination of these three, we’ll have 1,000 small molecules, but we only needed thirty building blocks (faces and ears) to make them. This combinatorial approach is what allows DELs to have so many members: the library in this competition is composed of 133M small molecules. The 133M small molecule library used here, AMA014, was provided by <a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>. It has a triazine core and superficially resembles the DELs described <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">here</a>.</p>
<p><strong>DEL是通过组合不同的构建块来制造的</strong><br>一个思考DEL的直观方法是想象一个米老鼠的头作为DEL中一个小分子的例子。我们把DNA条形码贴在米奇的下巴上。米奇的左耳由拉链连接；米奇的右耳是用尼龙搭扣连接的。拉链和尼龙搭扣的这些连接点类似于可能用于构建DEL的不同化学反应。<br>我们可以购买十个不同的米老鼠脸、十个不同拉链耳朵和十个不同尼龙搭扣耳朵，并用它们来构建我们的小分子库。通过创建这三者的每一个组合，我们将拥有1000个小分子，但我们只需要30个构建块（脸和耳朵）就可以制造它们。这种组合方法使DEL能够拥有如此多的成员：这场竞争中的文库由133M个小分子组成。这里使用的133M小分子文库AMA014由<a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>提供。它有一个三嗪核心，表面上类似于<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">此处</a>描述的DEL。</p>
<img src="https://www.googleapis.com/download/storage/v1/b/kaggle-user-content/o/inbox%2F1095143%2F1901c6caa0c6c011617f4dec525d7bbe%2FKaggle%20v2%20(1).png?generation=1712179256934503&alt=media">

<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Leash Biosciences is grateful for the generous cosponsorship of <a target="_blank" rel="noopener" href="https://www.topharvestcap.com/">Top Harvest Capital</a> and <a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>.</p>
<h2 id="Citation"><a href="#Citation" class="headerlink" title="Citation"></a>Citation</h2><p>Andrew Blevins, Ian K Quigley, Brayden J Halverson, Nate Wilkinson, Rebecca S Levin, Agastya Pulapaka, Walter Reade, Addison Howard. (2024). Leash Bio - Predict New Medicines with BELKA. Kaggle. <a target="_blank" rel="noopener" href="https://kaggle.com/competitions/leash-BELKA">https://kaggle.com/competitions/leash-BELKA</a></p>
<hr>
<h2 id="Dataset-Description"><a href="#Dataset-Description" class="headerlink" title="Dataset Description"></a>Dataset Description</h2><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>The examples in the competition dataset are represented by a binary classification of whether a given small molecule is a binder or not to one of three protein targets. The data were collected using DNA-encoded chemical library (DEL) technology.</p>
<p><em>比赛数据集中的例子由给定小分子是否与三个蛋白质靶标之一结合的二元分类表示。使用DNA编码化学文库（DEL）技术收集数据。</em></p>
<p>We represent chemistry with SMILES (<a target="_blank" rel="noopener" href="https://archive.epa.gov/med/med_archive_03/web/html/smiles.html">Simplified Molecular-Input Line-Entry System</a>) and the labels as binary binding classifications, one per protein target of three targets.</p>
<p>我们用SMILES（<a target="_blank" rel="noopener" href="https://archive.epa.gov/med/med_archive_03/web/html/smiles.html">简化分子输入 行输入系统</a>)和二元绑定分类来表示化学，三个靶标中的每个蛋白质靶标都有一个。</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a><strong>Files</strong></h2><p><strong>[train&#x2F;test].[csv&#x2F;parquet]</strong> - The train or test data, available in both the csv and parquet formats.</p>
<ul>
<li><code>id</code> - A unique example_id that we use to identify the molecule-binding target pair.</li>
<li><code>buildingblock1_smiles</code> - The structure, in SMILES, of the first building block</li>
<li><code>buildingblock2_smiles</code> - The structure, in SMILES, of the second building block</li>
<li><code>buildingblock3_smiles</code> - The structure, in SMILES, of the third building block</li>
<li><code>molecule_smiles</code> - The structure of the fully assembled molecule, in SMILES. This includes the three building blocks and the triazine core. Note we use a <code>[Dy]</code> as the stand-in for the DNA linker.</li>
<li><code>protein_name</code> - The protein target name</li>
<li><code>binds</code> - The target column. A binary class label of whether the molecule binds to the protein. Not available for the test set.</li>
</ul>
<p><strong>sample_submission.csv</strong> - A sample submission file in the correct format</p>
<p><strong>[train&#x2F;test].[csv&#x2F;parquet]</strong> - 训练或测试数据，csv和parquet格式均可。</p>
<ul>
<li><code>id</code> - 我们用来识别分子结合靶标对的唯一示例_id。</li>
<li><code>buildingblock1_smiles</code> - 第一个构建块的结构，以SMILES表示</li>
<li><code>buildingblock2_smiles</code> - 第二个构建块的结构，以SMILES表示</li>
<li><code>buildingblock3_smiles</code> - 第三个构建块的结构，以SMILES表示</li>
<li><code>molecule_smiles</code> - 完全组装的分子的结构，以SMILES表示。这包括三个构建块和三嗪核心。请注意，我们使用<code>[Dy]</code>作为DNA连接子的替代。</li>
<li><code>protein_name</code> - 蛋白质靶标名称</li>
<li><code>binds</code> - 目标列。分子是否与蛋白质结合的二进制类标签。不适用于测试集。</li>
</ul>
<h2 id="Competition-data"><a href="#Competition-data" class="headerlink" title="Competition data"></a><strong>Competition data</strong></h2><p>All data were generated in-house at Leash Biosciences. We are providing roughly 98M training examples per protein, 200K validation examples per protein, and 360K test molecules per protein. To test generalizability, the test set contains building blocks that are not in the training set. These datasets are very imbalanced: roughly 0.5% of examples are classified as binders; we used 3 rounds of selection in triplicate to identify binders experimentally. Following the competition, Leash will make all the data available for future use (3 targets × 3 rounds of selection × 3 replicates × 133M molecules, or 3.6B measurements).</p>
<p><em>所有数据均由Leash Biosciences公司内部生成。我们为每种蛋白质提供了大约 98M 个训练实例，为每种蛋白提供了 200K 个验证实例，为每个蛋白质提供了 360K 个测试分子。为了测试可推广性，测试集包含不在训练集中的构建块。这些数据集非常不平衡：大约0.5%的示例被归类为绑定；我们使用了三轮一式三份的选择来实验鉴定粘合剂。比赛结束后，Leash将提供所有数据供未来使用（3个靶标×3轮选择×3个重复×3.33M个分子，或3.6B测量值）。</em></p>
<h2 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a><strong>Targets</strong></h2><p>Proteins are encoded in the genome, and names of the genes encoding those proteins are typically bestowed by their discoverers and regulated by the <a target="_blank" rel="noopener" href="https://www.genenames.org/">Hugo Gene Nomenclature Committee</a>. The protein products of these genes can sometimes have different names, often due to the history of their discovery.</p>
<p>We screened three protein targets for this competition.</p>
<p>蛋白质在基因组中编码，编码这些蛋白质的基因的名称通常由其发现者命名，并由<a target="_blank" rel="noopener" href="https://www.genenames.org/">雨果基因命名委员会</a>监管。这些基因的蛋白质产物有时可能有不同的名称，通常是由于它们的发现历史。<br>我们为这次比赛筛选了三个蛋白质靶点。</p>
<h3 id="EPHX2-sEH"><a href="#EPHX2-sEH" class="headerlink" title="EPHX2 (sEH)"></a><strong>EPHX2 (sEH)</strong></h3><p>The first target, epoxide hydrolase 2, is encoded by the EPHX2 genetic locus, and its protein product is commonly named “soluble epoxide hydrolase”, or abbreviated to sEH. Hydrolases are enzymes that catalyze certain chemical reactions, and EPHX2&#x2F;sEH also hydrolyzes certain phosphate groups. EPHX2&#x2F;sEH is a potential drug target for high blood pressure and diabetes progression, and small molecules inhibiting EPHX2&#x2F;sEH from earlier DEL efforts <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8429121/">made it to clinical trials</a>.</p>
<p>EPHX2&#x2F;sEH was also screened with DELs, and hits predicted with ML approaches, in a <a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">recent</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">study</a> but the screening data were not published. We included EPHX2&#x2F;sEH to allow contestants an external gut check for model performance by comparing to these previously-published results.</p>
<p>We screened EPHX2&#x2F;sEH <a target="_blank" rel="noopener" href="https://www.caymanchem.com/product/10011669/soluble-epoxide-hydrolase-(human-recombinant)">purchased from Cayman Chemical</a>, a life sciences commercial vendor. For those contestants wishing to incorporate protein structural information in their submissions, the amino sequence is positions 2-555 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/P34913/entry#sequences">P34913</a>, the crystal structure can be found in <a target="_blank" rel="noopener" href="https://www.rcsb.org/structure/3i28">PDB entry 3i28</a>, and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/P34913">34913</a>. Additional EPHX2&#x2F;sEH crystal structures with ligands bound can be found in PDB.</p>
<p>第一个靶标环氧化物水解酶2由EPHX2基因座编码，其蛋白产物通常被命名为“可溶性环氧化物水解酶”，或缩写为sEH。水解酶是催化某些化学反应的酶，EPHX2&#x2F;sEH也水解某些磷酸基团。EPHX2&#x2F;sEH是高血压和糖尿病进展的潜在药物靶点，早期DEL研究中抑制EPHX2&#x2F;s EH的小分子<a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8429121/">已进入临床试验</a>.<br>EPHX2&#x2F;sEH也用DEL进行了筛选，并用ML方法预测了命中率(<a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html%E5%AD%A6%E4%B9%A0https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452)%E4%BD%86%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B2%A1%E6%9C%89%E5%85%AC%E5%B8%83%E3%80%82%E6%88%91%E4%BB%AC%E7%BA%B3%E5%85%A5%E4%BA%86EPHX2/sEH%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B8%8E%E4%B9%8B%E5%89%8D%E5%85%AC%E5%B8%83%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%EF%BC%8C%E8%AE%A9%E5%8F%82%E8%B5%9B%E8%80%85%E8%83%BD%E5%A4%9F%E5%AF%B9%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%A4%96%E9%83%A8%E6%A3%80%E6%9F%A5%E3%80%82">https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html学习https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452)但筛选数据没有公布。我们纳入了EPHX2/sEH，通过与之前公布的结果进行比较，让参赛者能够对模型性能进行外部检查。</a><br>我们筛选了EPHX2&#x2F;sEH<a target="_blank" rel="noopener" href="https://www.caymanchem.com/product/10011669/soluble-epoxide-hydrolase-%EF%BC%88%E4%BA%BA%E7%B1%BB%E9%87%8D%E7%BB%84%EF%BC%89%EF%BC%89%EF%BC%8C%E4%B8%80%E5%AE%B6%E7%94%9F%E5%91%BD%E7%A7%91%E5%AD%A6%E5%95%86%E4%B8%9A%E4%BE%9B%E5%BA%94%E5%95%86%E3%80%82%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E5%B8%8C%E6%9C%9B%E5%9C%A8%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81%E4%B8%AD%E5%8A%A0%E5%85%A5%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%82%E8%B5%9B%E8%80%85%EF%BC%8C%E6%B0%A8%E5%9F%BA%E9%85%B8%E5%BA%8F%E5%88%97%E4%BD%8D%E4%BA%8EUniProt%E6%9D%A1%E7%9B%AE%E7%9A%842-555%E4%BD%8D[P34913](https://www.uniprot.org/uniprotkb/P34913/entry#sequences)%EF%BC%8C%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%9C%A8[PDB%E6%9D%A1%E7%9B%AE3i28]%E4%B8%AD%E6%89%BE%E5%88%B0(https://www.rcsb.org/structure/3i28)%EF%BC%8C%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E5%9C%A8AlphaFold2%E6%9D%A1%E7%9B%AE[34913]%E4%B8%AD%E6%89%BE%E5%88%B0(https://alphafold.ebi.ac.uk/entry/P34913">购自开曼化学</a>. 在PDB中可以发现具有结合配体的额外的EPHX2&#x2F;sEH晶体结构。</p>
<h3 id="BRD4"><a href="#BRD4" class="headerlink" title="BRD4"></a><strong>BRD4</strong></h3><p>The second target, bromodomain 4, is encoded by the BRD4 locus and its protein product is also named BRD4. Bromodomains bind to protein spools in the nucleus that DNA wraps around (called histones) and affect the likelihood that the DNA nearby is going to be transcribed, producing new gene products. Bromodomains play roles in cancer progression and a number of drugs <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10096006/">have been discovered to inhibit their activities</a>.</p>
<p>BRD4 <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01670">has been screened with DEL approaches previously</a> but the screening data were not published. We included BRD4 to allow contestants to evaluate candidate molecules for oncology indications.</p>
<p>We screened BRD4 <a target="_blank" rel="noopener" href="https://www.activemotif.com/catalog/details/31594/recombinant-brd4-44-460-protein">purchased from Active Motif</a>, a life sciences commercial vendor. For those contestants wishing to incorporate protein structural information in their submissions, the amino acid sequence is positions 44-460 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/O60885/entry#sequences">O60885-1</a>, the crystal structure (for a single domain) can be found in PDB entry <a target="_blank" rel="noopener" href="https://www.rcsb.org/structure/7USK">7USK</a> and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/O60885">O60885</a>. Additional BRD4 crystal structures with ligands bound can be found in PDB.</p>
<h3 id="ALB-HSA"><a href="#ALB-HSA" class="headerlink" title="ALB (HSA)"></a><strong>ALB (HSA)</strong></h3><p>The third target, serum albumin, is encoded by the ALB locus and its protein product is also named ALB. The protein product is sometimes abbreviated as HSA, for “human serum albumin”. ALB, the most <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/books/NBK459198/">common protein in the blood</a>, is used to drive osmotic pressure (to bring fluid back from tissues into blood vessels) and to transport many ligands, hormones, fatty acids, and more.</p>
<p>Albumin, being the most abundant protein in the blood, often plays a role in absorbing candidate drugs in the body and sequestering them from their target tissues. Adjusting candidate drugs to bind less to albumin and other blood proteins <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acsptsci.2c00115">is a strategy to help these candidate drugs be more effective</a>.</p>
<p>ALB <a target="_blank" rel="noopener" href="https://pubmed.ncbi.nlm.nih.gov/25650139/">has been screened with DEL approaches previously</a> but the screening data were not published. We included ALB to allow contestants to build models that might have a larger impact on drug discovery across many disease types. The ability to predict ALB binding well would allow drug developers to improve their candidate small molecule therapies much more quickly than physically manufacturing many variants and testing them against ALB empirically in an iterative process.</p>
<p>We screened ALB <a target="_blank" rel="noopener" href="https://www.abcam.com/products/proteins-peptides/recombinant-human-serum-albumin-protein-his-tag-ab217817.html">purchased from Active Motif</a>. For those contestants wishing to incorporate protein structural information in their submissions, the amino acid sequence is positions 25 to 609 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/P02768/entry#sequences">P02768</a>, the crystal structure can be found in PDB entry <a target="_blank" rel="noopener" href="https://www.ebi.ac.uk/pdbe/entry/pdb/1AO6">1AO6</a>, and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/P02768">P02768</a>. Additional ALB crystal structures with ligands bound can be found in PDB.</p>
<p>Good luck!</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-07T12:22:34.000Z" title="2024/5/7 20:22:34">2024-05-07</time>发表</span><span class="level-item"><time dateTime="2024-05-27T02:24:04.468Z" title="2024/5/27 10:24:04">2024-05-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/">树(Tree)</a></span><span class="level-item">17 分钟读完 (大约2598个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/07/Tree/">Tree</a></p><div class="content"><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h2><p>[TOC]</p>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树是一种非常重要的非线性数据结构，树的一个节点可能会生出多个分支。一般而言，一棵树会包含一个根节点，向下延伸出若干子节点，每个末端的节点被称为叶子节点。<br><img src="/./Tree/Tree.png"></p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>有根树存在一个<strong>根节点Root</strong>，如下：<br><img src="/./Tree/RootTree.drawio.png"><br>对于图中概念的一些补充：</p>
<ul>
<li>节点拥有的子节点个数叫做节点的<strong>度</strong>。</li>
<li>具有相同深度的节点处于同一层，方便表示。</li>
<li>节点和节点之间的线叫做<strong>边</strong>。</li>
<li>路径：指从树上一点到另外一点所经过的<strong>不重合的</strong>点和边的集合，题目中有时会单指点或边的集合。</li>
<li>一颗 $n$ 个节点的树，一定有 $n-1$ 条边</li>
</ul>
<h4 id="无根树"><a href="#无根树" class="headerlink" title="无根树"></a>无根树</h4><hr>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>是一种<strong>特殊的树</strong>。</p>
<ul>
<li>所有节点的度都不超过2的树称为二叉树。</li>
<li>因为每个二叉树的节点最多只会有两个子结点，它的两个子节点一般会被称为左、右儿子，两棵子树一般会被称为左、右子树。</li>
<li>左、右儿子甚至根节点本身都有可能缺失（一个节点都没有可以称为空二叉树）。</li>
</ul>
<h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><p>二叉树也有两个比较特殊的类型：<strong>满二叉树和完全二叉树</strong>。<br><img src="/./Tree/FullBinaryTree.png"></p>
<ul>
<li><strong>满二叉树</strong>：所有层的节点全满。<ul>
<li>满二叉树的一些规律<ul>
<li>第 $n$ 层的节点个数为 $2^{n-1}$</li>
<li>深度为 $n$ 的满二叉树节点数为 $2^0 + 2^1 + 2^2 + \dots + 2^{n-1}&#x3D; 2^n-1$</li>
</ul>
</li>
</ul>
</li>
<li><strong>完全二叉树</strong>：除了最后一层以外，其他层的节点个数全满，而且最后一层的节点从左到右排满直到最后一个节点。<ul>
<li>完全二叉树的一些规律<ul>
<li>完全二叉树的节点个数不会少于 $(2^{n-1}-1)+1 &#x3D; 2^{n-1}$</li>
<li>完全二叉树的节点个数不会多于 $2^{n} - 1$</li>
<li>一棵完全二叉树，设当前节点为 $t$，其父节点为 $t&#x2F;2$，其左儿子为 $2t$，其右儿子为 $2t+1$，借助该规律，我们可以将完全二叉树使用数组进行存储。<br><img src="/./Tree/BinaryTree_NodeNumber.drawio.png"></li>
</ul>
</li>
</ul>
</li>
<li>完全二叉树的存储<ul>
<li>完全二叉树由于它的特性，可以简单用数组来模拟其结构</li>
<li>一般会以数组$[1]$位置为根节点建立二叉树</li>
<li>数组$[t]$位置的左儿子和右儿子对应的位置分别为$[2t]$和$[2t+1]$，父节点的位置为$[t&#x2F;2]$。</li>
<li>堆、线段树等数据结构的建立也会参考这个方式</li>
</ul>
</li>
</ul>
<p>完全二叉树的建立（使用数组），使用这种方法建立非完全二叉树，会导致空间的浪费：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="built_in">UpdateData</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子节点存在</span></span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">2</span> * t);</span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">2</span> * t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以使用其他方法来完成一般二叉树的存储，可以用数组下标模拟节点编号，用多个数组来记录节点信息。为了方便，我们也可以使用结构体来存储这些信息：<br><img src="/./Tree/NormalBinaryTree.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用结构体来实现上述操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> l, r, fa;</span><br><span class="line">&#125;a[<span class="number">100010</span>];</span><br></pre></td></tr></table></figure>
<p>当然，作为一种树形结构，使用指针显然是更合适的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针来实现上述操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode* l;</span><br><span class="line">    TreeNode* r;</span><br><span class="line">    TreeNode* fa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* root;</span><br></pre></td></tr></table></figure>
<p>使用指针的一些操作：</p>
<ul>
<li>新建节点：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode *l, *r, *fa;   <span class="comment">// 初始为 NULL</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)&#123; value = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br></pre></td></tr></table></figure></li>
<li>根节点初始化：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br></pre></td></tr></table></figure></li>
<li>插入节点：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(TreeNode* fa, TreeNode* p, <span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">// flag = 0 插入到左边</span></span><br><span class="line">    <span class="comment">// flag = 1 插入到右边</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">        fa-&gt;l = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa-&gt;r = p;</span><br><span class="line">    p-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line"><span class="built_in">Insert</span>(fa, treeNode, flag);</span><br></pre></td></tr></table></figure></li>
<li>删除节点  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 删除节点</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历可分为先序遍历、中序遍历和后序遍历，这三种方式以访问根节点的时间来区分。<br><strong>先序遍历（Degree-Left-Right, DLR）</strong>：根→左→右<br><strong>中序遍历（Left-Degree-Right, LDR）</strong>：左→根→右<br><strong>先序遍历（Left-Right-Degree, LRD）</strong>：左→右→根</p>
<!-- ![](./Tree/DLR_LDR_LRD.png) -->
<img src="./Tree/DLR_LDR_LRD.png" width=350px height=auto>

<p>在该图中，先序遍历的结果为 <code>1 2 4 5 3 6 7</code>，先序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">preOrder</span>(treeNode-&gt;l);</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">preOrder</span>(treeNode-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">preOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>在该图中，中序遍历的结果为 <code>4 2 5 1 6 3 7</code>，中序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">inOrder</span>(treeNode-&gt;l);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">inOrder</span>(treeNode-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>在该图中，后序遍历的结果为 <code>4 5 2 6 7 3 1</code>，后序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">postOrder</span>(treeNode-&gt;l);</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">postOrder</span>(treeNode-&gt;r);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">postOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>除了上述的几种遍历方式，还有层级遍历（BFS）方式对树进行遍历。层级遍历是借助队列（Queue）来实现的，其过程可以描述如下：<br><img src="/./Tree/BFSTree.png"></p>
<p>层级遍历的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">1</span>, rear = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear) &#123;</span><br><span class="line">        TreeNode* p = q[front];     <span class="comment">// 选取队列中最前面的节点</span></span><br><span class="line">        front++;</span><br><span class="line">        cout &lt;&lt; p-&gt;value &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;l)    q[++rear] = p-&gt;l;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;r)    q[++rear] = p-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(root);</span><br></pre></td></tr></table></figure>
<h4 id="计算节点的深度"><a href="#计算节点的深度" class="headerlink" title="计算节点的深度"></a>计算节点的深度</h4><p>我们可以在遍历树的时候同时进行节点深度的记录，简单来讲就是：<br>$$depth_{儿子} &#x3D; depth_{父亲} + 1$$</p>
<h3 id="有根树-Tree"><a href="#有根树-Tree" class="headerlink" title="有根树(Tree)"></a>有根树(Tree)</h3><p>这里不再是二叉树这种特殊的树，而是一般意义的树。</p>
<h4 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h4><ul>
<li><code>vector/链表</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector 方式</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nodes[N + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 x 和 y之间构建一条边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    nodes[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 x 的所有儿子</span></span><br><span class="line"><span class="type">int</span> l = nodes[x].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    nodes[x][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: nodes[x]) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> where;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *head[N + <span class="number">1</span>], a[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>], l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    a[++i].where = y;</span><br><span class="line">    a[l].next = head[x];</span><br><span class="line">    head[x] = &amp;a[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 x 的所有儿子</span></span><br><span class="line"><span class="keyword">for</span> (Node* p = head[x]; p; p-&gt;next) &#123;</span><br><span class="line">    p-&gt;where;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="有根树遍历"><a href="#有根树遍历" class="headerlink" title="有根树遍历"></a>有根树遍历</h4><p>遍历一棵树一般有 DFS 和 BFS 两种方式。<br><strong>DFS</strong>：深度优先搜索，从一个节点开始，选择一条路径并走到底，并通过回溯来访问所有节点。<br><strong>BFS</strong>：广度优先搜索，也称层级顺序探索，从一个节点开始，遍历该节点的所有子节点，或称按照深度从小到大的顺序依次遍历所有点。<br><img src="./Tree/RootTreeDFS.png" width=350px height=auto></p>
<ul>
<li><strong>有根树的DFS序</strong><br>有根树的 DFS 序是指，从根节点开始的深度优先搜索过程中，依次记录的点所生成的序列。<br>对于上图，所生成的 DFS 序即为 <code>ABCDEFGHIJKLMN</code>。当然这个只是其中一种 DFS 序，因为 <code>A</code> 可以走向 <code>B</code>，也可以走向 <code>E</code>，当然也可以走向 <code>F</code>。不同的走向会有不同的 DFS 序。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; dfn;      <span class="comment">// 用于存储 DFS 序, 常用 DFN 表示 DFS 序</span></span><br><span class="line">                      <span class="comment">// dfn 中的元素即为 DFS 序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="comment">// for x的所有儿子y &#123; dfs(y); &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (Node* p = x; p; p-&gt;next)&#123; <span class="built_in">dfs</span>(p-&gt;next) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(root);</span><br></pre></td></tr></table></figure></li>
<li><strong>有根树的BFS序</strong><br>有根树的 BFS 序是指，从根节点开始的广度优先搜索过程中，依次记录的点所生成的序列。<br>对于上图，所生成的 BFS 序即为 <code>ABENCDFMGJHIKL</code>。当然这个只是其中一种 BFS 序，因为同一深度可能会有不同的遍历顺序，如深度为 $2$ 时，<code>BEN</code>、<code>BNE</code>、<code>EBN</code>、…都是可能出现的顺序，不同的顺序会有不同的 BFS 序。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 root 加入队列 q;</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历队列 q</span></span><br><span class="line">    <span class="keyword">while</span>(队列 q 非空) &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>();    <span class="comment">// 取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();        <span class="comment">// x 出队</span></span><br><span class="line">        <span class="keyword">for</span> x的所有儿子y &#123;</span><br><span class="line">            y 入队;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="无根树-Unrooted-Tree"><a href="#无根树-Unrooted-Tree" class="headerlink" title="无根树(Unrooted Tree)"></a>无根树(Unrooted Tree)</h3><p>无根树即没有固定根结点的树，树中的节点只有相邻关系而没有父子关系。无根树有几种等价的形式化定义（建议搭配图论一起学习）：</p>
<ul>
<li>有 $n$ 个结点， $n−1$ 条边的连通无向图</li>
<li>无向无环的连通图</li>
<li>任意两个结点之间有且仅有一条简单路径的无向图</li>
<li>任何边均为桥的连通图</li>
<li>没有圈，且在任意不同两点间添加一条边之后所得图含唯一的一个圈的图</li>
</ul>
<p>如下图所示，即一棵无根树：<br><img src="./Tree/UnrootTree.png" width=350px height=auto><br>无根树中的任意一个节点可以被指定为根，变成一棵有根树。</p>
<h4 id="无根树的遍历"><a href="#无根树的遍历" class="headerlink" title="无根树的遍历"></a>无根树的遍历</h4><p>遍历一棵无根树一般也有 DFS 和 BFS 两种方式。<br>遍历无根树时，可以从任意一个节点开始，以类似有根树的方式，遍历整棵树。唯一的区别是在进入一个新节点时，需要记录这个节点的来源节点，在遍历新节点的相邻节点时，避免重复访问来源节点即可。</p>
<ul>
<li><strong>无根树的 DFS</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> x的所有响铃节点y &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">-1</span>, x);</span><br></pre></td></tr></table></figure></li>
<li><strong>无根树的 BFS</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 x 加入队列 q，x 的来源为空</span></span><br><span class="line">    <span class="keyword">while</span> (队列 q 非空) &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>();</span><br><span class="line">        from = x的来源节点;</span><br><span class="line">        q.pop;</span><br><span class="line">        <span class="keyword">for</span> x的所有相邻节点 y &#123;</span><br><span class="line">            <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">                y 入队;</span><br><span class="line">                记录 y 的来源节点为 x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(x);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><ul>
<li>树的直径是指树上任意两个节点之间最长（路径的长度一般指的是路径经过的边的数量）的路径。</li>
<li>一棵树可以存在很多条直径，他们的长度相等。</li>
<li>树的直径的中间节点被称为树的中心（图中C节点），如果直径上有偶数个节点，那么中间的两个节点都可以是树的中心。</li>
<li>树的中心到其它点的最长路径最短。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-07T12:06:30.000Z" title="2024/5/7 20:06:30">2024-05-07</time>发表</span><span class="level-item"><time dateTime="2024-05-22T12:07:12.232Z" title="2024/5/22 20:07:12">2024-05-22</time>更新</span><span class="level-item">10 分钟读完 (大约1450个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/07/Heap/">Heap</a></p><div class="content"><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>[TOC]</p>
<h3 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h3><h4 id="二叉堆的基本概念和基本性质"><a href="#二叉堆的基本概念和基本性质" class="headerlink" title="二叉堆的基本概念和基本性质"></a>二叉堆的基本概念和基本性质</h4><p>堆是一种树形结构，有二叉树就有二叉堆。</p>
<ul>
<li>二叉堆总是一棵完全二叉树</li>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>根节点的值为整个堆中的最小&#x2F;最大值。<ul>
<li>父节点中的值<strong>大于等于</strong>两个子节点中的值，根节点的值最大的堆称为<strong>大根堆</strong>。</li>
<li>父节点中的值<strong>小于等于</strong>两个子节点中的值，根节点的值最小的堆称为<strong>小根堆</strong>。</li>
</ul>
</li>
<li>我们可以在堆中插入和删除元素，然后通过调整元素的位置来维护堆的性质。</li>
</ul>
<h4 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h4><ul>
<li>堆的初始化<br>在建立堆之前，需要初始化一些东西：<ul>
<li>一个空数组，用于存储堆中的元素</li>
<li>一个记录堆中元素个数的变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heap[MAXSIZE + <span class="number">1</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>堆中元素的插入<br>堆在插入时，需要首先将插入元素放在数组末尾，然后插入元素不断的和其父节点比较，直到位置合适。下面是对小根堆插入过程的模拟：<br><img src="/./Heap/HeapInsert.png"><br>小根堆插入的代码如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; heap[k] &lt; heap[k/<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[k/<span class="number">2</span>]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
大根堆和小根堆插入元素的方式基本相同，只需要改变大于&#x2F;小于符号，插入操作的时间复杂度为 $O(log;n)$</li>
<li>堆顶元素的删除<br>堆最常用的功能就是<strong>维护最小&#x2F;最大值</strong>。在使用小根堆时，我们经常会求得最小的数字，然后让它出堆，这时就要从堆中删除堆顶数据。<br>这时除了堆顶为空，它的左子树堆和右子树堆仍满堆结构。为了操作简单，一般选择<strong>将堆尾部元素放到堆顶，然后将其逐步下移的方式</strong>，下移时，如进行交换操作，交换的是该节点左右儿子中较小的一个与该节点。<br>下图模拟小根堆删除堆顶元素的操作：<br><img src="/./Heap/HeapDelete.png"><br>小根堆删除元素的代码如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">        <span class="type">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k*<span class="number">2</span>+<span class="number">1</span> &lt; len &amp;&amp; heap[j+<span class="number">1</span>] &lt; heap[j])  j++;</span><br><span class="line">        <span class="keyword">if</span>(heap[k] &lt;= heap[j])  <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆中任意位置的删除<br>删除堆中的任意一个元素时，我们可以发现这个时候这个元素下的左子树堆和右子树堆也满足堆结构，但是我们不可以像删除堆顶节点一样，和数组尾部元素互换，然后尝试下移，原因如下：<br><img src="/./Tree/NormalHeapDelete.drawio.png"><br>此时无需向下调整，因为 $5&lt;8$ 且 $5&lt;9$，依旧满足小根堆的性质，但是其父节点 $6&gt;5$，破坏了小根堆的性质，因此此时需要上移。<br>所以我们删除堆中的任意一个元素，跟数组尾元素互换时，不仅要考虑下移，还有可能会上移。小根堆中删除一个位于数组位置 <code>pos</code> 的元素的代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == len) &#123;</span><br><span class="line">        heap[len] = <span class="number">0</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = heap[pos], y = heap[len];</span><br><span class="line">    <span class="built_in">swap</span>(heap[pos], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">        <span class="comment">// 堆尾的数比原数大, 尝试上移</span></span><br><span class="line">        <span class="built_in">up</span>(pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 堆尾的数比原数小, 尝试下移</span></span><br><span class="line">        <span class="built_in">down</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="STL-中的-priority-queue-优先队列"><a href="#STL-中的-priority-queue-优先队列" class="headerlink" title="STL 中的 priority_queue(优先队列)"></a>STL 中的 priority_queue(优先队列)</h3><p>STL 库中的 <code>priority_queue</code> 是一个很类似于堆的结构，它包含如下操作：</p>
<ul>
<li><code>empty</code> - 判断是否为空</li>
<li><code>size</code> - 返回队列内元素个数</li>
<li><code>top</code> - 访问队首元素</li>
<li><code>push</code> - 往队列中插入一个元素</li>
<li><code>pop</code> - 弹出队首元素</li>
</ul>
<p>这里的 <code>priority_queue</code> 相当于堆，队首元素相当于堆顶元素。<br>我们可以使用如下语句创建一个小根堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>这段C++语句创建了一个优先队列 <code>q</code>，其中元素类型为 <code>int</code>，底层容器使用 <code>vector&lt;int&gt;</code>，并且使用 <code>greater&lt;int&gt;</code> 作为比较器。在优先队列中，当元素被插入队列时，会根据比较器的规则进行排序，从而实现堆的性质。</p>
<p>在这段语句中，<code>greater&lt;int&gt;</code> 是一个函数对象，代表使用“大于”运算符进行比较。因此，当要创建一个小根堆时，即希望队列中的元素按照从小到大的顺序排列，可以利用 greater<int> 作为比较器，这样队列中的最小元素将位于队首。<br>同样的，我们可以使用如下语句创建一个大根堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法 1：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 写法 2：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code> 创建一个小根堆后，可以按以下方式操作这个小根堆：</p>
<ul>
<li>插入元素：使用 push() 方法将元素插入小根堆。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(<span class="number">5</span>); <span class="comment">// 插入元素5</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 插入元素3</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">7</span>); <span class="comment">// 插入元素7</span></span><br></pre></td></tr></table></figure></li>
<li>获取堆顶元素：使用 top() 方法获取小根堆的头部元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> topElement = q.<span class="built_in">top</span>(); <span class="comment">// 获取小根堆的头部元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Top element of the min heap: &quot;</span> &lt;&lt; topElement &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li>删除堆顶元素：使用 pop() 方法删除小根堆顶部的元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 删除小根堆的头部元素</span></span><br></pre></td></tr></table></figure></li>
<li>查看堆是否为空：使用 empty() 方法检查小根堆是否为空。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min heap is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min heap is not empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarMyself.jpg" alt="NilEra"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">NilEra</p><p class="is-size-6 is-block">C/C++ Developer!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jinan Shandong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">25</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/NilEra-K" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/NilEra-K" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://nano.chemtian.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Thymol Blue</span></span><span class="level-right"><span class="level-item tag">nano.chemtian.top</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CppDev/"><span class="level-start"><span class="level-item">CppDev</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/QT6/"><span class="level-start"><span class="level-item">QT6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="level-start"><span class="level-item">软件源</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">大数据技术</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/"><span class="level-start"><span class="level-item">ECharts</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/"><span class="level-start"><span class="level-item">HBase</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Axure-RP-9/"><span class="level-start"><span class="level-item">Axure RP 9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构/算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/"><span class="level-start"><span class="level-item">哈希(Hash)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/"><span class="level-start"><span class="level-item">栈(Stack)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/"><span class="level-start"><span class="level-item">树(Tree)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"><span class="level-start"><span class="level-item">PyTorch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/"><span class="level-start"><span class="level-item">闲聊</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/%E8%AE%A1%E5%88%92/"><span class="level-start"><span class="level-item">计划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-12T07:13:57.000Z">2024-06-12</time></p><p class="title"><a href="/2024/06/12/SparkQuickIN/">SparkQuickIN</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/">Spark</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-11T08:03:22.000Z">2024-06-11</time></p><p class="title"><a href="/2024/06/11/OnlineTravelBigdataPlatform/">OnlineTravelBigdataPlatform</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-10T09:32:28.000Z">2024-06-10</time></p><p class="title"><a href="/2024/06/10/ScalaQuickIN/">ScalaQuickIN</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-02T14:43:53.000Z">2024-06-02</time></p><p class="title"><a href="/2024/06/02/QuickPassHBase/">QuickPassHBase</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/">HBase</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-27T10:18:43.000Z">2024-05-27</time></p><p class="title"><a href="/2024/05/27/Evaluation-Indicators-in-AI/">Evaluation Indicators in AI</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Axure-RP-9/"><span class="tag">Axure RP 9</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CppDev/"><span class="tag">CppDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECharts/"><span class="tag">ECharts</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kaggle/"><span class="tag">Kaggle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QT6/"><span class="tag">QT6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tomcat/"><span class="tag">Tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="tag">大数据技术</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E5%88%92/"><span class="tag">计划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="tag">软件源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%B2%E8%81%8A/"><span class="tag">闲聊</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE/"><span class="tag">项目</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a><p class="is-size-7"><span>&copy; 2024 NilEra</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024 前方⚡高能</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdnjs.loli.net/ajax/libs/algoliasearch/4.0.3/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdnjs.loli.net/ajax/libs/instantsearch.js/4.3.1/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"2TB5ZZYPCO","apiKey":"00a43f1d62ca7b24c8b78d5f0223c065","indexName":"dev_nilera_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>