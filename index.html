<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>Hello, NilEra :-)</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hello, NilEra :-)"><meta name="msapplication-TileImage" content="/img/StarLogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hello, NilEra :-)"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="努力做自己喜欢的事"><meta property="og:type" content="blog"><meta property="og:title" content="Hello, NilEra :-)"><meta property="og:url" content="https://hello-nilera.com/"><meta property="og:site_name" content="Hello, NilEra :-)"><meta property="og:description" content="努力做自己喜欢的事"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hello-nilera.com/img/og_image.png"><meta property="article:author" content="NilEra"><meta property="article:tag" content="Hello NilEra"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hello-nilera.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hello-nilera.com"},"headline":"Hello, NilEra :-)","image":["https://hello-nilera.com/img/og_image.png"],"author":{"@type":"Person","name":"NilEra"},"publisher":{"@type":"Organization","name":"Hello, NilEra :-)","logo":{"@type":"ImageObject","url":"https://hello-nilera.com/img/StarLogo.svg"}},"description":"努力做自己喜欢的事"}</script><link rel="icon" href="/img/StarLogo.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?249654dcf9a3bf70708fdfc6e2b1ec2b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="F6BD78C6BD0096D2218CF88334111125"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/me">我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-12T07:13:57.000Z" title="2024/6/12 15:13:57">2024-06-12</time>发表</span><span class="level-item"><time dateTime="2024-06-12T07:15:24.640Z" title="2024/6/12 15:15:24">2024-06-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/">Spark</a></span><span class="level-item">几秒读完 (大约8个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/12/SparkQuickIN/">SparkQuickIN</a></p><div class="content"><h2 id="快速入门-Spark"><a href="#快速入门-Spark" class="headerlink" title="快速入门 Spark"></a>快速入门 Spark</h2><p>[TOC]</p>
<h3 id="SparkRDD"><a href="#SparkRDD" class="headerlink" title="SparkRDD"></a>SparkRDD</h3><h3 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-11T08:03:22.000Z" title="2024/6/11 16:03:22">2024-06-11</time>发表</span><span class="level-item"><time dateTime="2024-06-12T05:58:15.906Z" title="2024/6/12 13:58:15">2024-06-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/">项目</a></span><span class="level-item">16 分钟读完 (大约2372个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/11/OnlineTravelBigdataPlatform/">OnlineTravelBigdataPlatform</a></p><div class="content"><h2 id="🌳-在线旅游大数据平台项目"><a href="#🌳-在线旅游大数据平台项目" class="headerlink" title="🌳 在线旅游大数据平台项目"></a>🌳 在线旅游大数据平台项目</h2><p>
    <label for="file">完成度：</label>
    <progress max="100" value="12.5"> 12.5% </progress>
</p>
**日期任务清单**

<ul>
<li><input checked="" disabled="" type="checkbox"> 项目开始日期: 2024-06-11<ul>
<li><input checked="" disabled="" type="checkbox"> 了解项目的背景以及整个系统的架构</li>
<li><input checked="" disabled="" type="checkbox"> 了解系统需要完成的主要功能</li>
<li><input checked="" disabled="" type="checkbox"> 了解系统整个架构</li>
<li><input checked="" disabled="" type="checkbox"> 完成数据服务端的部署</li>
<li><input checked="" disabled="" type="checkbox"> 完成数据客户端的部署</li>
<li><input checked="" disabled="" type="checkbox"> 了解数据集</li>
<li><input checked="" disabled="" type="checkbox"> 认识消息队列 Kafka</li>
<li><input checked="" disabled="" type="checkbox"> 完成消息队列 Kafka 的部署</li>
<li><input checked="" disabled="" type="checkbox"> 了解消息队列 Kafka 的基本应用</li>
<li><input checked="" disabled="" type="checkbox"> 使用 Flume 收集数据到 Kafka</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 2024-06-12 暂时未开始</li>
<li><input disabled="" type="checkbox"> 2024-06-13 暂时未开始</li>
<li><input disabled="" type="checkbox"> 2024-06-14 暂时未开始</li>
<li><input disabled="" type="checkbox"> 2024-06-17 暂时未开始</li>
<li><input disabled="" type="checkbox"> 2024-06-18 暂时未开始</li>
</ul>
<p><strong>文件目录</strong></p>
<p>[TOC]</p>
<more>

<h3 id="📕-1-项目概述"><a href="#📕-1-项目概述" class="headerlink" title="📕 1. 项目概述"></a>📕 1. 项目概述</h3><h4 id="1-1-项目背景"><a href="#1-1-项目背景" class="headerlink" title="1.1 项目背景"></a>1.1 项目背景</h4><p>随着信息技术的飞速发展，旅游行业正迅速融入数字化转型的浪潮中。旅游大数据的产生和积累为行业提供了前所未有的洞察力。然而，传统的数据处理方法往往难以应对数据的海量性和实时性需求。</p>
<h4 id="1-2-项目介绍"><a href="#1-2-项目介绍" class="headerlink" title="1.2 项目介绍"></a>1.2 项目介绍</h4><p>本项目旨在构建一个旅游大数据实时分析和监控系统，系统主要包括旅游数据分析和实时监控两大模块，旅游数据分析模块是基于Spark Streaming对济南各景点的人流量数据进行实时处理和分析，实时监控模块是基于SpringBoot对分析的结果进行可视化展示。 </p>
<h3 id="🚧-2-系统功能及架构"><a href="#🚧-2-系统功能及架构" class="headerlink" title="🚧 2. 系统功能及架构"></a>🚧 2. 系统功能及架构</h3><h4 id="2-1-系统主要功能"><a href="#2-1-系统主要功能" class="headerlink" title="2.1 系统主要功能"></a>2.1 系统主要功能</h4><ul>
<li>数据实时收集：通过 <em><strong>Flume</strong></em> 实时采集手机移动信令数据（数据生成器生成的模拟数据），发送到 <strong>Kafka</strong>。</li>
<li>数据实时处理分析：通过<em><strong>Spark Streaming</strong></em> 消费 <em><strong>Kafka</strong></em> 数据，主要完成以下分析：<ul>
<li>各景点人流量实时统计（热力图，每秒钟）</li>
<li>各景点人流量随时间增长情况&#x2F;各景点人流量随时间变化趋势(每分钟)</li>
<li>实时监控：通过 <code>SpringBoot</code> + <code>MyBatis</code> 构建旅游监控系统，基于高德地图完成每秒钟人流量热力图展示，基于 <code>Echarts</code> 完成每分钟流量柱状图和每分钟人流量变化折线图。</li>
</ul>
</li>
</ul>
<h4 id="2-2-系统结构与技术选型"><a href="#2-2-系统结构与技术选型" class="headerlink" title="2.2 系统结构与技术选型"></a>2.2 系统结构与技术选型</h4><img src="https://img-blog.csdnimg.cn/direct/0b6829b9886840a382e4d6e5a18d366b.png#pic_center" alt="SystemStructure" style="zoom: 50%;" />

<ul>
<li><p><strong>项目开发工具：</strong><code>IntelliJ IDEA 2019</code></p>
</li>
<li><p><strong>数据收集分析</strong>：<code>Flume</code> + <code>Kafka</code> + <code>SparkStreaming</code> + <code>MySQL/Redis</code></p>
</li>
<li><p><strong>数据展示：</strong><code>SpringBoot</code> + <code>MyBatis</code> + <code>WebSocket</code> + <code>MySQL</code> + <code>LayUI</code> + <code>Echarts</code> + <code>高德地图API</code></p>
</li>
</ul>
<h3 id="🔧-3-项目收集功能"><a href="#🔧-3-项目收集功能" class="headerlink" title="🔧 3.项目收集功能"></a>🔧 3.项目收集功能</h3><h4 id="3-1-数据服务端与数据客户端部署"><a href="#3-1-数据服务端与数据客户端部署" class="headerlink" title="3.1 数据服务端与数据客户端部署"></a>3.1 数据服务端与数据客户端部署</h4><p>我的主机信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.26.110      bigdata</span><br><span class="line">192.168.26.111      webserver01</span><br><span class="line">192.168.26.111      webserver02</span><br></pre></td></tr></table></figure>

<h5 id="3-1-1-数据服务端部署"><a href="#3-1-1-数据服务端部署" class="headerlink" title="3.1.1 数据服务端部署"></a>3.1.1 数据服务端部署</h5><ol>
<li><p>将 <code>logweb-1.0.jar</code> 上传到服务器<code>webserver01</code> 以及 <code>webserver02</code>。</p>
</li>
<li><p>启动运行 <code>logweb</code> 程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -jar logweb-1.0.jar &amp;</span><br></pre></td></tr></table></figure>

<p>运行成功后，查询日志文件结果，结果如下表示正常启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::               (v2.7.10)</span><br><span class="line"></span><br><span class="line">2024-06-11 12:10:18.084  INFO 1288 --- [           main] c.s.i.w.s.web.logweb.LogwebApplication   : Starting LogwebApplication v1.0 using Java 1.8.0_231 on webserver01 with PID 1288 (/home/subowen/serverJar/logweb-1.0.jar started by subowen in /home/subowen/serverJar)</span><br><span class="line">2024-06-11 12:10:18.090  INFO 1288 --- [           main] c.s.i.w.s.web.logweb.LogwebApplication   : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2024-06-11 12:10:20.604  INFO 1288 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9527 (http)</span><br><span class="line">2024-06-11 12:10:20.666  INFO 1288 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2024-06-11 12:10:20.666  INFO 1288 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.73]</span><br><span class="line">2024-06-11 12:10:21.301  INFO 1288 --- [           main] o.a.c.c.C.[.[localhost].[/logweb]        : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2024-06-11 12:10:21.301  INFO 1288 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3094 ms</span><br><span class="line">2024-06-11 12:10:23.099  INFO 1288 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 9527 (http) with context path &#x27;/logweb&#x27;</span><br><span class="line">2024-06-11 12:10:23.116  INFO 1288 --- [           main] c.s.i.w.s.web.logweb.LogwebApplication   : Started LogwebApplication in 6.507 seconds (JVM running for 8.07)</span><br><span class="line">2024-06-11 12:14:14.608  INFO 1288 --- [nio-9527-exec-1] o.a.c.c.C.[.[localhost].[/logweb]        : Initializing Spring DispatcherServlet &#x27;dispatcherServlet&#x27;</span><br><span class="line">2024-06-11 12:14:14.608  INFO 1288 --- [nio-9527-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#x27;dispatcherServlet&#x27;</span><br><span class="line">2024-06-11 12:14:14.609  INFO 1288 --- [nio-9527-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-1-2-数据客户端部署"><a href="#3-1-2-数据客户端部署" class="headerlink" title="3.1.2 数据客户端部署"></a>3.1.2 数据客户端部署</h5><p>本次数据客户端直接部署在 <strong><code>Windosw</code></strong> 下，使用 <code>IntelliJ IDEA 2019</code> 进行开发。</p>
<p><code>IDEA</code> 数据客户端结构如下：</p>
<img src="https://img-blog.csdnimg.cn/direct/b7a696fb3de3430c843302479bd8f4ff.png#pic_center" alt="LogClientStruct" style="zoom: 80%;" />

<ol>
<li>修改 <code>pom.xml</code> 引入相应的包</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>travel_subowen423<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.inspur.szy.subowen.travel<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置 Spark 的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spark.version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">spark.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">httpclient.version</span>&gt;</span>4.5.12<span class="tag">&lt;/<span class="name">httpclient.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;httpclient.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导入 <code>logclient</code> 代码，并且修改相应包名和部分代码</li>
<li>执行 <code>ScenicAPP.java</code> 随机生成数据。</li>
</ol>
<h5 id="3-1-3-数据格式说明"><a href="#3-1-3-数据格式说明" class="headerlink" title="3.1.3 数据格式说明"></a>3.1.3 数据格式说明</h5><table>
<thead>
<tr>
<th align="center">经度</th>
<th align="center">纬度</th>
<th align="center">景点名称</th>
<th align="center">时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">117.024489</td>
<td align="center">36.669213</td>
<td align="center">曲水亭街</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.016089</td>
<td align="center">36.661138</td>
<td align="center">趵突泉</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">116.813744</td>
<td align="center">36.541549</td>
<td align="center">济南国际园博园</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.022959</td>
<td align="center">36.668068</td>
<td align="center">芙蓉街</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.034920</td>
<td align="center">36.641749</td>
<td align="center">千佛山</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.023837</td>
<td align="center">36.674997</td>
<td align="center">大明湖</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.023837</td>
<td align="center">36.674997</td>
<td align="center">大明湖</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.024489</td>
<td align="center">36.669213</td>
<td align="center">曲水亭街</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.016089</td>
<td align="center">36.661138</td>
<td align="center">趵突泉</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">117.021483</td>
<td align="center">36.661473</td>
<td align="center">济南泉城广场</td>
<td align="center">20240611155103</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<h4 id="3-2-Kafka-消息队列"><a href="#3-2-Kafka-消息队列" class="headerlink" title="3.2 Kafka 消息队列"></a>3.2 Kafka 消息队列</h4><h5 id="3-2-1-Kafka-简介"><a href="#3-2-1-Kafka-简介" class="headerlink" title="3.2.1 Kafka 简介"></a>3.2.1 Kafka 简介</h5><p>点击访问：<a target="_blank" rel="noopener" href="https://kafka.apache.org/">Kafka官网</a></p>
<p><em><strong>Apache Kafka</strong></em> 是一个开源分布式**事件(Event)**流平台，已被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用程序。</p>
<p>本项目主要使用<strong>发布</strong>（写入）和<strong>订阅</strong>（读取）事件流，包括从其他系统持续导入&#x2F;导出数据；根据需要持久可靠地<strong>存储</strong>事件流；在事件发生时或回顾性地<strong>处理</strong>事件流。</p>
<h5 id="3-2-2-Kafka-中的核心概念"><a href="#3-2-2-Kafka-中的核心概念" class="headerlink" title="3.2.2 Kafka 中的核心概念"></a>3.2.2 Kafka 中的核心概念</h5><table>
<thead>
<tr>
<th align="left">名词</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Broker</code></td>
<td align="left"><em><strong>Kafka</strong></em> 集群包含一个或多个服务器，这些服务器称为 <code>Broker</code></td>
</tr>
<tr>
<td align="left"><code>Producer</code></td>
<td align="left">生产者，负责将数据发送到 <em><strong>Kafka</strong></em></td>
</tr>
<tr>
<td align="left"><code>Consumer</code></td>
<td align="left">消费者，负责从 <em><strong>Kafka</strong></em> 中读取数据</td>
</tr>
<tr>
<td align="left"><code>Consumer Group</code></td>
<td align="left">消费者组，多个消费者组成的组</td>
</tr>
<tr>
<td align="left"><code>Topic</code></td>
<td align="left">主题，每条发布到 <em><strong>Kafka</strong></em> 集群的消息都有一个类别，这个类别称为 <code>Topic</code>，可以理解为文件夹</td>
</tr>
<tr>
<td align="left"><code>Partition</code></td>
<td align="left">分区，每个<code>Topic</code>包含一个或多个<code>Partition</code></td>
</tr>
</tbody></table>
<h5 id="3-2-3-Kafka-部署"><a href="#3-2-3-Kafka-部署" class="headerlink" title="3.2.3 Kafka 部署"></a>3.2.3 Kafka 部署</h5><ul>
<li><p><strong>Kafka</strong> 的部署方式分为：</p>
<ul>
<li>分布式部署（多节点多Broker）</li>
<li>单机部署（单节点单Broker&#x2F;单节点多Broker）</li>
</ul>
</li>
<li><p><strong>Kafka</strong> 是使用 <strong>Scala</strong> 编写的组件，依赖与Scala版本</p>
</li>
<li><p><strong>Kafka</strong> 依赖于 <strong>ZooKeeper</strong>，必须要安装 <strong>ZooKeeper</strong>，再安装 <strong>Kafka</strong></p>
</li>
<li><p>部署 <strong>Kafka</strong> 过程</p>
<ul>
<li>解压 <code>kafka</code> 安装包</li>
<li>配置环境变量</li>
<li>修改配置 <code>config/server.properties</code> 文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 Broker 的 ID, 在同一个集群上, 这个值必须是一个独一无二的整数值</span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置日志文件的路径</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/home/subowen/apps/kafka_2.12-2.8.0/kafka-logs</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-2-4-Kafka-的基本应用"><a href="#3-2-4-Kafka-的基本应用" class="headerlink" title="3.2.4 Kafka 的基本应用"></a>3.2.4 Kafka 的基本应用</h5><ul>
<li><p>启动 <strong>ZooKeeper</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subowen@bigdata ~]$ zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 <code>Kafka</code></p>
<ul>
<li><p>第一次启动：先使用前台启动，如果没有问题再使用后台启动</p>
</li>
<li><p>前台启动命令：<code>kafka-server-start.sh  $KAFKA_HOME/config/server.properties</code></p>
</li>
<li><p>后台启动命令：<code>kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="3-2-5-使用-Flume-收集数据到-Kafka"><a href="#3-2-5-使用-Flume-收集数据到-Kafka" class="headerlink" title="3.2.5 使用 Flume 收集数据到 Kafka"></a>3.2.5 使用 Flume 收集数据到 Kafka</h5><p>在之前的项目中，我学习了 <em><strong>离线类型</strong></em> 项目的 Flume 数据收集，因为本次需要进行在线的实时数据分析，所以按照之前的离线分析方式，使用 Flume 将数据收集到 HDFS 是不适合实时的数据分析环境的。<br>将数据落地到 HDFS 则意味着数据进入磁盘，数据的读写会占用大量的磁盘 I&#x2F;O，不适用于实时场景。<br>因此在实时项目，考虑到数据的实时性，本次实时数据分析项目使用 消息队列（Kafka）进行数据的存放。</p>
<ol>
<li><p>配置 <code>webserver01</code> 和 <code>webserver02</code> 上的 Flume 配置文件 <code>taildir-avro-stream.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a1.sources  = r1</span><br><span class="line">a1.sinks    = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = TAILDIR</span><br><span class="line">a1.sources.r1.positionFile = /home/subowen/apps/apache-flume-1.9.0-bin/position/taildir_position.json</span><br><span class="line">a1.sources.r1.filegroups = f1</span><br><span class="line">a1.sources.r1.filegroups.f1 = /home/subowen/serverJar/logweb/logs/scenic.log</span><br><span class="line">a1.sources.r1.headers.f1.headerKey1 = inspur-szy</span><br><span class="line">a1.sources.r1.fileHeader = true</span><br><span class="line">a1.sources.r1.maxBatchCount = 1000</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = 192.168.26.110</span><br><span class="line">a1.sinks.k1.port = 4545</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line">a1.sources.r1.channels=c1</span><br><span class="line">a1.sinks.k1.channel=c1</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>bigdata</code> 上的 Flume 配置文件 <code>avro-kafka-stream.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 配置 Agent a1各个组件的名称</span><br><span class="line"># Agent a1 的 source有一个, 叫做r1</span><br><span class="line">a1.sources  = r1</span><br><span class="line"># Agent a1 的 sink也有一个, 叫做k1</span><br><span class="line">a1.sinks    = k1</span><br><span class="line"># Agent a1 的 channel有一个, 叫做c1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># 配置 Agent a1的source r1的属性</span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line"># 监听的端口</span><br><span class="line">a1.sources.r1.port = 4545</span><br><span class="line"></span><br><span class="line"># 配置 Agent a1的sink k1的属性</span><br><span class="line">a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">a1.sinks.k1.kafka.topic = subowen</span><br><span class="line">a1.sinks.k1.kafka.bootstrap.servers = bigdata:9092</span><br><span class="line">a1.sinks.k1.kafka.flumeBatchSize = 20</span><br><span class="line">a1.sinks.k1.kafka.producer.acks = 1</span><br><span class="line">a1.sinks.k1.kafka.producer.linger.ms = 1</span><br><span class="line">a1.sinks.k1.kafka.producer.compression.type = snappy</span><br><span class="line"></span><br><span class="line"># 配置 Agent a1 的 channel c1 的属性, channel是用来缓冲Event数据的</span><br><span class="line"># channel 的类型是内存 channel, 顾名思义这个 channel 是使用内存来缓冲数据</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 内存channel的容量大小是1000, 注意这个容量不是越大越好, 配置越大, 一旦Flume 挂掉丢失的 event 也就越多</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># source 和 sink 从内存 channel 每次事务传输的event数量</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># 把source和sink绑定到channel上</span><br><span class="line"># 与source r1绑定的channel有一个, 叫做c1</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"># 与sink k1绑定的channel有一个, 叫做c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></li>
<li><p>启动 <code>webserver01</code> 和 <code>webserver02</code> 的 Flume，这里为了简化操作，只启动一台机器上的 Flume</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subowen@webserver01 config]$ ./start-flume.sh taildir-avro-stream.conf a1</span><br></pre></td></tr></table></figure></li>
<li><p>启动 <code>bigdata</code> 上的 Flume</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subowen@bigdata config]$ ./start-flume.sh avro-kafka-stream.conf a1</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>bigdata</code> 上启动 **<code>kafka-console-consumer</code>**，使用消费者Shell进行测试消费，后期会更换为 <em><strong><code>SparkStreaming</code></strong></em> 进行消费。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subowen@bigdata ~]$ kafka-console-consumer.sh --topic subowen --bootstrap-server bigdata:9092</span><br></pre></td></tr></table></figure></li>
<li><p>在 Windows 下运行客户端，模拟数据的产生，执行<code>ScenicAPP</code>代码，模拟数据的生成过程。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.inspur.szy.subowen.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.inspur.szy.subowen.data.producer.DataProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScenicApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://192.168.26.111:9527/logweb/upload&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        DataProducer.producer(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-4-数据实时分析"><a href="#📈-4-数据实时分析" class="headerlink" title="📈 4. 数据实时分析"></a>📈 4. 数据实时分析</h3><h4 id="4-1-SparkStreaming-概述"><a href="#4-1-SparkStreaming-概述" class="headerlink" title="4.1 SparkStreaming 概述"></a>4.1 <code>SparkStreaming</code> 概述</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-10T09:32:28.000Z" title="2024/6/10 17:32:28">2024-06-10</time>发表</span><span class="level-item"><time dateTime="2024-06-12T07:13:20.343Z" title="2024/6/12 15:13:20">2024-06-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/">Scala</a></span><span class="level-item">29 分钟读完 (大约4277个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/10/ScalaQuickIN/">ScalaQuickIN</a></p><div class="content"><h2 id="快速入门-Scala"><a href="#快速入门-Scala" class="headerlink" title="快速入门 Scala"></a>快速入门 Scala</h2><p>[TOC]</p>
<h3 id="1-学习目标"><a href="#1-学习目标" class="headerlink" title="1. 学习目标"></a>1. 学习目标</h3><img src="./ScalaQuickIN/SCALA.png" style="zoom:33%;" />

<h3 id="2-Scala-介绍"><a href="#2-Scala-介绍" class="headerlink" title="2. Scala 介绍"></a>2. Scala 介绍</h3><h4 id="2-1-Scala-简介"><a href="#2-1-Scala-简介" class="headerlink" title="2.1 Scala 简介"></a>2.1 Scala 简介</h4><p>Scala 创始人为 <em>Martin Odersky</em>，<em>马丁·奥德斯基</em>。JDK5 和 JDK8 版本的Java编译器 <code>javac</code> 都是由他和他的团队编写的。</p>
<h4 id="2-2-Scala-的六大特征"><a href="#2-2-Scala-的六大特征" class="headerlink" title="2.2 Scala 的六大特征"></a>2.2 Scala 的六大特征</h4><p>一句话总结：Scala 是一门以 JVM 为运行环境的静态类型编程语言，具备面向对象及函数是编程的特性。下面是官网对Scala特性的介绍：</p>
<p>① <strong>SEAMLESS JAVA INTEROP</strong> 无缝与 JAVA互操作</p>
<p>Java 和 Scala 可以混编，在写 Scala 代码时可以引用 Java 的类。</p>
<p>Scala 运行在 JVM 上，所以 Java 和 Scala 可以自由的混合使用。这也就是在日常编写代码的过程中，经常看到Scala引用了很多Java包的原因。</p>
<p>② <strong>TYPE INFERENCE</strong> 类型推断（自动推测类型）</p>
<p>使类型系统不是那么的死板（静态）。不要为了类型系统工作，而是让类型系统为你工作。</p>
<p>Scala是一种弱类型语言，即它在编写代码时，不需要像强类型语言（如 Java、C++等）定义变量的类别。</p>
<p>Scala有<code>Int</code>、<code>Long</code>、<code>Short</code>、<code>Byte</code>、<code>Float</code>、<code>Double</code>、<code>Char</code>、<code>Boolean</code>这些基础数据类型。但与 Java 不同，在定义变量时，Scala用 <code>var/val</code> 来定义，让其自主判断数据类型。 </p>
<p>其中<code>val</code>是常量，<code>var</code>是变量，一般来说，用<code>val</code>比较多（涉及资源的利用）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中定义一个变量</span></span><br><span class="line"><span class="type">String</span> name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scala 中定义一个变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>③ <strong>CONCURRENCY &amp; DISTRIBUTION</strong> 并发和分布式（Actor）</p>
<p>Scala 在操作集合时使用了数据并行操作。并且使用Actor（Actor是一种不共享数据，依赖于消息传递的并发编程模式， 有效的避免了死锁、资源争夺等情况）来解决并发和分布式中的一些问题。或者使用 <code>futures</code> 类进行异步编程。</p>
<p>使用 Scala 进行并发以及分布式场景下的开发时有得天独厚的优势。</p>
<p>④ <strong>TRAITS</strong> 特性</p>
<p>将 <strong>Java 风格接口的灵活性</strong>与<strong>类的强大功能</strong>相结合。认为是一种多重继承。</p>
<p>其实这就相当于 Java 的接口，但实际上它比接口还功能强大。 与接口不同的是，它还可以定义属性和方法的实现。</p>
<p>简单来说：<em><strong>TRAITS &#x3D; Interface + Abstract</strong></em>。</p>
<p>⑤ <strong>PATTERN MATCHING</strong> 模式匹配</p>
<p>更强大的 <code>Switch</code>，它可以匹配类的层级结构、序列以及更多。</p>
<p>⑥ <strong>HIGHER-ORDER FUNCTIONS</strong> 高阶函数</p>
<p>函数是一级对象。在保证类型安全的情况下编写它们。在任何地方使用它们，传递给任何东西，即函数可以作为参数传递到函数中。</p>
<h4 id="2-3-具体应用"><a href="#2-3-具体应用" class="headerlink" title="2.3 具体应用"></a>2.3 具体应用</h4><ul>
<li>Kafka：分布式消息队列，内部代码经常用来处理并发的问题，用 Scala 可以大大简化其代码。</li>
<li>Spark：方便处理多线程场景，另外Spark主要用作内存计算，经常要用来实现复杂的算法，利用Scala这种函数式编程语言可以大大简化代码。</li>
</ul>
<h3 id="3-Scala-的安装和使用"><a href="#3-Scala-的安装和使用" class="headerlink" title="3. Scala 的安装和使用"></a>3. Scala 的安装和使用</h3><h4 id="3-1-Windows-下安装-Scala"><a href="#3-1-Windows-下安装-Scala" class="headerlink" title="3.1 Windows 下安装 Scala"></a>3.1 Windows 下安装 Scala</h4><p>Scala下载地址：<a target="_blank" rel="noopener" href="https://www.scala-lang.org/">The Scala Programming Language (scala-lang.org)</a></p>
<p>① 进入下载地址后，选择合适的Scala版本进行安装。记住安装的路径，方便配置环境变量。</p>
<p>② 配置环境变量 <code>SCALA_HOME</code></p>
<p>③ 验证是否安装成功：进入命令行<code>CMD</code>，输入 <code>scala -version</code>，显示版本号及表明配置成功。</p>
<h4 id="3-2-IDEA-2022-中配置-Scala-插件"><a href="#3-2-IDEA-2022-中配置-Scala-插件" class="headerlink" title="3.2 IDEA 2022 中配置 Scala 插件"></a>3.2 IDEA 2022 中配置 Scala 插件</h4><p>① 进入IDEA，Files→Settings→Plugins</p>
<p>② 进入Marketolace界面，直接搜索<code>Scala</code>，安装即可。</p>
<p>③ 在编写 Scala 代码时，双击 <code>Shift</code>，选择 <code>Add Framework</code> 后，添加 Scala 框架，即可编写 Scala 代码。</p>
<h3 id="4-Scala-基础"><a href="#4-Scala-基础" class="headerlink" title="4. Scala 基础"></a>4. Scala 基础</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Byte</code></td>
<td>8-bit 的有符号数字，范围在 -128 ~ 127</td>
</tr>
<tr>
<td><code>Short</code></td>
<td>16-bit 的有符号数字，范围在 -32768 ~ 32767</td>
</tr>
<tr>
<td><code>Int</code></td>
<td>32-bit 的有符号数字，范围在 -2147483648 ~ 2147483647</td>
</tr>
<tr>
<td><code>Long</code></td>
<td>64-bit 的有符号数字，范围在 -9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td><code>Float</code></td>
<td>32-bit IEEE 754 单精度浮点数</td>
</tr>
<tr>
<td><code>Double</code></td>
<td>64-bit IEEE 754 双精度浮点数</td>
</tr>
<tr>
<td><code>Char</code></td>
<td>16-bit Unicode 字符，范围 U+0000 ~ U+FFFF</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔类型</td>
</tr>
<tr>
<td><code>Unit</code></td>
<td>表示空值，与其他语言中的 <code>void</code> 相同</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>空值或者空引用</td>
</tr>
<tr>
<td><code>Nothing</code></td>
<td>所有其他类型的子类型，表示没有值</td>
</tr>
<tr>
<td><code>Any</code></td>
<td>所有类型的超类，任何类型都属于<code>Any</code></td>
</tr>
<tr>
<td><code>AnyRef</code></td>
<td>所有引用类型的超类</td>
</tr>
<tr>
<td><code>AnyVal</code></td>
<td>所有值类型的超类</td>
</tr>
<tr>
<td><code>Nil</code></td>
<td>表示长度为0的List</td>
</tr>
</tbody></table>
<p>比较特殊的 <code>None</code>，是<code>Option</code>的两个子类之一，另一个是<code>Some</code>，用于安全的函数返回值。</p>
<p>Scala 推荐在可能返回空的方法使用 <code>Option[X]</code> 作为返回类型。如果有值就返回 <code>Some[X]</code>，否则返回 <code>None</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(key: <span class="type">A</span>): option[<span class="type">B</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (contains(key))</span><br><span class="line">    	<span class="type">Some</span>(getValue(key))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="type">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-变量和常量的声明"><a href="#4-2-变量和常量的声明" class="headerlink" title="4.2 变量和常量的声明"></a>4.2 变量和常量的声明</h4><ul>
<li><p>变量用 <code>var</code> 定义，可修改</p>
</li>
<li><p>常量用 <code>val</code> 定义，不可修改</p>
</li>
<li><p>定义变量或常量的时候，也可以写上返回值的类型，一般省略，如 <code>val a: Int = 10</code></p>
</li>
<li><p>常量不可以再赋值</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">println(name)		<span class="comment">// zhangsan</span></span><br><span class="line">name = <span class="string">&quot;lisi&quot;</span></span><br><span class="line">println(name)		<span class="comment">// lisi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> gender = <span class="string">&quot;m&quot;</span></span><br><span class="line">gender = <span class="string">&quot;m&quot;</span>		<span class="comment">// [Error] 不可以给常量赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-键盘标准输入"><a href="#4-3-键盘标准输入" class="headerlink" title="4.3 键盘标准输入"></a>4.3 键盘标准输入</h4><p>编程中可以通过键盘输入语句来接收用户输入的数据（也就是 Java 中的 Scanner 对象）。<br>在 Scala 中只需要导入对应的包，比 Java 还要简单，不需要实例化对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Please Input Your Name: &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> name = <span class="type">StdIn</span>.readLine()</span><br><span class="line">        println(<span class="string">&quot;Please Input Your Age: &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">        printf(<span class="string">&quot;Your Name is %s, Your Age is %d&quot;</span>, name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码一样，<code>printf()</code> 的用法和 Java 中一样，为格式化输出。注意使用规范即可。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>%d</code></td>
<td>十进制数字</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数浮点数</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点数</td>
</tr>
</tbody></table>
<h4 id="4-4-类Class-和-对象Object"><a href="#4-4-类Class-和-对象Object" class="headerlink" title="4.4 类Class 和 对象Object"></a>4.4 类<code>Class</code> 和 对象<code>Object</code></h4><ul>
<li>在编写 Scala 代码时，一般不加分号<code>;</code>，如果一行中有多条语句，则可以用分号隔开，如：<code>var a = 10; var b = 20</code>。</li>
<li><code>class</code> 默认实现了 <code>getter/setter</code> 方法。</li>
<li><code>class</code> 中如果有参数传入，那么这个构造器就是这个类的默认构造器。</li>
<li><code>class</code> 在被 <code>new</code> 新建对象的时候，除了方法内部不执行，其他地方的代码都会执行，类似于Java中的工具类。</li>
<li><code>Object</code> 里面不能传递参数，<code>Object</code> 里面的属性和方法都是静态的，类似于 Java 中 <code>static</code> 修饰的东西，类似于 Java 中的工具类。</li>
<li>伴生类和伴生对象，在一个 Scala 文件中，如果 <code>Class</code> 和 <code>Object</code> 的名字一样，则互为伴生类和伴生对象。他们可以互相访问到互相的私有成员变量。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">xname:<span class="type">String</span>, xage: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name  = xname</span><br><span class="line">    <span class="keyword">val</span> age   = xage</span><br><span class="line">    <span class="keyword">var</span> money = <span class="number">100</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写构造器, 必须调用类的默认构造器</span></span><br><span class="line"><span class="comment">     * @param xname</span></span><br><span class="line"><span class="comment">     * @param xage</span></span><br><span class="line"><span class="comment">     * @param xmoney</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(xname: <span class="type">String</span>, xage: <span class="type">Int</span>, xmoney: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>(xname, xage)</span><br><span class="line">        money = xmoney</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Checkpoint&quot;</span>)			<span class="comment">// `class` 在被 `new` 新建对象的时候，除了方法内部不执行，其他地方的代码都会执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Inside Function&quot;</span>)	<span class="comment">// 方法内部不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Checkpoint&quot;</span>)			<span class="comment">// `class` 在被 `new` 新建对象的时候，除了方法内部不执行，其他地方的代码都会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> person1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">        println(person.name + <span class="string">&quot;:&quot;</span> + person.age)		<span class="comment">// 默认实现了 getter/setter 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-IF-ELSE-语句"><a href="#4-5-IF-ELSE-语句" class="headerlink" title="4.5 IF-ELSE 语句"></a>4.5 IF-ELSE 语句</h4><p>Scala 中的条件判断语句同 Java 中的条件判断语句，语法结构基本一致。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;请输入年龄&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;请输入 0 ~ 100 的数字&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-Loop-循环语句"><a href="#4-6-Loop-循环语句" class="headerlink" title="4.6 Loop 循环语句"></a>4.6 Loop 循环语句</h4><ul>
<li><code>to</code> 和 <code>until</code> 语句的区别</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ToUntilDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="number">1</span> to <span class="number">10</span>)		<span class="comment">// to    表示 [1, 10], 输出: Range(1, 2, 3, ..., 10)</span></span><br><span class="line">        println(<span class="number">1</span> until <span class="number">10</span>)		<span class="comment">// until 表示 [1, 10), 输出: Range(1, 2, 3, ...,  9)</span></span><br><span class="line">        println(<span class="number">1</span> to (<span class="number">10</span>, <span class="number">2</span>))	<span class="comment">// 表示按照步长为`2`来输出数据, 输出: Range(1, 3, 5, 7, 9)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for</code> 循环</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">            print(i + &#x27; &#x27;)		<span class="comment">// 输出: 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Scala 中的 `for` 循环可以将 if 语句直接写在 for 循环中</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; <span class="keyword">if</span> i &gt; <span class="number">5</span>; <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d &quot;</span>, i)	<span class="comment">// 输出: 6 8 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上面的写法可以等同于下面的写法</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">5</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双重 for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; j &lt;- <span class="number">1</span> to <span class="number">5</span>) &#123;</span><br><span class="line">            println(i + <span class="string">&quot;:&quot;</span> + j)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上面的写法可以等同于下面的写法</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to <span class="number">5</span>) &#123;</span><br><span class="line">                println(i + <span class="string">&quot;:&quot;</span> + j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Scala 中不能使用类似于 <code>x++</code>、<code>x--</code> 的操作，需要使用 <code>x += 1</code> 或者 <code>x -= 1</code> 来完成自增或者自减操作。</li>
<li><code>for</code> 循环使用 <code>yield</code> 关键字返回一个集合，<code>for &#123; 子句 &#125; yield &#123;变量或表达式&#125;</code>，<code>for</code> 循环中的 <code>yield</code> 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala 中 <code>for</code> 循环是有返回值的。如果被循环的是 <code>Map</code>，返回的就是 <code>Map</code>，被循环的是 <code>List</code>，返回的就是 <code>List</code>，以此类推。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Loop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    	<span class="keyword">val</span> range = <span class="number">1</span> to <span class="number">10</span>;</span><br><span class="line">    	<span class="keyword">for</span> (num &lt;- range <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">if</span> num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      		printf(<span class="string">&quot;%d&quot;</span>, num);	<span class="comment">// 6 8 10 </span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result_1 = <span class="keyword">for</span> (num&lt;-range <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">if</span> num &gt; <span class="number">5</span>)  <span class="keyword">yield</span> num		<span class="comment">// yield 变量</span></span><br><span class="line">    	println(result_1) 		<span class="comment">// Vector(6, 8, 10)</span></span><br><span class="line">        <span class="keyword">val</span> result_2 = <span class="keyword">for</span> (num&lt;-range <span class="keyword">if</span> num &gt; <span class="number">5</span>)  				<span class="keyword">yield</span> num % <span class="number">2</span>	<span class="comment">// yield 表达式</span></span><br><span class="line">    	println(result_2) 		<span class="comment">// Vector(0, 1, 0, 1, 0)</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>while</code> 和 <code>do...while</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Loop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;第&quot;</span> + index + <span class="string">&quot;次循环&quot;</span>)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            println(<span class="string">&quot;第&quot;</span> + index + <span class="string">&quot;次循环&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">while</span>(index &lt; <span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Scala-函数-方法"><a href="#5-Scala-函数-方法" class="headerlink" title="5. Scala 函数(方法)"></a>5. Scala 函数(方法)</h3><h4 id="5-1-函数的定义"><a href="#5-1-函数的定义" class="headerlink" title="5.1 函数的定义"></a>5.1 函数的定义</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数(方法) 的定义</span></span><br><span class="line"><span class="comment">// def 函数名(参数x: 参数类型, 参数y: 参数类型): 返回类型 = &#123;</span></span><br><span class="line"><span class="comment">//     函数体</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span></span>(x: <span class="type">Int</span>, y: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    function_body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>Scala 使用 <code>def</code> 关键字告诉编译器这是一个函数（方法）</li>
<li>我们可以通过在参数列表后面加一个<strong>冒号<code>:</code><strong>和</strong>类型</strong>来显式地指定返回类型。</li>
<li>函数可以写<code>返回类型</code>，也可以不写，会自动推断（最后一行是什么类型，就被推断成什么类型）。有时候不能省略，必须写，比如在<strong>递归函数中</strong>或者<strong>函数的返回值是函数类型</strong>的时候。</li>
<li>Scala 中函数有返回值时，可以写 <code>return</code>，也可以不写 <code>return</code>，不写 <code>return</code> 时会把函数中最后一行当做结果返回。当写 <code>return</code> 时，必须要写函数的<code>返回类型</code>。</li>
<li>传递给方法的参数可以在方法中使用，并且 Scala 规定：方法的传过来的参数为常量 <code>val</code> 而不是变量 <code>var</code> 。</li>
<li>如果去掉函数体前面的等号<code>=</code>，那么这个函数返回类型必定是 <code>Unit</code>。这种说法无论函数体里面什么逻辑都成立，Scala 可以把任意类型转换为 <code>Unit</code>。假设，函数里面的逻辑最后返回了一个 <code>String</code>，那么这个返回值会被转换成 <code>Unit</code>，原本逻辑的值会被丢弃。这种方法往往适用于无返回值的函数中。</li>
</ol>
<h4 id="5-2-递归函数"><a href="#5-2-递归函数" class="headerlink" title="5.2 递归函数"></a>5.2 递归函数</h4><img src="./ScalaQuickIN/ScalaGNUFunction.png" style="zoom: 67%;" />

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归函数:</span></span><br><span class="line"><span class="comment">     * 关键点在于递归的定义, 终止条件(避免无休止的递归, 导致栈溢出问题)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">        num * f1(num<span class="number">-1</span>)		<span class="comment">// f1(5) = 5*f1(4) = 5*4*f1(3) = 5*4*3*f1(2) = 5*4*3*2*f1(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(f1(<span class="number">5</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-包含参数默认值的函数"><a href="#5-3-包含参数默认值的函数" class="headerlink" title="5.3 包含参数默认值的函数"></a>5.3 包含参数默认值的函数</h4><ul>
<li>和其他语言没有任何区别</li>
<li>默认值的函数中，如果传入的参数个数与函数定义相同，则传入的数值会覆盖默认值。</li>
<li>如果不想覆盖默认值，且传入的参数个数小于定义的函数的参数，则需要指定参数名称。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含参数默认值的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(x: <span class="type">Int</span>=<span class="number">5</span>, y: <span class="type">Int</span>=<span class="number">10</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(f2())			<span class="comment">// 输出: 15</span></span><br><span class="line">        println(f2(<span class="number">10</span>, <span class="number">20</span>))		<span class="comment">// 输出: 30</span></span><br><span class="line">        println(f2(<span class="number">10</span>))			<span class="comment">// 输出: 20</span></span><br><span class="line">        println(f2(y=<span class="number">30</span>))		<span class="comment">// 输出: 35</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-可变参数个数的函数"><a href="#5-4-可变参数个数的函数" class="headerlink" title="5.4 可变参数个数的函数"></a>5.4 可变参数个数的函数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可变参数个数的函数</span></span><br><span class="line"><span class="comment">     * 传入多个参数时, 多个参数之间用逗号分隔</span></span><br><span class="line"><span class="comment">     * 传入的参数其实就是不定长数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>(elements: <span class="type">Int</span>*): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (element &lt;- elements) &#123;</span><br><span class="line">            sum += element</span><br><span class="line">        &#125;</span><br><span class="line">        sum</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(f3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))	<span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-匿名函数"><a href="#5-5-匿名函数" class="headerlink" title="5.5 匿名函数"></a>5.5 匿名函数</h4><p>匿名函数有以下几种：</p>
<ul>
<li>有参匿名函数</li>
<li>无参匿名函数</li>
<li>有返回值的匿名函数</li>
</ul>
<p>在定义和使用匿名函数时：</p>
<ul>
<li>可以将匿名函数返回给 <code>val</code> 定义的值</li>
<li>匿名函数不能显示声明函数的返回类型</li>
</ul>
<p>在 Scala 中 ，<strong>大多数情况</strong>下 <code>=&gt;</code> 是匿名函数的显著标志。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匿名函数: 经常和高阶函数一起使用</span></span><br><span class="line"><span class="comment">     * 1. 有参匿名函数</span></span><br><span class="line"><span class="comment">     * 2. 无参匿名函数</span></span><br><span class="line"><span class="comment">     * 3. 有返回值的匿名函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 有参数匿名函数</span></span><br><span class="line">        <span class="keyword">val</span> value1 = (a: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">            println(a)</span><br><span class="line">        &#125;</span><br><span class="line">        value1(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参数匿名函数</span></span><br><span class="line">        <span class="keyword">val</span> value2 = () =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;无参数匿名函数&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        value2()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有返回值的匿名函数</span></span><br><span class="line">        <span class="keyword">val</span> value3 = (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">            a + b</span><br><span class="line">        &#125;</span><br><span class="line">        println(value3(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-嵌套函数"><a href="#5-6-嵌套函数" class="headerlink" title="5.6 嵌套函数"></a>5.6 嵌套函数</h4><p>嵌套函数其实就是函数里套了函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f5</span> </span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="meta">@tailrec</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">                b</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f6(a<span class="number">-1</span>, a*b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f6(num, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        f5(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-7-偏应用函数"><a href="#5-7-偏应用函数" class="headerlink" title="5.7 偏应用函数"></a>5.7 偏应用函数</h4><p>偏应用函数是一种表达式，不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 这里只是一个普通的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, log: <span class="type">String</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Date is &quot;</span> + date + <span class="string">&quot;, Log is &quot;</span> + log)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照普通函数的方法使用</span></span><br><span class="line">        <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()		<span class="comment">// 与 Java 混编</span></span><br><span class="line">        log(date, <span class="string">&quot;log1&quot;</span>)</span><br><span class="line">        log(date, <span class="string">&quot;log2&quot;</span>)</span><br><span class="line">        log(date, <span class="string">&quot;log3&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们发现, 上面的程序除了 log 参数在改变, date 参数没有变化</span></span><br><span class="line">        <span class="comment">// 此时我们可以使用偏应用函数来优化</span></span><br><span class="line">        <span class="comment">// _ 下划线可以理解为一个变化的参数, 而 date 可以理解为一个固定的参数(他本身可能是变化的)</span></span><br><span class="line">        <span class="keyword">val</span> logWithDate = log(date, _:<span class="type">String</span>)</span><br><span class="line">        logWithDate(<span class="string">&quot;log_11&quot;</span>)</span><br><span class="line">        logWithDate(<span class="string">&quot;log_12&quot;</span>)</span><br><span class="line">        logWithDate(<span class="string">&quot;log_13&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-8-高阶函数"><a href="#5-8-高阶函数" class="headerlink" title="5.8 高阶函数"></a>5.8 高阶函数</h4><p><strong>高阶函数：</strong>函数的<code>参数</code>是函数，或者函数的<code>返回类型</code>是函数，或者<strong>函数的<code>参数</code>和函数的<code>返回类型</code>是函数</strong>的函数。</p>
<p>函数的格式为 <code>(A)=&gt;B</code>,  后面没有函数体, 此函数接收类型 <code>A</code> 的参数, 返回类型 <code>B</code> 的函数。</p>
<ul>
<li>函数的<code>参数</code>是函数：其实就是定义一个传入<code>参数</code>和<code>返回类型</code>的<strong>模板参数</strong>，但是这个模板需要从其他地方实现。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的参数是函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f7</span></span>(a: <span class="type">Int</span>, func: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = func(<span class="number">1</span>, <span class="number">2</span>)		<span class="comment">// 这里将函数作为参数传入 f7, 而 result 使用了这个函数</span></span><br><span class="line">    							<span class="comment">// 这里我理解为模板, result 使用了一个 参数为(Int, Int), 返回类型为 Int 的函数模板</span></span><br><span class="line">    							<span class="comment">// 那么这个模板的具体实现是什么, 则需要从其他地方实现</span></span><br><span class="line">    a * result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f8</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;	<span class="comment">// 这里就是对于模板的一种实现</span></span><br><span class="line">	x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(f7(<span class="number">5</span>, f8))				<span class="comment">// 使用这种方式将 f8 传入, 并且打印输出, 结果为: 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然我们也可以结合匿名函数一起实现</span></span><br><span class="line">println(f7(<span class="number">5</span>, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;x + y&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的<code>返回类型</code>是函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的返回类型是函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f9</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): (<span class="type">String</span>, <span class="type">String</span>) =&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f10</span></span>(c: <span class="type">String</span>, d: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        a + <span class="string">&quot; &quot;</span> + b + <span class="string">&quot; &quot;</span> + c + <span class="string">&quot; &quot;</span> + d</span><br><span class="line">    &#125;</span><br><span class="line">    f10		<span class="comment">// 返回一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像这种括号连着括号的`()()`, 往往代表着出现了函数的返回类型是函数的函数</span></span><br><span class="line">println(f9(<span class="number">1</span>, <span class="number">2</span>)(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>)) 	<span class="comment">// 输出: 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的<code>参数</code>和函数的<code>返回类型</code>是函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f11</span></span>(x: <span class="type">Int</span>, f: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(f11(<span class="number">1</span>, (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; &#123; a + b &#125; ) (<span class="number">100</span>, <span class="number">200</span>))	<span class="comment">// 输出: 300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _ 类似于 Java 中的 *. 通配符, 变量只使用一次的时候可以简写如下:</span></span><br><span class="line">println(f11(<span class="number">1</span>, (_ + _))(<span class="number">100</span>, <span class="number">200</span>))							<span class="comment">// 输出: 300</span></span><br></pre></td></tr></table></figure>

<h4 id="5-9-柯里化函数"><a href="#5-9-柯里化函数" class="headerlink" title="5.9 柯里化函数"></a>5.9 柯里化函数</h4><p>柯里化函数，或称<strong>颗粒化函数</strong>，将参数变成颗粒散落简而言之就是将参数不断拆分。柯里化函数基本是在做这么一件事情：只传递给函数一部分参数来调用它，让它<strong>返回一个函数</strong>去处理剩下的参数。如果写成公式文字就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn(a, b, c, d) =&gt; fn(a)(b)(c)(d)</span><br><span class="line">fn(a, b, c, d) =&gt; fn(a)(b, c, d)</span><br><span class="line">fn(a, b, c, d) =&gt; fn(a, b)(c)(d)</span><br><span class="line">fn(a, b, c, d) =&gt; fn(a, b, c)(d)</span><br></pre></td></tr></table></figure>

<p>可以理解为高阶函数的简化，类似于返回类型为函数的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f12</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>, d: <span class="type">Int</span>) = &#123;</span><br><span class="line">    a + b + c + d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数: 可以理解为高阶函数的简化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f13</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>)(c: <span class="type">Int</span>, d: <span class="type">Int</span>) = &#123;</span><br><span class="line">    a + b + c + d    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Scala-字符串"><a href="#6-Scala-字符串" class="headerlink" title="6. Scala 字符串"></a>6. Scala 字符串</h3><h4 id="6-1-String"><a href="#6-1-String" class="headerlink" title="6.1 String"></a>6.1 String</h4><h4 id="6-2-StringBuilder"><a href="#6-2-StringBuilder" class="headerlink" title="6.2 StringBuilder"></a>6.2 StringBuilder</h4><h4 id="6-3-String-的操作方法"><a href="#6-3-String-的操作方法" class="headerlink" title="6.3 String 的操作方法"></a>6.3 String 的操作方法</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-02T14:43:53.000Z" title="2024/6/2 22:43:53">2024-06-02</time>发表</span><span class="level-item"><time dateTime="2024-06-05T03:13:08.926Z" title="2024/6/5 11:13:08">2024-06-05</time>更新</span><span class="level-item">37 分钟读完 (大约5548个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/02/QuickPassHBase/">QuickPassHBase</a></p><div class="content"><h2 id="快速上手HBase"><a href="#快速上手HBase" class="headerlink" title="快速上手HBase"></a>快速上手HBase</h2><p>[TOC]</p>
<h3 id="⚙-1-HBase简介"><a href="#⚙-1-HBase简介" class="headerlink" title="⚙ 1. HBase简介"></a>⚙ 1. HBase简介</h3><h4 id="1-1-HBase的定义"><a href="#1-1-HBase的定义" class="headerlink" title="1.1 HBase的定义"></a>1.1 HBase的定义</h4><p><strong>Apache HBase</strong> 是以 HDFS 为数据存储的，一种分布式、可扩展的 NoSQL 数据库。</p>
<p>HBase 的设计理念依据 Google 的 BigTable 论文，论文中对于数据模型的首句介绍。</p>
<p><strong>BigTable是一个稀疏的、分布式的、持久的多维排序映射(Map)。该映射由行键、列键和时间戳索引作为键(Key)，映射中的每个值(Value)都是一个未解释的字节数组。</strong></p>
<p>HBase 使用与 BigTable 非常相似的数据模型。用户将数据行存储在带标签的表中。数据行具有可排序的键和任意数量的列。该表存储稀疏，因此如果用户喜欢，同一表中的行可以具有疯狂变化的列。</p>
<h4 id="1-2-HBase的数据模型"><a href="#1-2-HBase的数据模型" class="headerlink" title="1.2 HBase的数据模型"></a>1.2 HBase的数据模型</h4><h5 id="1-2-1-HBase-的逻辑结构"><a href="#1-2-1-HBase-的逻辑结构" class="headerlink" title="1.2.1 HBase 的逻辑结构"></a>1.2.1 HBase 的逻辑结构</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;row_key1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;personal_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZhangSan&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;156****0000&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;office_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;tel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010-1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shandong&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;row_key11&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;personal_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;133****0000&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;office_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;tel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010-1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;row_key2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>列族→</td>
        <td colspan="3">personal_info</td> 
        <td colspan="3">office_info</td> 
    </tr>
    <tr>
        <td>RowKey↓</td>
        <td>name</td> 
        <td>city</td>
        <td>phone</td>
        <td>tel</td>
        <td>address</td>
    </tr>
    <tr>
        <td>row_key1</td>
        <td>ZhangSan</td> 
        <td>Beijing</td>
        <td>156****0000</td>
        <td>010-1234567</td>
        <td>Shandong</td>
    </tr>
    <tr>
        <td>row_key11</td>
        <td></td> 
        <td>Shanghai</td>
        <td>131****0000</td>
        <td>010-1234567</td>
        <td></td>
    </tr>
    <tr>
        <td>row_key2</td>
        <td>...</td> 
        <td>...</td>
        <td>...</td>
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>在上面的表格中：</p>
<ul>
<li><code>personal_info</code>、<code>office_info</code>称为<strong>列族</strong></li>
<li><code>name</code>、<code>city</code>、<code>phone</code>、<code>tel</code>、<code>address</code>称为<strong>列</strong></li>
<li><code>row_key1</code>、<code>row_key11</code>称为<strong>行键</strong>。</li>
<li>将一整张大表按照<strong>行</strong>进行拆分，拆分为多个表，拆分后的每个表称为**块(Region)**，用于实现分布式结构。</li>
<li>将一整张大表按照<strong>列族</strong>进行拆分，拆分为多个**存储(Store)**，用于在底层存储到不同的文件夹中，便于文件对应。</li>
</ul>
<p>存储数据<strong>稀疏</strong>，数据存储<strong>多维</strong>，不同的行具有不同的列。数据存储整体有序，按照RowKey的字典序排列，RowKey为一个Byte数组。</p>
<h5 id="1-2-2-HBase-的物理结构"><a href="#1-2-2-HBase-的物理结构" class="headerlink" title="1.2.2 HBase 的物理结构"></a>1.2.2 HBase 的物理结构</h5><p>物理存储结构即为数据映射关系，而在概念视图的空单元格，底层实际根本不存储。</p>
<p>在HDFS中划分好的存储Store如下：</p>
<table>
    <tr>
        <td></td>
        <td colspan="3">personal_info</td> 
    </tr>
    <tr>
        <td>RowKey</td>
        <td>name</td> 
        <td>city</td>
        <td>phone</td>
    </tr>
    <tr>
        <td>row_key1</td>
        <td>ZhangSan</td> 
        <td>Beijing</td>
        <td>156****0000</td>
    </tr>
    <tr>
        <td>row_key11</td>
        <td></td> 
        <td>Shanghai</td>
        <td>131****0000</td>
    </tr>
    <tr>
        <td>row_key2</td>
        <td>...</td> 
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>其底层一定是以映射(Map)的方式进行存储的，格式为**<code>(Key, Value)</code><strong>，<code>Value</code>一定是</strong>“ZhangSan”**这种字段。那么<code>Key</code>是什么呢？</p>
<p>为了确定<code>Value</code>值**”ZhangSan”<strong>，我们需要用</strong>Key<strong>对应到</strong>Value**，于是得到存储如下：</p>
<table>
<thead>
<tr>
<th>Row Key</th>
<th>Column Family</th>
<th>Column Qualifier</th>
<th>Timestamp</th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>row_key1</td>
<td>personal_info</td>
<td>name</td>
<td>t1</td>
<td>Put</td>
<td>ZhangSan</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>city</td>
<td>t2</td>
<td>Put</td>
<td>Beijing</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t3</td>
<td>Put</td>
<td>156****0000</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t4</td>
<td>Put</td>
<td>156****0001</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t5</td>
<td>Delete</td>
<td>156****0001</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>因为 HDFS 是无法修改数据的，而 HBase 需要修改数据，那么就需要解决这一问题，于是就有了**时间戳(Timestamp)**。不同版本（version）的数据根据 <strong>Timestamp</strong> 进行区分，读取数据默认读取最新的版本。</p>
<p>在上面的表格中，<code>t4</code>相对于<code>t3</code>来说就是进行了修改，将<code>t3</code>时的**<code>phone</code><strong>从<code>156****0000</code>修改为<code>t4</code>时的<code>156****0001</code>，读取时默认读取<code>t4</code>时的</strong><code>phone</code>**值，通过这种方式完成了修改。</p>
<p>同样的，我们也不好删除数据，因此我们只需要插入一条**<code>Type</code>**为<code>Delete</code>的数据即可。</p>
<h5 id="1-2-3-数据模型"><a href="#1-2-3-数据模型" class="headerlink" title="1.2.3 数据模型"></a>1.2.3 数据模型</h5><ul>
<li><p><strong>Name Space</strong> 命名空间</p>
<p>类似于关系型数据库的 <strong>Database</strong> 概念，每个命名空间下有多个表。HBase 两个自带的命名空间，分别是 <code>hbase</code> 和<code>default</code>，<code>hbase</code> 中存放的是 HBase 内置的表，<code>default</code>表是用户默认使用的命名空间。</p>
</li>
<li><p><strong>Table</strong></p>
<p>类似于关系型数据库的<strong>表</strong>概念。不同的是，HBase 定义表时<strong>只需要声明列族</strong>即可，<strong>不需要声明具体的列</strong>。因为数据存储时稀疏的，所有往HBase写入数据时，字段<strong>可以动态、按需指定</strong>。因此，和关系型数据库相比，HBase能够轻松应对字段变更的场景。</p>
<p>需要注意的是，<strong>列族</strong>的存在是<strong>动态</strong>添加列（或称字段）的基础。</p>
</li>
<li><p><strong>Row</strong></p>
<p>HBase 表中的每行数据都由<em>*一个行键(RowKey)<strong>和</strong>多个列(Column)<strong>组成，数据是按照 RowKey的字典顺序存储的，</strong>*并且查询数据时只能根据 RowKey进行检索</em>**，所以RowKey的设计十分重要。</p>
</li>
<li><p><strong>Column</strong></p>
<p>HBase 中的每个列都由<strong>列族(Column Family)<strong>和</strong>列限定符(Column Qualifier)<strong>进行限定，例如<code>info:name, info:age</code>。建表时，只需指明列族，而</strong>列限定符无需预先定义</strong>。列限定符听起来很高端，其实就是列名的意思。</p>
</li>
<li><p><strong>Time Stamp</strong></p>
<p>用于标识数据的**不同版本(version)**，每条数据写入时，系统会自动为其加上该字段，其值为写入 HBase 的时间。</p>
</li>
<li><p><strong>Cell</strong></p>
<p>由 <code>&#123;rowkey, Column Family: Column Qualifier, Timestamp&#125;</code> 唯一确定的单元，<code>Cell</code>中的数据全部是字节码形式存储。</p>
</li>
</ul>
<h4 id="1-3-HBase-基本架构"><a href="#1-3-HBase-基本架构" class="headerlink" title="1.3 HBase 基本架构"></a>1.3 HBase 基本架构</h4><img src="./QuickPassHBase/HBaseStructure.png" alt="HBase基本架构" style="zoom:33%;" />

<ul>
<li><p><strong>Master</strong></p>
<p><strong>主要进程</strong>，具体实现类为<code>HMaster</code>，通常部署在<code>NameNode</code>上。</p>
<p><strong>主要功能</strong>：负责通过 <code>ZK</code> 监控 <code>RegionServer</code> 进程状态，同时是所有元数据变化的接口，内部启动监控执行 <code>region</code> 的故障转移和拆分的线程。</p>
<p><strong>功能的详细描述</strong>：</p>
<ul>
<li><p>管理元数据表格 <code>hbase:meta</code>：接收用户对表格创建、修改、删除的命令并执行。</p>
</li>
<li><p>监控 <code>RegionServer</code> 是否需要进行<strong>负载均衡</strong>、<strong>故障转移</strong>和<strong>Region拆分</strong>。通过启动多个后台线程监控实现上述功能：</p>
<ul>
<li><p><code>LoadBalancer</code> 负载均衡器</p>
<p>周期性监控 <code>region</code>分布在 <code>RegionServer</code> 上面是否均衡，由参数 <code>hbase.balancer.period</code>控制周期时间，默认5分钟。</p>
</li>
<li><p><code>CatalogJanitor</code>元数据管理器</p>
<p>定期检查和清理<code>hbase:meta</code>中的数据。</p>
</li>
<li><p><code>MasterProcWAL</code> Master 预写日志处理器</p>
<p>把Master需要执行的任务记录到预写日志WAL中，如果Master宕机，则让BackupMaster继续操作。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RegionServer</strong></p>
<p><strong>主要进程</strong>，具体实现类为<code>HRegionServer</code>，通常部署在<code>DataNode</code>上。</p>
<p><strong>功能</strong>：主要负责数据 <code>Cell</code> 的处理，同时在执行区域的拆分和合并的时候，由 <code>RegionServer</code> 来实际执行。</p>
<p><strong>功能的详细描述</strong>：</p>
<ul>
<li>负责数据 <code>Cell</code> 的处理，例如写入数据<code>put</code>，查询数据<code>get</code>等。</li>
<li>拆分合并 <code>region</code> 的实际执行者，有 <strong>Master</strong> 监控，有<code>RegionServer</code> 执行。</li>
</ul>
</li>
<li><p><strong>ZooKeeper</strong></p>
<p>HBase 通过 <code>ZooKeeper</code> 来做 <code>Master</code>的高可用、记录 <code>RegionServer</code> 的部署信息、并且存储有 <code>meta</code> 表的位置信息。<br>HBase 对于数据的读写操作时是直接访问 <code>ZooKeeper</code> 的，在 2.3 版本推出 <code>Master Registry</code> 模式，客户端可以直接访问 <code>Master</code>。使用此功能，会加大对 <code>Master</code>的压力，减轻对 <code>ZooKeeper</code> 的压力。</p>
</li>
<li><p><strong>HDFS</strong></p>
<p><code>HDFS</code> 为 HBase 提供最终的底层数据存储服务，同时为 HBase 提供高容错的支持。</p>
</li>
</ul>
<p>上图中的<code>Region</code>由三个<code>RegionServer</code>随机管理，尽量均衡。表名<code>hbase:meta</code>是一个特例，他存储在<strong>HDFS</strong>，但是由<strong>Master</strong>管理。</p>
<h3 id="🔧-2-快速上手"><a href="#🔧-2-快速上手" class="headerlink" title="🔧 2. 快速上手"></a>🔧 2. 快速上手</h3><h4 id="2-1-安装部署"><a href="#2-1-安装部署" class="headerlink" title="2.1 安装部署"></a>2.1 安装部署</h4><h5 id="2-1-1-分布式部署"><a href="#2-1-1-分布式部署" class="headerlink" title="2.1.1 分布式部署"></a>2.1.1 分布式部署</h5><ol>
<li><p>至少 3 台虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101</span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证 <strong>ZooKeeper</strong> 正常部署，并且启动 <strong>ZooKeeper</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证 <strong>Hadoop</strong> 正常部署，并且启动 <strong>Hadoop</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <strong>HBase</strong> 环境</p>
<p>① 下载 HBase 安装包（压缩包），这里假设为<code>hbase-2.4.11-bin.tar.gz</code></p>
<p>② 解压 HBase 安装包到一个文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /path/to/hbase-2.4.11-bin.tar.gz -C /path/to/module</span><br></pre></td></tr></table></figure>

<p>③ 在用户目录下，添加用户环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#HBase_HOME</span></span><br><span class="line"><span class="built_in">export</span> HBASE_HOME = /path/to/module/hbase-2.4.11</span><br><span class="line"><span class="built_in">export</span> PATH = <span class="variable">$PATH</span>:<span class="variable">$HBASE_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>④ 使环境变量生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure>

<p>⑤ 修改配置文件</p>
<ul>
<li><p><code>hbase-env.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示是否需要 HBase 管理维护一个自带的 ZooKeeper, 默认为 true</span></span><br><span class="line"><span class="comment"># 我们需要使用本机已经配置好的 ZooKeeper, 所以修改为 False</span></span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hbase-site.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101,hadoop102,hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase数据在HDFS中的存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase的运行模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- false为单机模式, HBase和ZooKeeper会运行在同一个JVM虚拟机中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- true 为分布式模式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper快照的存储位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里替换为自己的 /path/to/ZooKeeperDir --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/zookeeper-3.4.6/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- HBase 安全模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在分布式模式下, 设置为 false --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>regionservers</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101</span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br></pre></td></tr></table></figure></li>
</ul>
<p>⑥ 解决 <code>log4j</code> 不兼容的问题，移除 <code>HBase</code>或者 <code>Hadoop</code>的 <code>.jar</code>包</p>
<p>⑦ 使用 <code>scp</code> 命令同步 HBase 配置，需要提前设置好免密登录。或者使用 <code>xsync</code></p>
</li>
<li><p>启动 HBase 服务</p>
<ul>
<li><p>单点启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单点启动HMaster</span></span><br><span class="line">hbase-daemon.sh start master</span><br><span class="line"><span class="comment">#单点启动HRegionServer</span></span><br><span class="line">hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>集群启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="2-1-2-高可用服务"><a href="#2-1-2-高可用服务" class="headerlink" title="2.1.2 高可用服务"></a>2.1.2 高可用服务</h5><ol>
<li><p>如果 HBase 已经启动，先关闭HBase</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件 <code>backup-masters</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用touch命令或者echo命令均可</span></span><br><span class="line"><span class="built_in">touch</span> /path/to/hbase-2.1.4/conf/backup-masters</span><br><span class="line">vim /path/to/hbase-2.1.4/conf/backup-masters</span><br></pre></td></tr></table></figure>

<p>添加内容：<code>hadoop102</code></p>
</li>
<li><p>使用 <code>scp</code> 命令分发配置文件</p>
</li>
<li><p>启动HBase，正常启动进程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101 -&gt; HMaster HRegionServer</span><br><span class="line">hadoop102 -&gt; HMaster HRegionServer</span><br><span class="line">hadoop103 -&gt; HRegionServer</span><br></pre></td></tr></table></figure>

<p>其中，<code>hadoop101</code> 的 <code>HMaster</code> 先启动作为主节点，<code>hadoop102</code> 的 <code>HMaster</code>后启动，作为**备用节点(Backup-Master)**。</p>
</li>
</ol>
<h4 id="2-2-使用操作"><a href="#2-2-使用操作" class="headerlink" title="2.2 使用操作"></a>2.2 使用操作</h4><h5 id="2-2-1-Shell操作"><a href="#2-2-1-Shell操作" class="headerlink" title="2.2.1 Shell操作"></a>2.2.1 Shell操作</h5><p>使用命令 <code>hbase shell</code> 启动 HBase 的 <code>Shell</code> 命令界面，所有命令均可以使用 <code>help</code> 查到。</p>
<p>当我们在 <code>hbase shell</code>中输入<code>help</code>命令时，将会弹出HBase的使用提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; help</span><br><span class="line">HBase Shell, version 2.1.8, rd8333e556c8ed739cf39dab58ddc6b43a50c0965, Tue Nov 19 15:29:04 UTC 2019</span><br><span class="line">Type &#x27;help &quot;COMMAND&quot;&#x27;, (e.g. &#x27;help &quot;get&quot;&#x27; -- the quotes are necessary) for help on a specific command.</span><br><span class="line">Commands are grouped. Type &#x27;help &quot;COMMAND_GROUP&quot;&#x27;, (e.g. &#x27;help &quot;general&quot;&#x27;) for help on a command group.</span><br><span class="line"></span><br><span class="line">COMMAND GROUPS:</span><br><span class="line">  Group name: general</span><br><span class="line">  Commands: processlist, status, table_help, version, whoami</span><br><span class="line"></span><br><span class="line">  Group name: ddl</span><br><span class="line">  Commands: alter, alter_async, alter_status, clone_table_schema, create, describe, disable, disable_all, drop, drop_all, enable, enable_all, exists, get_table, is_disabled, is_enabled, list, list_regions, locate_region, show_filters</span><br><span class="line"></span><br><span class="line">  Group name: namespace</span><br><span class="line">  Commands: alter_namespace, create_namespace, describe_namespace, drop_namespace, list_namespace, list_namespace_tables</span><br><span class="line"></span><br><span class="line">  Group name: dml</span><br><span class="line">  Commands: append, count, delete, deleteall, get, get_counter, get_splits, incr, put, scan, truncate, truncate_preserve</span><br><span class="line"></span><br><span class="line">  Group name: tools</span><br><span class="line">  Commands: assign, balance_switch, balancer, balancer_enabled, catalogjanitor_enabled, catalogjanitor_run, catalogjanitor_switch, cleaner_chore_enabled, cleaner_chore_run, cleaner_chore_switch, clear_block_cache, clear_compaction_queues, clear_deadservers, close_region, compact, compact_rs, compaction_state, flush, hbck_chore_run, is_in_maintenance_mode, list_deadservers, major_compact, merge_region, move, normalize, normalizer_enabled, normalizer_switch, split, splitormerge_enabled, splitormerge_switch, stop_master, stop_regionserver, trace, unassign, wal_roll, zk_dump</span><br><span class="line"></span><br><span class="line">  Group name: replication</span><br><span class="line">  Commands: add_peer, append_peer_exclude_namespaces, append_peer_exclude_tableCFs, append_peer_namespaces, append_peer_tableCFs, disable_peer, disable_table_replication, enable_peer, enable_table_replication, get_peer_config, list_peer_configs, list_peers, list_replicated_tables, remove_peer, remove_peer_exclude_namespaces, remove_peer_exclude_tableCFs, remove_peer_namespaces, remove_peer_tableCFs, set_peer_bandwidth, set_peer_exclude_namespaces, set_peer_exclude_tableCFs, set_peer_namespaces, set_peer_replicate_all, set_peer_serial, set_peer_tableCFs, show_peer_tableCFs, update_peer_config</span><br><span class="line"></span><br><span class="line">  Group name: snapshots</span><br><span class="line">  Commands: clone_snapshot, delete_all_snapshot, delete_snapshot, delete_table_snapshots, list_snapshots, list_table_snapshots, restore_snapshot, snapshot</span><br><span class="line"></span><br><span class="line">  Group name: configuration</span><br><span class="line">  Commands: update_all_config, update_config</span><br><span class="line"></span><br><span class="line">  Group name: quotas</span><br><span class="line">  Commands: list_quota_snapshots, list_quota_table_sizes, list_quotas, list_snapshot_sizes, set_quota</span><br><span class="line"></span><br><span class="line">  Group name: security</span><br><span class="line">  Commands: grant, list_security_capabilities, revoke, user_permission</span><br><span class="line"></span><br><span class="line">  Group name: procedures</span><br><span class="line">  Commands: list_locks, list_procedures</span><br><span class="line"></span><br><span class="line">  Group name: visibility labels</span><br><span class="line">  Commands: add_labels, clear_auths, get_auths, list_labels, set_auths, set_visibility</span><br><span class="line"></span><br><span class="line">  Group name: rsgroup</span><br><span class="line">  Commands: add_rsgroup, balance_rsgroup, get_rsgroup, get_server_rsgroup, get_table_rsgroup, list_rsgroups, move_namespaces_rsgroup, move_servers_namespaces_rsgroup, move_servers_rsgroup, move_servers_tables_rsgroup, move_tables_rsgroup, remove_rsgroup, remove_servers_rsgroup</span><br><span class="line"></span><br><span class="line">SHELL USAGE:</span><br><span class="line">Quote all names in HBase Shell such as table and column names.  Commas delimit</span><br><span class="line">command parameters.  Type &lt;RETURN&gt; after entering a command to run it.</span><br><span class="line">Dictionaries of configuration used in the creation and alteration of tables are</span><br><span class="line">Ruby Hashes. They look like this:</span><br><span class="line"></span><br><span class="line">  &#123;&#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;, ...&#125;</span><br><span class="line"></span><br><span class="line">and are opened and closed with curley-braces.  Key/values are delimited by the</span><br><span class="line">&#x27;=&gt;&#x27; character combination.  Usually keys are predefined constants such as</span><br><span class="line">NAME, VERSIONS, COMPRESSION, etc.  Constants do not need to be quoted.  Type</span><br><span class="line">&#x27;Object.constants&#x27; to see a (messy) list of all constants in the environment.</span><br><span class="line"></span><br><span class="line">If you are using binary keys or values and need to enter them in the shell, use</span><br><span class="line">double-quote&#x27;d hexadecimal representation. For example:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\x03\x3f\xcd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\003\023\011&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">put <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;test\xef\xff&quot;</span>, <span class="string">&#x27;f1:&#x27;</span>, <span class="string">&quot;\x01\x33\x40&quot;</span></span></span><br><span class="line"></span><br><span class="line">The HBase shell is the (J)Ruby IRB with the above HBase-specific commands added.</span><br><span class="line">For more on the HBase Shell, see http://hbase.apache.org/book.html</span><br></pre></td></tr></table></figure>

<p>根据上述信息，我们可以进一步的操作 HBase 数据库。我们实际开发中常用的**命令组(COMMAND GROUPS)**有：<code>general</code>、<code>namespace</code>、<code>ddl</code>、<code>dml</code>等，下面依次介绍这些内容：</p>
<ul>
<li><p><strong>通用命令 <code>general</code></strong></p>
<ul>
<li><p>查看 HBase 状态 <code>status</code>，提供 HBase 的状态，如服务器的数量等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; status</span><br><span class="line">1 active master, 0 backup masters, 1 servers, 0 dead, 4.0000 average load</span><br><span class="line">Took 0.5268 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 HBase 版本 <code>version</code>，提供正在使用 HBase 版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; version</span><br><span class="line">2.1.8, rd8333e556c8ed739cf39dab58ddc6b43a50c0965, Tue Nov 19 15:29:04 UTC 2019</span><br><span class="line">Took 0.0002 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>表引用命令提供帮助 <code>table_help</code></p>
</li>
<li><p>提供有关用户的信息 <code>whoami</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; whoami</span><br><span class="line">nilera (auth:SIMPLE)</span><br><span class="line">    groups: nilera</span><br><span class="line">Took 0.0283 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>操作命名空间 <code>Namespace</code></strong></p>
<p>**命名空间(Namespace)**，相当于MySQL数据库中的DataBase。<code>Namespace</code> 命令包括：<code>alter namespace</code>、<code>create_namespace</code>、<code>describe_namespace</code>、<code>drop_namespace</code>、<code>list_namespace</code>、<code>list_namespace_tables</code>。下面将对一些常用命令进行介绍：</p>
<ul>
<li><p>查看全部命名空间 <code>list_namespace</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.5484 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建命名空间 <code>create_namespace</code></p>
<p>用法：<code>create_namespace &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create_namespace &#x27;bigdata&#x27;</span><br><span class="line">Took 0.0432 seconds</span><br><span class="line">hbase(main):002:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">bigdata</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0224 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除命名空间 <code>drop_namespace</code></p>
<p>用法：<code>drop_namespace &#39;ns&#39;</code>，删除命名空间时，命名空间必须为空。</p>
</li>
<li><p>查看命名空间 <code>describe_namespace</code></p>
<p>用法：<code>describe_namespace &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; describe_namespace &#x27;bigdata&#x27;</span><br><span class="line">DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;bigdata&#x27;&#125;</span><br><span class="line">Took 0.0068 seconds</span><br><span class="line">=&gt; 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看命名空间下的表 <code>list_namespace_tables</code></p>
<p>用法：<code>list_namespace_tables &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace_tables &#x27;default&#x27;</span><br><span class="line">TABLE</span><br><span class="line">logs</span><br><span class="line">user</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.3790 seconds</span><br><span class="line">=&gt; [&quot;logs&quot;, &quot;user&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据定义语言 <code>ddl</code></strong></p>
<p><strong>DDL(Data Definition Language)数据定义语言</strong>，主要是进行定义&#x2F;改变表的结构、数据类型、表之间的链接等操作。<code>ddl</code> 相关命令如下：<code>alter</code>、<code>alter_async</code>、<code>alter_status</code>、<code>clone_table_schema</code>、<code>create</code>、<code>describe</code>、<code>disable</code>、<code>disable_all</code>、<code>drop</code>、<code>drop_all</code>、<code>enable</code>、<code>enable_all</code>、<code>exists</code>、<code>get_table</code>、<code>is_disabled</code>、<code>is_enabled</code>、<code>list</code>、<code>list_regions</code>、<code>locate_region</code>、<code>show_filters</code>。下面将对一些常用命令进行介绍：</p>
<ul>
<li><p>创建表 <code>create</code></p>
<p><strong>常见用法：</strong></p>
<p>① <code>create &#39;ns:tb&#39;, &#123;NAME =&gt; &#39;cf&#39;, VERSION =&gt; 5&#125;</code></p>
<p>​	在命名空间 <code>ns</code> 下，创建一张表 <code>tb</code>，定义一个列族 <code>cf</code>。</p>
<p>② 当在默认命名空间<code>default</code>下创建表时，可以省略 <code>ns</code></p>
<p>③ <code>create &#39;tb&#39;, &#39;cf1&#39;, &#39;cf2&#39;</code></p>
<p>​	在默认命名空间<code>default</code>下，创建一张表<code>tb</code>，并定义两个列族 <code>cf1</code>、<code>cf2</code></p>
<p>④ <code>create &#39;tb&#39;, &#123;NAME =&gt; &#39;cf1&#39;, VERSION =&gt; 5&#125;, &#123;NAME =&gt; &#39;cf2&#39;, VERSION =&gt; 5&#125;</code></p>
<p>​	在默认命名空间<code>default</code>下，创建一张表<code>tb</code>，并定义两个列族 <code>cf1</code>、<code>cf2</code>，并同时指定两个列族的版本为 <code>5</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create &#x27;bigdata:person&#x27;, &#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; 5&#125;, &#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; 5&#125;</span><br><span class="line">Created table bigdata:person</span><br><span class="line">Took 1.5638 seconds</span><br><span class="line">=&gt; Hbase::Table - bigdata:person</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表的详细信息 <code>describe</code></p>
<p><strong>用法</strong>：<code>describe &#39;tb&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.1536 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表 <code>alter</code></p>
<p>表名创建时写的所有和列族相关的信息，都可以后续通过<code>alter</code>修改，包括<strong>增加</strong>、<strong>删除</strong>列族。</p>
<p>① 增加列族和修改信息都使用覆盖的方法</p>
<p>​	修改列族的版本，<code>VERSIONS =&gt; 6</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; 6</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 4.0145 seconds</span><br></pre></td></tr></table></figure>

<p>​	添加列族 <code>tel</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;tel&#x27;, VERSIONS =&gt; 6</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.4498 seconds</span><br></pre></td></tr></table></figure>

<p>​	查看修改后的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; &#x27;6&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#123;NAME =&gt; &#x27;tel&#x27;, VERSIONS =&gt; &#x27;6&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0795 seconds</span><br></pre></td></tr></table></figure>

<p>② 删除列族</p>
<p>​	删除列族可以用以下两种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;tel&#x27;, METHOD =&gt; &#x27;delete&#x27;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.1046 seconds</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; alter &#x27;bigdata:person&#x27;, &#x27;delete&#x27; =&gt; &#x27;msg&#x27;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.9721 seconds</span><br></pre></td></tr></table></figure>

<p>​	然后查询修改后的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0391 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用表 <code>disable</code></p>
<p><strong>用法</strong>： <code>disable &#39;ns:tb&#39;</code>或<code>disable &#39;tb&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; disable &#x27;bigdata:person&#x27;</span><br><span class="line">Took 0.9384 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表 <code>drop</code></p>
<p><strong>用法</strong>： <code>drop &#39;ns:tb&#39;</code>或<code>drop &#39;tb&#39;</code>，删除表时需要保证表是禁用的，否则会出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; drop &#x27;bigdata:person&#x27;</span><br><span class="line"></span><br><span class="line">ERROR: Table bigdata:person is enabled. Disable it first.</span><br><span class="line"></span><br><span class="line">For usage try &#x27;help &quot;drop&quot;&#x27;</span><br><span class="line"></span><br><span class="line">Took 0.0248 seconds</span><br></pre></td></tr></table></figure>

<p>​	禁用表后再删除表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; drop &#x27;bigdata:person&#x27;</span><br><span class="line">Took 1.7106 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据操纵语言 <code>dml</code></strong></p>
<p><strong>DML(Data Manipulation Language)数据操纵语言</strong>，主要是对数据进行增加、删除、修改操作。</p>
<ul>
<li><p>写入数据 <code>put</code></p>
<p>在 HBase 中如果想要写入数据，只能添加结构中最底层的 <code>Cell</code>。可以手动写入时间戳指定 <code>Cell</code> 的版本，推荐不写，默认使用当前的系统时间。如果重复写入相同 <code>rowKey</code>，相同列的数据，会写入多个版本进行覆盖。所以他同时兼具<strong>写入</strong>和<strong>修改</strong>的功能。</p>
<p><strong>用法</strong>：</p>
<p>① <code>put &#39;ns:tb&#39;, &#39;rk&#39;, &#39;col&#39;, &#39;value&#39;</code></p>
<p>​	向命名空间<code>ns</code>中的<code>tb</code>表中的行键为<code>rk</code>，列为<code>col</code>的位置写入值<code>value</code>。其中<code>col</code>为<code>cf:col</code>（即<code>列族:列名</code>）的格式。</p>
<p>​	如果重复向相同行号<code>rk</code>，相同<code>col</code>写数据，则会进行覆盖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">Took 0.2415 seconds</span><br><span class="line">hbase(main):002:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">Took 0.0121 seconds</span><br><span class="line">hbase(main):003:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;wangwu&#x27;</span><br><span class="line">Took 0.0342 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1002&#x27;, &#x27;info:name&#x27;, &#x27;zhaoliu&#x27;</span><br><span class="line">Took 0.0082 seconds</span><br><span class="line">hbase(main):005:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#x27;info:age&#x27;, &#x27;10&#x27;</span><br><span class="line">Took 0.0050 seconds</span><br><span class="line">hbase(main):006:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#x27;info:sex&#x27;, &#x27;male&#x27;</span><br><span class="line">Took 0.0054 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>put &#39;t1&#39;, &#39;r1&#39;, &#39;c1&#39;, &#39;value&#39;</code>用法同上。</p>
</li>
<li><p>读取数据 <code>get/scan</code></p>
<p>读取数据的方法有两个：<code>get</code> 和 <code>scan</code></p>
<ul>
<li><p><code>get</code>最大范围是一行数据，也可以进行列的过滤，读取数据的结果为多行 <code>Cell</code>。</p>
</li>
<li><p><code>scan</code>是扫描数据，能够读取多行数据，不建议扫描过多数据，推荐使用 <code>startRow</code> 和 <code>stopRow</code> 来控制读取的数据，默认范围左闭右开。</p>
</li>
</ul>
<p>① <code>get</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>											<span class="comment">#查看&#x27;r1&#x27;的数据</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;TIMERANGE =&gt; [ts1, ts2]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>&#125;							<span class="comment">#过滤单列, 只显示 &#x27;c1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>]&#125;			<span class="comment">#过滤多列, 只显示 &#x27;c1&#x27;, &#x27;c2&#x27;, &#x27;c3&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMESTAMP =&gt; ts1&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMERANGE =&gt; [ts1, ts2], VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMESTAMP =&gt; ts1, VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;FILTER =&gt; <span class="string">&quot;ValueFilter(=, &#x27;binary:abc&#x27;)&quot;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;c1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;CONSISTENCY =&gt; <span class="string">&#x27;TIMELINE&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;CONSISTENCY =&gt; <span class="string">&#x27;TIMELINE&#x27;</span>, REGION_REPLICA_ID =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1001&#x27;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:name                               timestamp=1717580289267, value=wangwu</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0645 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):002:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#123;COLUMN =&gt; &#x27;info:name&#x27;&#125;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:name                               timestamp=1717580289267, value=wangwu</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0107 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):003:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#123;COLUMN =&gt; &#x27;info:age&#x27;&#125;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:age                                timestamp=1717580366636, value=10</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0185 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>scan</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;hbase:meta&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;hbase:meta&#x27;</span>, &#123;COLUMNS =&gt; <span class="string">&#x27;info:regioninfo&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;ns1:t1&#x27;</span>, &#123;COLUMNS =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">&#x27;xyz&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;COLUMNS =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">&#x27;xyz&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;COLUMNS =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMERANGE =&gt; [1303668804000, 1303668904000]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;REVERSED =&gt; <span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;ALL_METRICS =&gt; <span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;METRICS =&gt; [<span class="string">&#x27;RPC_RETRIES&#x27;</span>, <span class="string">&#x27;ROWS_FILTERED&#x27;</span>]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;ROWPREFIXFILTER =&gt; <span class="string">&#x27;row2&#x27;</span>, FILTER =&gt; <span class="string">&quot;</span></span></span><br><span class="line">    (QualifierFilter (&gt;=, &#x27;binary:xyz&#x27;)) AND (TimestampsFilter ( 123, 456))&quot;&#125;</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;FILTER =&gt;</span></span></span><br><span class="line">    org.apache.hadoop.hbase.filter.ColumnPaginationFilter.new(1, 0)&#125;</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;CONSISTENCY =&gt; &#x27;TIMELINE&#x27;&#125;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;ISOLATION_LEVEL =&gt; &#x27;READ_UNCOMMITTED&#x27;&#125;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;MAX_RESULT_SIZE =&gt; 123456&#125;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717580289267, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0338 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):025:0&gt; scan &#x27;bigdata:student&#x27;, &#123;STARTROW =&gt; &#x27;1001&#x27;, STOPROW =&gt; &#x27;1003&#x27;&#125;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717580289267, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.0118 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据 <code>delete/deleteall</code></p>
<p>删除数据的方式有两个：<code>delete</code>和<code>deleteall</code></p>
<ul>
<li><code>delete</code> 表示删除一个版本的数据，即为 <code>1</code> 个 <code>Cell</code>，不填写版本默认删除最新的一个版本。</li>
<li><code>deleteall</code> 表示删除所有版本的数据，即为当前行当前列的多个 <code>Cell</code>。执行命令会标记数据为要删除，不会直接彻底删除，删除只在特定时期清理磁盘时进行。</li>
</ul>
<p>① <code>delete</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">Took 0.3910 seconds</span><br><span class="line">hbase(main):002:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">Took 0.2024 seconds</span><br><span class="line">hbase(main):003:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;wangwu&#x27;</span><br><span class="line">Took 0.1559 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717584831277, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0083 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):005:0&gt; delete &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;</span><br><span class="line">Took 0.0055 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):006:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717584831277, value=lisi</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0087 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>deleteall</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-2-API操作"><a href="#2-2-2-API操作" class="headerlink" title="2.2.2 API操作"></a>2.2.2 API操作</h5><ul>
<li>环境搭建</li>
<li>单线程使用连接</li>
<li>多线程使用连接</li>
<li>获取Admin</li>
<li>创建命名空间</li>
<li>多异常处理</li>
<li>判断表格是否存在</li>
<li>创建表格</li>
</ul>
<h3 id="📕-3-底层原理"><a href="#📕-3-底层原理" class="headerlink" title="📕 3. 底层原理"></a>📕 3. 底层原理</h3><h4 id="3-1-进程架构"><a href="#3-1-进程架构" class="headerlink" title="3.1 进程架构"></a>3.1 进程架构</h4><h5 id="3-1-1-Master架构"><a href="#3-1-1-Master架构" class="headerlink" title="3.1.1 Master架构"></a>3.1.1 Master架构</h5><h5 id="3-1-2-RegionServer架构"><a href="#3-1-2-RegionServer架构" class="headerlink" title="3.1.2 RegionServer架构"></a>3.1.2 RegionServer架构</h5><h4 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h4><h5 id="3-2-1-写入顺序"><a href="#3-2-1-写入顺序" class="headerlink" title="3.2.1 写入顺序"></a>3.2.1 写入顺序</h5><h5 id="3-2-2-刷新机制"><a href="#3-2-2-刷新机制" class="headerlink" title="3.2.2 刷新机制"></a>3.2.2 刷新机制</h5><h4 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h4><h5 id="3-3-1-读取顺序"><a href="#3-3-1-读取顺序" class="headerlink" title="3.3.1 读取顺序"></a>3.3.1 读取顺序</h5><h5 id="3-3-2-合并数据优化"><a href="#3-3-2-合并数据优化" class="headerlink" title="3.3.2 合并数据优化"></a>3.3.2 合并数据优化</h5><h4 id="3-4-文件合并"><a href="#3-4-文件合并" class="headerlink" title="3.4 文件合并"></a>3.4 文件合并</h4><h5 id="3-4-1-大合并"><a href="#3-4-1-大合并" class="headerlink" title="3.4.1 大合并"></a>3.4.1 大合并</h5><h5 id="3-4-2-小合并"><a href="#3-4-2-小合并" class="headerlink" title="3.4.2 小合并"></a>3.4.2 小合并</h5><h4 id="Region拆分"><a href="#Region拆分" class="headerlink" title="Region拆分"></a>Region拆分</h4><h5 id="自定义预分区"><a href="#自定义预分区" class="headerlink" title="自定义预分区"></a>自定义预分区</h5><h5 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h5><h3 id="🔧-企业开发"><a href="#🔧-企业开发" class="headerlink" title="🔧 企业开发"></a>🔧 企业开发</h3><h4 id="TSDB模式"><a href="#TSDB模式" class="headerlink" title="TSDB模式"></a>TSDB模式</h4><h4 id="基础表格模式"><a href="#基础表格模式" class="headerlink" title="基础表格模式"></a>基础表格模式</h4><h5 id="自定义API"><a href="#自定义API" class="headerlink" title="自定义API"></a>自定义API</h5><h5 id="整合框架"><a href="#整合框架" class="headerlink" title="整合框架"></a>整合框架</h5><h6 id="Phoenix-读写数据"><a href="#Phoenix-读写数据" class="headerlink" title="Phoenix 读写数据"></a>Phoenix 读写数据</h6><h6 id="Hive-分析数据"><a href="#Hive-分析数据" class="headerlink" title="Hive 分析数据"></a>Hive 分析数据</h6></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-27T10:18:43.000Z" title="2024/5/27 18:18:43">2024-05-27</time>发表</span><span class="level-item"><time dateTime="2024-05-27T10:18:43.645Z" title="2024/5/27 18:18:43">2024-05-27</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/27/Evaluation-Indicators-in-AI/">Evaluation Indicators in AI</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T13:50:18.000Z" title="2024/5/22 21:50:18">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-06-03T02:10:04.006Z" title="2024/6/3 10:10:04">2024-06-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/QT6/">QT6</a></span><span class="level-item">18 分钟读完 (大约2771个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Better-QT/">Better QT</a></p><div class="content"><p>[TOC]</p>
<h2 id="Qt-的一些常用技巧"><a href="#Qt-的一些常用技巧" class="headerlink" title="Qt 的一些常用技巧"></a>Qt 的一些常用技巧</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>快捷键 <code>Ctrl + Tab</code> 可以切换文件；</li>
<li>快捷键 <code>Alt + ENTER</code> 弹出代码生成提示，可以快速提示错误修改方案，类似于 IDEA 的 <code>Alt + ENTER</code>；</li>
<li>快捷键 <code>Alt + 鼠标</code> 同时输入；</li>
<li>快捷键 <code>Ctrl + R</code> 运行程序；</li>
<li>快捷键 <code>Ctrl + M</code> 创建书签（Bookmark），或者直接在某行代码前右键添加书签；</li>
<li>快捷键 <code>Ctrl + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + Shift + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + I</code> 代码对齐；</li>
<li>快捷键 <code>Ctrl + ;</code> 格式化代码；</li>
<li>快捷键 <code>Shift + Delete</code> 剪切当前行，可以当删除用；</li>
<li>快捷键 <code>Ctrl + Shift + R</code> 局部变量统一修改；</li>
<li>快捷键 <code>Ctrl + Shift + V</code> 复制历史；</li>
<li>用键盘模拟鼠标操作：  <table>
    <tr>
        <td colspan="3">功能键</td> 
        <td colspan="3">方向键</td> 
        <td>备注</td>
    </tr>
    <tr>
          <td>Ctrl</td>
          <td>Shift</td>
          <td>Alt</td>
          <td>左/右</td>
          <td>上/下</td>
          <td>Home/End</td>
          <td>方向键具有移动光标的作用</td>
    </tr>
    <tr>
          <td>×</td>
          <td>×</td>
          <td>×</td>
          <td>字符</td>
          <td>字符</td>
          <td>行首/行尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>×</td>
          <td>单词</td>
          <td>滚动条</td>
          <td>文件头/尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>单词</td>
          <td>移动</td>
          <td>行首/行尾</td>
          <td>Shift具有选中文本的作用</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>√</td>
          <td>-</td>
          <td>向上/下复制选中部分</td>
          <td>-</td>
          <td>-</td>
    </tr>
  </table></li>
<li>快捷键 <code>F1</code> 查看帮助、文档</li>
<li>快捷键 <code>F2</code> 快速到变量或者函数间切换</li>
<li>快捷键 <code>F4</code> 快速在<code>.cpp</code>文件和<code>.h</code>文件间切换</li>
<li>快捷键 <code>Ctrl + Shift + U</code> 查找所有使用该符号的地方</li>
<li>快捷键 <code>Ctrl + K</code> 打开定位器</li>
<li>快捷键 <code>Ctrl + L</code> 跳转到某一行</li>
<li>快捷键 <code>Ctrl + [Shift] + F</code> 查找&#x2F;替换当前文件[项目]当前选中的内容</li>
<li>快捷键 <code>[Shift] + F3</code> 查找下[上]一个</li>
<li>快捷键 <code>Ctrl + B</code> 编译工程</li>
<li>快捷键 <code>Ctrl + R</code> 运行工程</li>
<li>快捷键 <code>F5</code> 调试运行</li>
<li>快捷键 <code>Ctrl + Shift + F5</code> 重启调试</li>
<li>快捷键 <code>F9</code> 设置和取消断点</li>
<li>快捷键 <code>F10</code> 单步跳过</li>
<li>快捷键 <code>F11</code> 单步进入</li>
</ul>
<h3 id="Creator-片段"><a href="#Creator-片段" class="headerlink" title="Creator 片段"></a>Creator 片段</h3><p>片段简单理解一下就是已经写好的一些模式化的代码，用户可以使用内置片段或者根据自己的需要自定义片段。</p>
<ol>
<li>自带片段示例<br><img src="/./BetterQT/QtQuickSnippets.png" alt="Qt Quick Part"></li>
<li>自定义片段<br>一个用户的自定义片段需要以下几个内容：<br>$$片段 &#x3D; 一级标题 + 二级标题 + 片段文本$$<br>需要通过：编辑（Edit）→首选项（Preferences）→文本编辑器（Text Editor）→片段（Snippets）进行设置<br><img src="/./BetterQT/Qt_Custom_Snippets.png" alt="Qt Custom Snippets"><br>比如我要添加一个自定义片段 <code>note</code>，用来表示文件注释，可以选择 <code>Group</code> 为 <code>C++</code>，然后选择 <code>Add</code>，添加指定的内容：<br><img src="/./BetterQT/AddCustomSnippets.png" alt="Add Custom Snippets"></li>
</ol>
<h2 id="Qt-代码-文件解释"><a href="#Qt-代码-文件解释" class="headerlink" title="Qt 代码&#x2F;文件解释"></a>Qt 代码&#x2F;文件解释</h2><p>Qt的源代码和文件解释</p>
<h3 id="Qt-代码"><a href="#Qt-代码" class="headerlink" title="Qt 代码"></a>Qt 代码</h3><ul>
<li><code>hellocosbrowser.h</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOCOSBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOCOSBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span> : <span class="keyword">public</span> QWidget  <span class="comment">// QWidget 是所有应用程序窗口的基类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// Qt的宏, 支持 Qt 的特性, 如信号与槽、对象树、元对象等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里 HelloCOSBrowser 指定父窗口指针为 nullptr, 则它会作为一个独立的窗口进行展示, 否则则会作为父窗口的一个控件</span></span><br><span class="line">    <span class="comment">// 关于这个父窗口指针, 一个很典型的应用就是 微信</span></span><br><span class="line">    <span class="comment">// 当我们创建新窗口的时候, 如果不指定父窗口, 就会弹出一个独立的新窗口, 即电脑任务栏的图标会多出来一个</span></span><br><span class="line">    <span class="comment">// 如果指定了父窗口, 则不会创建一个独立的窗口, 即电脑任务栏处的图标不会增加</span></span><br><span class="line">    <span class="built_in">HelloCOSBrowser</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">HelloCOSBrowser</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::HelloCOSBrowser *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLOCOSBROWSER_H</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Qt-工程文件解释"><a href="#Qt-工程文件解释" class="headerlink" title="Qt 工程文件解释"></a>Qt 工程文件解释</h3><p>文件列表</p>
<table>
<thead>
<tr>
<th align="center">文件名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>pro</code> 文件</td>
<td align="center">该文件是 Qt 的项目文件，qmake工具可以根据此文件生成 Makefile</td>
</tr>
<tr>
<td align="center"><code>pro.user</code> 文件</td>
<td align="center">该文件包含和用户相关的项目信息（用户不需要关注此文件）</td>
</tr>
<tr>
<td align="center"><code>ui</code> 文件</td>
<td align="center">Qt 的设计师界面文件</td>
</tr>
<tr>
<td align="center"><code>.cpp</code> 文件</td>
<td align="center">C++ 源文件</td>
</tr>
<tr>
<td align="center"><code>.h</code> 文件</td>
<td align="center">C++ 头文件</td>
</tr>
</tbody></table>
<h2 id="MOC编译器"><a href="#MOC编译器" class="headerlink" title="MOC编译器"></a>MOC编译器</h2><p>MOC(Meta-Object Compiler)编译器<br>C++ 编译器本身不支持 Qt 的某些机制，Qt 希望对 C++ 代码进行自动扩展，这里就需要用到宏（例如：<code>Q_Object</code>）和继承。<br>此外为了方便用户使用，希望用户无感知，可以将这一操作直接集成到框架中。</p>
<h3 id="Qt-编译过程"><a href="#Qt-编译过程" class="headerlink" title="Qt 编译过程"></a>Qt 编译过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 目标</span><br><span class="line">  ↑</span><br><span class="line">  +-------------------------+</span><br><span class="line">                            ↑</span><br><span class="line">拓展代码 -&gt; MOC编译器 -&gt; 新CPP代码</span><br></pre></td></tr></table></figure>
<p>通过上述方式，实现 Qt 的某些特性。我们可以发现，当我们写完代码进行编译后，会产生一个 <code>debug</code> 文件夹，此时我们进入该文件夹，会看到一些元对象编译器编译的文件，如 <code>moc_xxxx.cpp</code> 或 <code>moc_xxx.h</code> 等文件。</p>
<h3 id="MOC-的使用方法"><a href="#MOC-的使用方法" class="headerlink" title="MOC 的使用方法"></a>MOC 的使用方法</h3><ol>
<li>MOC 编译工具由 Qt 框架自动调用</li>
<li>扫描 C++ 头文件，寻找 <code>Q_OBJECT</code> 宏</li>
<li>生成拓展 C++ 代码，再进行预编译</li>
<li>程序员在使用时，需要继承 QObject 类或者是 QObject 子类，并且包含 <code>Q_OBJECT</code> 宏。</li>
</ol>
<h2 id="Qt应用程序开发"><a href="#Qt应用程序开发" class="headerlink" title="Qt应用程序开发"></a>Qt应用程序开发</h2><h3 id="Qt-Designer-设计师界面使用"><a href="#Qt-Designer-设计师界面使用" class="headerlink" title="Qt Designer 设计师界面使用"></a>Qt Designer 设计师界面使用</h3><p><img src="/./BetterQT/Qt_Designer.png" alt="Qt Designer"><br>① Qt 控件编辑模式<br>② Qt 信号与槽编辑模式<br>③ Qt 伙伴关系编辑模式<br>④ Qt Tab 顺序编辑模式：可以设置按下 Tab 键的高亮顺序</p>
<h3 id="Qt-核心——信号与槽"><a href="#Qt-核心——信号与槽" class="headerlink" title="Qt 核心——信号与槽"></a>Qt 核心——信号与槽</h3><p><strong>信号与槽的基本概念</strong><br><img src="/./BetterQT/QtSignalsSlots.drawio.png" alt="Qt Signals and Slots"></p>
<ul>
<li>Qt 中的信号和槽是支持多对多的，即一个信号可以对应多个槽，一个槽可以由多个信号触发。</li>
<li>Qt 中的信号无需实现，可以由函数（普通函数或者槽函数）通过 <code>emit</code> 关键字发送信号传递参数。</li>
</ul>
<h4 id="Qt中如何定义信号"><a href="#Qt中如何定义信号" class="headerlink" title="Qt中如何定义信号"></a>Qt中如何定义信号</h4><ol>
<li>继承 <code>QObject</code> 类或其派生类，同时包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>signals</code> 声明函数信号函数，不需要具体实现信号函数</li>
<li>使用 <code>emit</code> 关键字发送信号</li>
</ol>
<h4 id="Qt中如何定义槽函数"><a href="#Qt中如何定义槽函数" class="headerlink" title="Qt中如何定义槽函数"></a>Qt中如何定义槽函数</h4><ol>
<li>必须包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>[public/protected/private] slots</code> 声明函数</li>
<li>需要具体实现声明的槽函数</li>
</ol>
<h4 id="Qt中如何连接信号与槽（三种写法）"><a href="#Qt中如何连接信号与槽（三种写法）" class="headerlink" title="Qt中如何连接信号与槽（三种写法）"></a>Qt中如何连接信号与槽（三种写法）</h4><ol>
<li><code>SIGNAL/SLOT</code> 宏写法：<br><code>QObject::connect(this, SIGNAL(...), this, SLOT(...));</code></li>
<li>函数指针写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, &amp;SlotFunction)</code></li>
<li>lambda 表达式写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, [=]() &#123; qDebug() &lt;&lt; &quot;...&quot;; &#125;)</code></li>
</ol>
<p>三种写法的比较：</p>
<table>
    <tr>
        <td rowspan="2" colspan="3">连接信号与槽</td> 
        <td colspan="2">宏</td>
        <td colspan="2">函数指针</td>
    </tr>
    <tr>
        <td>编译</td>
        <td>运行</td>
        <td>编译</td>
        <td>运行</td>
    </tr>
    <tr>
        <td rowspan="4">参数类型</td>
        <td colspan="2">完全相同</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td rowspan="2">隐式转换</td>
        <td>向上</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td>向下</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">不可以隐式转换</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
        <tr>
        <td rowspan="3">参数个数</td>
        <td colspan="2">信号=槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号>槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号<槽</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
</table>

<ul>
<li>这样看来好像宏写法相对于函数指针的写法来说，可能会带来一些问题，因为有时候宏写法通过编译后，在运行阶段可能会出现一些问题；而函数指针写法可以在出现这一问题之前（编译阶段）提前发现这一问题，使得程序无法通过编译。</li>
<li>但是事实上，宏写法还是存在一定的好处，当信号函数出现重载时，使用函数指针时，无法直接进行连接（会产生报错），只能使用类型转换来进行函数指针类型的转换，如<code>static_cast&lt;void QSpinBox::*)(int)&gt;</code>。</li>
<li>一般情况下，推荐使用函数指针方式连接信号与槽。</li>
<li>当面对信号与槽函数有重载的情况时，推荐使用宏方式连接。</li>
<li>对于短小的槽函数的调用且功能不被复用时，推荐使用 lambda 方式连接。</li>
</ul>
<h4 id="其他连接信号与槽的方式"><a href="#其他连接信号与槽的方式" class="headerlink" title="其他连接信号与槽的方式"></a>其他连接信号与槽的方式</h4><ul>
<li>使用 Qt Designer 连接信号与槽<br><img src="/./BetterQT/Designer_Connect.png" alt="Qt Designer Connect"></li>
<li>使用”转到槽”方式</li>
<li>信号与槽自动绑定<br>使用 <code>void on_&lt;对象名&gt;_&lt;信号名&gt;(信号参数);</code> 时可以不使用 <code>connect</code> 进行连接，但是当对象名、信号名或参数发生变化时，连接将会失效，且编译不会有错误提示。</li>
</ul>
<h3 id="Qt-窗口"><a href="#Qt-窗口" class="headerlink" title="Qt 窗口"></a>Qt 窗口</h3><h4 id="窗口的类型"><a href="#窗口的类型" class="headerlink" title="窗口的类型"></a>窗口的类型</h4><p><strong>顶层窗口、次级窗口（父、子窗口）</strong><br><img src="/./BetterQT/Qt_Windows.png" alt="Qt Windows"><br>在该图中，①可以称为顶层窗口（父窗口），②可以称为次级窗口（子窗口）。窗口中的某些按钮、输入框…等就是控件。</p>
<h4 id="设置窗口标志"><a href="#设置窗口标志" class="headerlink" title="设置窗口标志"></a>设置窗口标志</h4><p>在 Qt 中可以使用 <code>setWindowFlags()</code> 来设置窗口标志</p>
<ol>
<li>设置窗口无标题栏<br><img src="/./BetterQT/Window_With_No_Title.png" alt="Window With No Title"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint);</span><br></pre></td></tr></table></figure></li>
<li>设置窗口无边框<br><img src="/./BetterQT/Window_With_No_Frame.png" alt="Window With No Frame"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure></li>
<li>设置窗口置顶 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
如果按照上述方式依次设置窗口标志，我们会发现当设置第 $3$ 步时前面两步的操作都失效了，这是因为设置窗口置顶时，会覆盖前面的设置。我们可以使用“或”符连接这些标志，解决这一问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="窗口坐标系与几何布局"><a href="#窗口坐标系与几何布局" class="headerlink" title="窗口坐标系与几何布局"></a>窗口坐标系与几何布局</h3><h4 id="窗口的坐标系"><a href="#窗口的坐标系" class="headerlink" title="窗口的坐标系"></a>窗口的坐标系</h4><p><img src="/./BetterQT/CoordinateSystem.png" alt="Window Coordinate System"></p>
<h4 id="窗口的几何布局"><a href="#窗口的几何布局" class="headerlink" title="窗口的几何布局"></a>窗口的几何布局</h4><p><img src="/./BetterQT/WindowLayout.png" alt="Window Layout"></p>
<h3 id="为窗口添加图标"><a href="#为窗口添加图标" class="headerlink" title="为窗口添加图标"></a>为窗口添加图标</h3><ol>
<li>准备图标文件</li>
<li>调用 setWindowIcon 方法</li>
</ol>
<h3 id="为应用程序添加图标（一般使用这种方式）"><a href="#为应用程序添加图标（一般使用这种方式）" class="headerlink" title="为应用程序添加图标（一般使用这种方式）"></a>为应用程序添加图标（一般使用这种方式）</h3><ol>
<li>准备图标文件 <code>logo.ico</code></li>
<li>修改 pro 工程文件 <code>RC_ICONS = &lt;Path&gt;</code></li>
<li>通过此种方式修改图标，可执行程序 <code>.exe</code> 的图标会修改，且不需要额外单独设置窗口图标。</li>
</ol>
<h3 id="部署产品的三种方式"><a href="#部署产品的三种方式" class="headerlink" title="部署产品的三种方式"></a>部署产品的三种方式</h3><ol>
<li><p>手动部署（不常用，比较繁琐）<br>进入 <code>.exe</code> 文件所在的文件夹（<code>debug</code>目录），双击运行 <code>.exe</code> 文件，会提示缺少的文件（包括<code>dll</code>动态库、<code>plugin</code>插件等），然后找到对应的文件移动到 <code>.exe</code> 文件的同级目录下即可，如下：<br><img src="/./BetterQT/EXE_File_Dictionary.png" alt="EXE File Dictionary"><br>如果配置了环境变量则大概率不会出现报错提示缺少库的问题，那么这种方式就会失效。</p>
</li>
<li><p>使用 windeployqt 部署<br>① 查找 <code>windeployqt.exe</code> 程序<br>② 将 <code>windeployqt.exe</code> 加入环境变量<br>③ 再命令行界面执行命令 <code>windeployqt.exe &lt;exe_file_dir&gt;</code> 完成操作<br><img src="/./BetterQT/WIN_DEPLOY_QT_1.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_2.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_3.png" alt="WIN DEPLOY QT"></p>
</li>
<li><p>使用creator 部署<br>① 项目导航窗口→运行→部署→添加自定义部署<br><img src="/./BetterQT/CREATOR_DEPLOY_1.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_2.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_3.png" alt="CREATOR DEPLOY"><br>② 输入 <code>windeployqt.exe</code> 程序及对应的命令行参数<br><img src="/./BetterQT/CREATOR_DEPLOY_4.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_5.png" alt="CREATOR DEPLOY"><br>③ 执行部署命令<br><img src="/./BetterQT/CREATOR_DEPLOY_6.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_OK.png" alt="CREATOR DEPLOY OK"></p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T02:13:00.000Z" title="2024/5/22 10:13:00">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-05-22T04:33:42.112Z" title="2024/5/22 12:33:42">2024-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/">ECharts</a></span><span class="level-item">5 分钟读完 (大约751个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Build-Tomcat/">IDEA 2022 搭建 Tomcat 环境</a></p><div class="content"><p>[TOC]</p>
<h2 id="Tomcat-环境的搭建"><a href="#Tomcat-环境的搭建" class="headerlink" title="Tomcat 环境的搭建"></a>Tomcat 环境的搭建</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/what_how_why2020/article/details/114100385">参考教程</a></p>
<h3 id="下载-Tomcat"><a href="#下载-Tomcat" class="headerlink" title="下载 Tomcat"></a>下载 Tomcat</h3><p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/index.html">Tomcat官网地址</a><br><img src="https://img-blog.csdnimg.cn/direct/d5e359b939c040b8978dc243e260f662.png#pic_center" alt="Tomcat官网"><br>在 Tomcat 官网中下载指定版本的 Tomcat，左侧 Download 处有相应版本，这里推荐 Tomcat 9 版本（因为Tomcat 10 在配置时会出现一定的问题）。<br><img src="https://img-blog.csdnimg.cn/direct/30b899f91e23440abc83c30ac92a1ccd.png#pic_center" alt="TomcatDownload"><br>下载后解压到指定位置即可。</p>
<h3 id="配置环境变量即可"><a href="#配置环境变量即可" class="headerlink" title="配置环境变量即可"></a>配置环境变量即可</h3><p>配置 Tomcat 环境变量前一定要配置好 Java 的环境变量，尤其是JAVA_HOME，这里我一开始并没有配置 <code>JAVA_HOME</code>，我的环境变量是<code>JAVA_HOME_180=xxx</code>，这种方式Tomcat是找不到<code>JAVA_HOME</code>的，因此我又重新配置了<code>JAVA_HOME</code>。<br>我的 <code>JAVA_HOME</code> 环境变量为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=D:\JDK\jdk1.8.0_231</span><br></pre></td></tr></table></figure>
<p>下面是 Tomcat 的环境变量配置：<br>新建 <code>CATALINA_HOME</code> 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_HOME=D:\tomcat\apache-tomcat-9.0.89</span><br></pre></td></tr></table></figure>
<p>修改<code>Path</code>，在 <code>Path</code> 后添加（新建）如下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%CATALINA_HOME%\lib</span><br><span class="line">%CATALINA_HOME%\bin</span><br><span class="line">%CATALINA_HOME%\lib\servlet-api.jar</span><br></pre></td></tr></table></figure>

<h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>在命令行中，执行命令：<code>startup.bat</code>，若正常打印相关配置变量、且 Tomcat 进程被阻塞，即证明环境搭建成功。访问<code>localhost:8080</code>，出现以下界面即证明成功搭建。<br><img src="https://img-blog.csdnimg.cn/direct/28287d7ab3a145e396be286cc559d6e8.png#pic_center" alt="TomcatSuccess"><br>使用 <code>shutdown.bat</code> 命令即可使阻塞的 Tomcat 进程被关闭，推荐使用这种方式关闭 Tomcat。</p>
<h3 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h3><ol>
<li>协议处理程序初始化失败：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_59125846/article/details/122178889">参考教程</a><br>这个问题有可能是由于8080端口被占用了，在Windows中可以使用如下命令查看端口的占用情况： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|<span class="built_in">findstr</span> &quot;<span class="number">8080</span>&quot;</span><br></pre></td></tr></table></figure>
 如果确实被占用了，可以使用如下命令杀死端口号为 <code>&lt;PIDNUM&gt;</code> 的进程。 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> -PID &lt;PIDNUM&gt; -F</span><br></pre></td></tr></table></figure></li>
<li>闪退<br>可能原因是：环境变量配置不正确，仔细检查环境变量的配置。</li>
<li>乱码<br>问题描述：打开startup.bat后汉字乱码<br>解决方法：在.\apache-tomcat-9.0.43\conf下打开logging.properties文件<br>将<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>替换为<code>java.util.logging.ConsoleHandler.encoding = GBK</code></li>
</ol>
<h2 id="社区版-IDEA-如何配置-Tomcat"><a href="#社区版-IDEA-如何配置-Tomcat" class="headerlink" title="社区版 IDEA 如何配置 Tomcat"></a>社区版 IDEA 如何配置 Tomcat</h2><p>CSDN 上大多数教程使用 Maven 创建 Tomcat 项目，但是这种方法实在是过于麻烦，社区版和专业版又有些不同，找不到很多东西。</p>
<p>如何配置 IDEA 2022 社区版中的 Tomcat</p>
<ol>
<li>安装插件<br>在 File → Settings → Plugin 中安装插件，搜索 Tomcat，安装插件。<br><img src="https://img-blog.csdnimg.cn/direct/240fa059550945a28d84ff346ecfb0f7.png#pic_center" alt="SmartTomcat"></li>
<li>配置Tomcat路径<br>安装插件后，在 File → Settings → Plugin → Tomcat Server<br>添加配置如下：<br><img src="https://img-blog.csdnimg.cn/direct/0c4778a942504a91b01fcfbb42555f29.png#pic_center" alt="SmartTomcatConfig"></li>
<li>完成</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-19T08:33:06.000Z" title="2024/5/19 16:33:06">2024-05-19</time>发表</span><span class="level-item"><time dateTime="2024-05-22T01:49:59.850Z" title="2024/5/22 09:49:59">2024-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span> / </span><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/">Kaggle</a></span><span class="level-item">38 分钟读完 (大约5697个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/19/BELKA-2024/">BELKA_2024</a></p><div class="content"><p>[TOC]</p>
<h1 id="Leash-Bio-Predict-New-Medicines-with-BELKA"><a href="#Leash-Bio-Predict-New-Medicines-with-BELKA" class="headerlink" title="Leash Bio - Predict New Medicines with BELKA"></a>Leash Bio - Predict New Medicines with BELKA</h1><p>用 <em><strong>BELKA</strong></em> 预测新药</p>
<p>Predict small molecule-protein interactions using the Big Encoded Library for Chemical Assessment (BELKA)</p>
<p>使用化学评估大编码库（BELKA）预测小分子蛋白质相互作用</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>In this competition, you’ll develop machine learning (ML) models to predict the binding affinity of small molecules to specific protein targets – a critical step in drug development for the pharmaceutical industry that would pave the way for more accurate drug discovery. You’ll help predict which drug-like small molecules (chemicals) will bind to three possible protein targets.</p>
<p>在这场比赛中，你将开发机器学习（ML）模型来预测小分子与特定<strong>蛋白质靶标（目标蛋白）</strong>的结合亲和力——这是制药行业药物开发的关键一步，将为更准确的药物发现铺平道路。你将帮助预测哪种药物样的小分子（化学物质）将与三种可能的蛋白质靶点结合。</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Small molecule drugs are chemicals that interact with cellular protein machinery and affect the functions of this machinery in some way. Often, drugs are meant to inhibit the activity of single protein targets, and those targets are thought to be involved in a disease process. A classic approach to identify such candidate molecules is to physically make them, one by one, and then expose them to the protein target of interest and test if the two interact. This can be a fairly laborious and time-intensive process.</p>
<p><em>小分子药物是与细胞蛋白质机制相互作用并以某种方式影响该机制功能的化学物质。通常，药物旨在抑制单个蛋白质靶标的活性，而这些靶标被认为与疾病过程有关。识别这类候选分子的一种经典方法是一个接一个地进行物理制造，然后将其暴露于感兴趣的蛋白质靶点，并测试两者是否相互作用。这可能是一个相当费力和耗时的过程。</em></p>
<p>The US Food and Drug Administration (FDA) has approved roughly <a target="_blank" rel="noopener" href="https://www.fda.gov/drugs/development-approval-process-drugs/new-drugs-fda-cders-new-molecular-entities-and-new-therapeutic-biological-products">2,000 novel molecular entities</a> in its <a target="_blank" rel="noopener" href="https://www.fda.gov/about-fda/histories-fda-regulated-products/summary-nda-approvals-receipts-1938-present">entire history</a>. However, the number of chemicals in druglike space has been <a target="_blank" rel="noopener" href="https://www.nature.com/articles/432823a">estimated to be 10^60</a>, a space far too big to physically search. There are likely effective treatments for human ailments hiding in that chemical space, and better methods to find such treatments are desirable to us all.</p>
<p><em>美国食品药品监督管理局（FDA）已经批准了大约<a target="_blank" rel="noopener" href="https://www.fda.gov/drugs/development-approval-process-drugs/new-drugs-fda-cders-new-molecular-entities-and-new-therapeutic-biological-products">2000种新型分子实体</a>在其<a target="_blank" rel="noopener" href="https://www.fda.gov/about-fda/histories-fda-regulated-products/summary-nda-approvals-receipts-1938-present">整个历史</a>. 然而，类药物领域的化学物质数量<a target="_blank" rel="noopener" href="https://www.nature.com/articles/432823a">估计为$10^60$</a>，这个空间太大了，无法进行物理搜索。在这个化学空间里，可能有有效的治疗人类疾病的方法，而找到更好的治疗方法对我们所有人来说都是可取的。</em></p>
<p>To evaluate potential search methods in small molecule chemistry, competition host Leash Biosciences physically tested some 133M small molecules for their ability to interact with one of three protein targets using DNA-encoded chemical library (DEL) technology. This dataset, the Big Encoded Library for Chemical Assessment (BELKA), provides an excellent opportunity to develop predictive models that may advance drug discovery.</p>
<p><em>为了评估小分子化学中潜在的搜索方法，比赛主办方Leash Biosciences使用DNA编码化学文库（DEL）技术对约133M个小分子进行了物理测试，以确定它们与三个蛋白质靶标之一相互作用的能力。该数据集，即化学评估大编码库（BELKA），为开发可能促进药物发现的预测模型提供了极好的机会。</em></p>
<p>Datasets of this size are rare and restricted to large pharmaceutical companies. The current best-curated public dataset of this kind is perhaps <a target="_blank" rel="noopener" href="https://www.bindingdb.org/rwd/bind/index.jsp">bindingdb</a>, which, at 2.8M binding measurements, is much smaller than BELKA.</p>
<p><em>这种规模的数据集非常罕见，仅限于大型制药公司。目前这类最好的公共数据集可能是<a target="_blank" rel="noopener" href="https://www.bindingdb.org/rwd/bind/index.jsp">bindingdb</a>，在2.8M的结合测量值下，比BELKA小得多。</em></p>
<p>This competition aims to revolutionize small molecule binding prediction by harnessing ML techniques. Recent advances in ML approaches suggest it might be possible to search chemical space by inference using well-trained computational models rather than running <a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">laboratory</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">experiments</a>. Similar progress in <a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">other</a> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">fields</a> suggest using ML to search across vast spaces could be a generalizable approach applicable to many domains. We hope that by providing BELKA we will democratize aspects of computational drug discovery and assist the community in finding new lifesaving medicines.</p>
<p><em>这项竞赛旨在通过利用ML技术彻底改变小分子结合预测。ML方法的最新进展表明，使用训练有素的计算模型而不是进行<a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">实验室</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">实验</a>，通过推理搜索化学空间是可能的。<a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">其他</a> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">领域</a>的类似进展表明，使用ML在广阔的空间中搜索可能是一种适用于许多领域的通用方法。我们希望通过提供BELKA，我们将使计算药物发现的各个方面民主化，并帮助社区寻找新的救命药物。</em></p>
<p>Here, you’ll build predictive models to estimate the binding affinity of unknown chemical compounds to specified protein targets. You may use the training data provided; alternatively, there are a number of methods to make small molecule binding predictions without relying on empirical binding data (e.g. <a target="_blank" rel="noopener" href="https://github.com/gcorso/DiffDock">DiffDock</a>, and this contest was designed to allow for such submissions).</p>
<p><em>在这里，你将建立预测模型来估计未知化合物与特定蛋白质靶标的结合亲和力。您可以使用提供的培训数据；或者，有许多方法可以在不依赖经验结合数据的情况下进行小分子结合预测（例如<a target="_blank" rel="noopener" href="https://github.com/gcorso/DiffDock">DiffDock</a>，而本次竞赛旨在允许此类提交）。</em></p>
<p>Your work will contribute to advances in small molecule chemistry used to accelerate drug discovery.</p>
<p><em>你的工作将有助于促进用于加速药物发现的小分子化学的进步。</em></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>This metric for this competition is the average precision calculated for each (protein, split group) and then averaged for the final score. Please see this <a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/leash-BELKA/discussion/503232">forum post</a> for important details.</p>
<p><em>这项比赛的指标是为每个（蛋白质、分组）计算的平均精度，然后为最终得分取平均值。请参阅此<a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/leash-BELKA/discussion/503232">论坛帖子</a>了解重要细节。</em></p>
<p>Here’s the <a target="_blank" rel="noopener" href="https://www.kaggle.com/code/metric/leash-average-map">code</a> for the implementation.</p>
<p><em>这是<a target="_blank" rel="noopener" href="https://www.kaggle.com/code/metric/leash-average-map">代码</a>以供实施。</em></p>
<h3 id="Submission-File"><a href="#Submission-File" class="headerlink" title="Submission File"></a>Submission File</h3><p>For each <code>id</code> in the test set, you must predict a probability for the binary target <code>binds</code> target. The file should contain a header and have the following format:</p>
<p><em>对于测试集中的每个</em><code>id</code>，<em>您必须预测二进制目标“绑定”目标的概率。该文件应包含一个标头，并具有以下格式：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,binds</span><br><span class="line">295246830,0.5</span><br><span class="line">295246831,0.5</span><br><span class="line">295246832,0.5</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure>

<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul>
<li><strong>April 4, 2024</strong> - Start Date.</li>
<li><strong>July 1, 2024</strong> - Entry Deadline. You must accept the competition rules before this date in order to compete.</li>
<li><strong>July 1, 2024</strong> - Team Merger Deadline. This is the last day participants may join or merge teams.</li>
<li><strong>July 8, 2024</strong> - Final Submission Deadline.</li>
</ul>
<p>All deadlines are at 11:59 PM UTC on the corresponding day unless otherwise noted. The competition organizers reserve the right to update the contest timeline if they deem it necessary.</p>
<h2 id="Prizes"><a href="#Prizes" class="headerlink" title="Prizes"></a>Prizes</h2><ul>
<li>First Prize: $12,000</li>
<li>Second Prize: $10,000</li>
<li>Third Prize: $10,000</li>
<li>Fourth Prize: $8,000</li>
<li>Fifth Prize: $5,000</li>
<li>Top Student Group: $5,000 to the highest performing student team. A team would be considered a student team if majority members (e.g. at least 3 out of a 5 member team) are students enrolled in a high school or university degree. In the case of an even number of members, half of them must be students.</li>
</ul>
<h2 id="Competition-Host"><a href="#Competition-Host" class="headerlink" title="Competition Host"></a>Competition Host</h2><p><a target="_blank" rel="noopener" href="https://www.leash.bio/">Leash Biosciences</a> is a discovery-stage biotechnology company that seeks to improve medicinal chemistry with machine learning approaches and massive data collection. Leash is comprised of wet lab scientists and dry lab scientists in equal numbers, and is proudly headquartered in Salt Lake City, Utah, USA.</p>
<h2 id="Additional-Details"><a href="#Additional-Details" class="headerlink" title="Additional Details"></a>Additional Details</h2><h3 id="Chemical-Representations"><a href="#Chemical-Representations" class="headerlink" title="Chemical Representations"></a>Chemical Representations</h3><p>One of the goals of this competition is to explore and compare many different ways of representing molecules. Small molecules <a target="_blank" rel="noopener" href="https://jcheminf.biomedcentral.com/articles/10.1186/s13321-020-00460-5">have</a> <a target="_blank" rel="noopener" href="https://wires.onlinelibrary.wiley.com/doi/10.1002/wcms.1603">been</a> [represented](<a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acsinfocus.7e7006?ref=infocus/AI_&">https://pubs.acs.org/doi/10.1021/acsinfocus.7e7006?ref=infocus%2FAI_&amp;</a> Machine Learning) <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10689004/">with</a> SMILES, graphs, 3D structures, and more, including more esoteric methods <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1801.10130">such as spherical convolutional neural nets</a>. We encourage competitors to explore not only different methods of making predictions but also to try different ways of representing the molecules.</p>
<p>We provide the molecules in SMILES format.</p>
<p><em>这场比赛的目标之一是探索和比较许多不同的分子表现方式。小分子已经用SMILES、图形、3D结构等表示，包括更深奥的方法，如球形卷积神经网络。我们鼓励竞争对手不仅探索不同的预测方法，还尝试不同的分子表示方法。</em></p>
<p><em>我们提供SMILES格式的分子。</em></p>
<h3 id="SMILES"><a href="#SMILES" class="headerlink" title="SMILES"></a>SMILES</h3><p>SMILES is a concise string notation used to represent the structure of chemical molecules. It encodes the molecular graph, including atoms, bonds, connectivity, and stereochemistry as a linear sequence of characters, by traversing the molecule graph. SMILES is widely used in machine learning applications for chemistry, such as molecular property prediction, drug discovery, and materials design, as it provides a standardized and machine-readable format for representing and manipulating chemical structures.</p>
<p>The SMILES in this dataset should be sufficient to be translated into any other chemical representation format that you want to try. A simple way to perform some of these translations is with <a target="_blank" rel="noopener" href="https://www.rdkit.org/docs/GettingStartedInPython.html">RDKit</a>.</p>
<p><em>SMILES是一种简明的字符串表示法，用于表示化学分子的结构。它通过遍历分子图，将分子图（包括原子、键、连接性和立体化学）编码为线性字符序列。SMILES广泛用于化学的机器学习应用，如分子性质预测、药物发现和材料设计，因为它为表示和操纵化学结构提供了标准化和机器可读的格式。</em><br><em>该数据集中的SMILES应该足以转换为您想要尝试的任何其他化学表示格式。执行其中一些翻译的一种简单方法是使用<a target="_blank" rel="noopener" href="https://www.rdkit.org/docs/GettingStartedInPython.html">RDKit</a>.</em></p>
<h3 id="Details-about-the-experiments"><a href="#Details-about-the-experiments" class="headerlink" title="Details about the experiments"></a>Details about the experiments</h3><h3 id="DELs-are-libraries-of-small-molecules-with-unique-DNA-barcodes-covalently-attached"><a href="#DELs-are-libraries-of-small-molecules-with-unique-DNA-barcodes-covalently-attached" class="headerlink" title="DELs are libraries of small molecules with unique DNA barcodes covalently attached"></a>DELs are libraries of small molecules with unique DNA barcodes covalently attached</h3><p>Traditional <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nrd3368">high-throughput screening</a> requires keeping individual small molecules in separate, identifiable tubes and demands a lot of liquid handling to test each one of those against the protein target of interest in a separate reaction. The logistical overhead of these efforts tends to restrict screening collections, called libraries, to 50K-5M small molecules. A scalable solution to this problem, DNA-encoded chemical libraries, was <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">described in 2009</a>. As DNA sequencing got <a target="_blank" rel="noopener" href="https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost">cheaper and cheaper</a>, it became clear that DNA itself could be used as a label to identify, and deconvolute, collections of molecules in a complex mixture. <a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41573-023-00713-6">DELs</a> <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8369695/">leverage</a> this DNA sequencing technology.</p>
<p>These barcoded small molecules are in a pool (many in a single tube, rather than one tube per small molecule) and are exposed to the protein target of interest in solution. The protein target of interest is then rinsed to remove small molecules in the DEL that don’t bind the target, and the remaining binders are collected and their DNA sequenced.</p>
<p><strong>DEL是共价连接有独特DNA条形码的小分子库</strong><br><em>传统<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nrd3368">高通量筛选</a>需要将单个小分子保持在单独的、可识别的管中，并且需要大量的液体处理来在单独的反应中针对感兴趣的蛋白质靶标测试其中的每一个。这些工作的后勤开销往往将筛选收藏（称为文库）限制在5000万至500万个小分子以内。这个问题的一个可扩展的解决方案，DNA编码的化学文库，<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">在2009年描述</a>. 随着DNA测序变得<a target="_blank" rel="noopener" href="https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost">越来越便宜</a>，很明显，DNA本身可以用作标签来识别和消除复杂混合物中分子的聚集。<a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41573-023-00713-6%E5%BD%B1%E5%93%8D%E5%8A%9Bhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC8369695/">DELs</a>这种DNA测序技术。</em><br><em>这些条形码小分子在一个池中（许多在单管中，而不是每个小分子一管），并暴露于溶液中感兴趣的蛋白质靶标。然后冲洗感兴趣的蛋白质靶标，以去除DEL中不与靶标结合的小分子，收集剩余的结合物并对其DNA进行测序。</em></p>
<h3 id="DELs-are-manufactured-by-combining-different-building-blocks"><a href="#DELs-are-manufactured-by-combining-different-building-blocks" class="headerlink" title="DELs are manufactured by combining different building blocks"></a>DELs are manufactured by combining different building blocks</h3><p>An intuitive way to think about DELs is to imagine a Mickey Mouse head as an example of a small molecule in the DEL. We attach the DNA barcode to Mickey’s chin. Mickey’s left ear is connected by a zipper; Mickey’s right ear is connected by velcro. These attachment points of zippers and velcro are analogies to different chemical reactions one might use to construct the DEL.</p>
<p>We could purchase ten different Mickey Mouse faces, ten different zipper ears, and ten different velcro ears, and use them to construct our small molecule library. By creating every combination of these three, we’ll have 1,000 small molecules, but we only needed thirty building blocks (faces and ears) to make them. This combinatorial approach is what allows DELs to have so many members: the library in this competition is composed of 133M small molecules. The 133M small molecule library used here, AMA014, was provided by <a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>. It has a triazine core and superficially resembles the DELs described <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">here</a>.</p>
<p><strong>DEL是通过组合不同的构建块来制造的</strong><br>一个思考DEL的直观方法是想象一个米老鼠的头作为DEL中一个小分子的例子。我们把DNA条形码贴在米奇的下巴上。米奇的左耳由拉链连接；米奇的右耳是用尼龙搭扣连接的。拉链和尼龙搭扣的这些连接点类似于可能用于构建DEL的不同化学反应。<br>我们可以购买十个不同的米老鼠脸、十个不同拉链耳朵和十个不同尼龙搭扣耳朵，并用它们来构建我们的小分子库。通过创建这三者的每一个组合，我们将拥有1000个小分子，但我们只需要30个构建块（脸和耳朵）就可以制造它们。这种组合方法使DEL能够拥有如此多的成员：这场竞争中的文库由133M个小分子组成。这里使用的133M小分子文库AMA014由<a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>提供。它有一个三嗪核心，表面上类似于<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">此处</a>描述的DEL。</p>
<img src="https://www.googleapis.com/download/storage/v1/b/kaggle-user-content/o/inbox%2F1095143%2F1901c6caa0c6c011617f4dec525d7bbe%2FKaggle%20v2%20(1).png?generation=1712179256934503&alt=media">

<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Leash Biosciences is grateful for the generous cosponsorship of <a target="_blank" rel="noopener" href="https://www.topharvestcap.com/">Top Harvest Capital</a> and <a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>.</p>
<h2 id="Citation"><a href="#Citation" class="headerlink" title="Citation"></a>Citation</h2><p>Andrew Blevins, Ian K Quigley, Brayden J Halverson, Nate Wilkinson, Rebecca S Levin, Agastya Pulapaka, Walter Reade, Addison Howard. (2024). Leash Bio - Predict New Medicines with BELKA. Kaggle. <a target="_blank" rel="noopener" href="https://kaggle.com/competitions/leash-BELKA">https://kaggle.com/competitions/leash-BELKA</a></p>
<hr>
<h2 id="Dataset-Description"><a href="#Dataset-Description" class="headerlink" title="Dataset Description"></a>Dataset Description</h2><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>The examples in the competition dataset are represented by a binary classification of whether a given small molecule is a binder or not to one of three protein targets. The data were collected using DNA-encoded chemical library (DEL) technology.</p>
<p><em>比赛数据集中的例子由给定小分子是否与三个蛋白质靶标之一结合的二元分类表示。使用DNA编码化学文库（DEL）技术收集数据。</em></p>
<p>We represent chemistry with SMILES (<a target="_blank" rel="noopener" href="https://archive.epa.gov/med/med_archive_03/web/html/smiles.html">Simplified Molecular-Input Line-Entry System</a>) and the labels as binary binding classifications, one per protein target of three targets.</p>
<p>我们用SMILES（<a target="_blank" rel="noopener" href="https://archive.epa.gov/med/med_archive_03/web/html/smiles.html">简化分子输入 行输入系统</a>)和二元绑定分类来表示化学，三个靶标中的每个蛋白质靶标都有一个。</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a><strong>Files</strong></h2><p><strong>[train&#x2F;test].[csv&#x2F;parquet]</strong> - The train or test data, available in both the csv and parquet formats.</p>
<ul>
<li><code>id</code> - A unique example_id that we use to identify the molecule-binding target pair.</li>
<li><code>buildingblock1_smiles</code> - The structure, in SMILES, of the first building block</li>
<li><code>buildingblock2_smiles</code> - The structure, in SMILES, of the second building block</li>
<li><code>buildingblock3_smiles</code> - The structure, in SMILES, of the third building block</li>
<li><code>molecule_smiles</code> - The structure of the fully assembled molecule, in SMILES. This includes the three building blocks and the triazine core. Note we use a <code>[Dy]</code> as the stand-in for the DNA linker.</li>
<li><code>protein_name</code> - The protein target name</li>
<li><code>binds</code> - The target column. A binary class label of whether the molecule binds to the protein. Not available for the test set.</li>
</ul>
<p><strong>sample_submission.csv</strong> - A sample submission file in the correct format</p>
<p><strong>[train&#x2F;test].[csv&#x2F;parquet]</strong> - 训练或测试数据，csv和parquet格式均可。</p>
<ul>
<li><code>id</code> - 我们用来识别分子结合靶标对的唯一示例_id。</li>
<li><code>buildingblock1_smiles</code> - 第一个构建块的结构，以SMILES表示</li>
<li><code>buildingblock2_smiles</code> - 第二个构建块的结构，以SMILES表示</li>
<li><code>buildingblock3_smiles</code> - 第三个构建块的结构，以SMILES表示</li>
<li><code>molecule_smiles</code> - 完全组装的分子的结构，以SMILES表示。这包括三个构建块和三嗪核心。请注意，我们使用<code>[Dy]</code>作为DNA连接子的替代。</li>
<li><code>protein_name</code> - 蛋白质靶标名称</li>
<li><code>binds</code> - 目标列。分子是否与蛋白质结合的二进制类标签。不适用于测试集。</li>
</ul>
<h2 id="Competition-data"><a href="#Competition-data" class="headerlink" title="Competition data"></a><strong>Competition data</strong></h2><p>All data were generated in-house at Leash Biosciences. We are providing roughly 98M training examples per protein, 200K validation examples per protein, and 360K test molecules per protein. To test generalizability, the test set contains building blocks that are not in the training set. These datasets are very imbalanced: roughly 0.5% of examples are classified as binders; we used 3 rounds of selection in triplicate to identify binders experimentally. Following the competition, Leash will make all the data available for future use (3 targets × 3 rounds of selection × 3 replicates × 133M molecules, or 3.6B measurements).</p>
<p><em>所有数据均由Leash Biosciences公司内部生成。我们为每种蛋白质提供了大约 98M 个训练实例，为每种蛋白提供了 200K 个验证实例，为每个蛋白质提供了 360K 个测试分子。为了测试可推广性，测试集包含不在训练集中的构建块。这些数据集非常不平衡：大约0.5%的示例被归类为绑定；我们使用了三轮一式三份的选择来实验鉴定粘合剂。比赛结束后，Leash将提供所有数据供未来使用（3个靶标×3轮选择×3个重复×3.33M个分子，或3.6B测量值）。</em></p>
<h2 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a><strong>Targets</strong></h2><p>Proteins are encoded in the genome, and names of the genes encoding those proteins are typically bestowed by their discoverers and regulated by the <a target="_blank" rel="noopener" href="https://www.genenames.org/">Hugo Gene Nomenclature Committee</a>. The protein products of these genes can sometimes have different names, often due to the history of their discovery.</p>
<p>We screened three protein targets for this competition.</p>
<p>蛋白质在基因组中编码，编码这些蛋白质的基因的名称通常由其发现者命名，并由<a target="_blank" rel="noopener" href="https://www.genenames.org/">雨果基因命名委员会</a>监管。这些基因的蛋白质产物有时可能有不同的名称，通常是由于它们的发现历史。<br>我们为这次比赛筛选了三个蛋白质靶点。</p>
<h3 id="EPHX2-sEH"><a href="#EPHX2-sEH" class="headerlink" title="EPHX2 (sEH)"></a><strong>EPHX2 (sEH)</strong></h3><p>The first target, epoxide hydrolase 2, is encoded by the EPHX2 genetic locus, and its protein product is commonly named “soluble epoxide hydrolase”, or abbreviated to sEH. Hydrolases are enzymes that catalyze certain chemical reactions, and EPHX2&#x2F;sEH also hydrolyzes certain phosphate groups. EPHX2&#x2F;sEH is a potential drug target for high blood pressure and diabetes progression, and small molecules inhibiting EPHX2&#x2F;sEH from earlier DEL efforts <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8429121/">made it to clinical trials</a>.</p>
<p>EPHX2&#x2F;sEH was also screened with DELs, and hits predicted with ML approaches, in a <a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">recent</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">study</a> but the screening data were not published. We included EPHX2&#x2F;sEH to allow contestants an external gut check for model performance by comparing to these previously-published results.</p>
<p>We screened EPHX2&#x2F;sEH <a target="_blank" rel="noopener" href="https://www.caymanchem.com/product/10011669/soluble-epoxide-hydrolase-(human-recombinant)">purchased from Cayman Chemical</a>, a life sciences commercial vendor. For those contestants wishing to incorporate protein structural information in their submissions, the amino sequence is positions 2-555 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/P34913/entry#sequences">P34913</a>, the crystal structure can be found in <a target="_blank" rel="noopener" href="https://www.rcsb.org/structure/3i28">PDB entry 3i28</a>, and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/P34913">34913</a>. Additional EPHX2&#x2F;sEH crystal structures with ligands bound can be found in PDB.</p>
<p>第一个靶标环氧化物水解酶2由EPHX2基因座编码，其蛋白产物通常被命名为“可溶性环氧化物水解酶”，或缩写为sEH。水解酶是催化某些化学反应的酶，EPHX2&#x2F;sEH也水解某些磷酸基团。EPHX2&#x2F;sEH是高血压和糖尿病进展的潜在药物靶点，早期DEL研究中抑制EPHX2&#x2F;s EH的小分子<a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8429121/">已进入临床试验</a>.<br>EPHX2&#x2F;sEH也用DEL进行了筛选，并用ML方法预测了命中率(<a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html%E5%AD%A6%E4%B9%A0https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452)%E4%BD%86%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B2%A1%E6%9C%89%E5%85%AC%E5%B8%83%E3%80%82%E6%88%91%E4%BB%AC%E7%BA%B3%E5%85%A5%E4%BA%86EPHX2/sEH%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B8%8E%E4%B9%8B%E5%89%8D%E5%85%AC%E5%B8%83%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%EF%BC%8C%E8%AE%A9%E5%8F%82%E8%B5%9B%E8%80%85%E8%83%BD%E5%A4%9F%E5%AF%B9%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%A4%96%E9%83%A8%E6%A3%80%E6%9F%A5%E3%80%82">https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html学习https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452)但筛选数据没有公布。我们纳入了EPHX2/sEH，通过与之前公布的结果进行比较，让参赛者能够对模型性能进行外部检查。</a><br>我们筛选了EPHX2&#x2F;sEH<a target="_blank" rel="noopener" href="https://www.caymanchem.com/product/10011669/soluble-epoxide-hydrolase-%EF%BC%88%E4%BA%BA%E7%B1%BB%E9%87%8D%E7%BB%84%EF%BC%89%EF%BC%89%EF%BC%8C%E4%B8%80%E5%AE%B6%E7%94%9F%E5%91%BD%E7%A7%91%E5%AD%A6%E5%95%86%E4%B8%9A%E4%BE%9B%E5%BA%94%E5%95%86%E3%80%82%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E5%B8%8C%E6%9C%9B%E5%9C%A8%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81%E4%B8%AD%E5%8A%A0%E5%85%A5%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%82%E8%B5%9B%E8%80%85%EF%BC%8C%E6%B0%A8%E5%9F%BA%E9%85%B8%E5%BA%8F%E5%88%97%E4%BD%8D%E4%BA%8EUniProt%E6%9D%A1%E7%9B%AE%E7%9A%842-555%E4%BD%8D[P34913](https://www.uniprot.org/uniprotkb/P34913/entry#sequences)%EF%BC%8C%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%9C%A8[PDB%E6%9D%A1%E7%9B%AE3i28]%E4%B8%AD%E6%89%BE%E5%88%B0(https://www.rcsb.org/structure/3i28)%EF%BC%8C%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E5%9C%A8AlphaFold2%E6%9D%A1%E7%9B%AE[34913]%E4%B8%AD%E6%89%BE%E5%88%B0(https://alphafold.ebi.ac.uk/entry/P34913">购自开曼化学</a>. 在PDB中可以发现具有结合配体的额外的EPHX2&#x2F;sEH晶体结构。</p>
<h3 id="BRD4"><a href="#BRD4" class="headerlink" title="BRD4"></a><strong>BRD4</strong></h3><p>The second target, bromodomain 4, is encoded by the BRD4 locus and its protein product is also named BRD4. Bromodomains bind to protein spools in the nucleus that DNA wraps around (called histones) and affect the likelihood that the DNA nearby is going to be transcribed, producing new gene products. Bromodomains play roles in cancer progression and a number of drugs <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10096006/">have been discovered to inhibit their activities</a>.</p>
<p>BRD4 <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01670">has been screened with DEL approaches previously</a> but the screening data were not published. We included BRD4 to allow contestants to evaluate candidate molecules for oncology indications.</p>
<p>We screened BRD4 <a target="_blank" rel="noopener" href="https://www.activemotif.com/catalog/details/31594/recombinant-brd4-44-460-protein">purchased from Active Motif</a>, a life sciences commercial vendor. For those contestants wishing to incorporate protein structural information in their submissions, the amino acid sequence is positions 44-460 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/O60885/entry#sequences">O60885-1</a>, the crystal structure (for a single domain) can be found in PDB entry <a target="_blank" rel="noopener" href="https://www.rcsb.org/structure/7USK">7USK</a> and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/O60885">O60885</a>. Additional BRD4 crystal structures with ligands bound can be found in PDB.</p>
<h3 id="ALB-HSA"><a href="#ALB-HSA" class="headerlink" title="ALB (HSA)"></a><strong>ALB (HSA)</strong></h3><p>The third target, serum albumin, is encoded by the ALB locus and its protein product is also named ALB. The protein product is sometimes abbreviated as HSA, for “human serum albumin”. ALB, the most <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/books/NBK459198/">common protein in the blood</a>, is used to drive osmotic pressure (to bring fluid back from tissues into blood vessels) and to transport many ligands, hormones, fatty acids, and more.</p>
<p>Albumin, being the most abundant protein in the blood, often plays a role in absorbing candidate drugs in the body and sequestering them from their target tissues. Adjusting candidate drugs to bind less to albumin and other blood proteins <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acsptsci.2c00115">is a strategy to help these candidate drugs be more effective</a>.</p>
<p>ALB <a target="_blank" rel="noopener" href="https://pubmed.ncbi.nlm.nih.gov/25650139/">has been screened with DEL approaches previously</a> but the screening data were not published. We included ALB to allow contestants to build models that might have a larger impact on drug discovery across many disease types. The ability to predict ALB binding well would allow drug developers to improve their candidate small molecule therapies much more quickly than physically manufacturing many variants and testing them against ALB empirically in an iterative process.</p>
<p>We screened ALB <a target="_blank" rel="noopener" href="https://www.abcam.com/products/proteins-peptides/recombinant-human-serum-albumin-protein-his-tag-ab217817.html">purchased from Active Motif</a>. For those contestants wishing to incorporate protein structural information in their submissions, the amino acid sequence is positions 25 to 609 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/P02768/entry#sequences">P02768</a>, the crystal structure can be found in PDB entry <a target="_blank" rel="noopener" href="https://www.ebi.ac.uk/pdbe/entry/pdb/1AO6">1AO6</a>, and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/P02768">P02768</a>. Additional ALB crystal structures with ligands bound can be found in PDB.</p>
<p>Good luck!</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-07T12:22:34.000Z" title="2024/5/7 20:22:34">2024-05-07</time>发表</span><span class="level-item"><time dateTime="2024-05-27T02:24:04.468Z" title="2024/5/27 10:24:04">2024-05-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/">树(Tree)</a></span><span class="level-item">17 分钟读完 (大约2598个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/07/Tree/">Tree</a></p><div class="content"><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h2><p>[TOC]</p>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树是一种非常重要的非线性数据结构，树的一个节点可能会生出多个分支。一般而言，一棵树会包含一个根节点，向下延伸出若干子节点，每个末端的节点被称为叶子节点。<br><img src="/./Tree/Tree.png"></p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>有根树存在一个<strong>根节点Root</strong>，如下：<br><img src="/./Tree/RootTree.drawio.png"><br>对于图中概念的一些补充：</p>
<ul>
<li>节点拥有的子节点个数叫做节点的<strong>度</strong>。</li>
<li>具有相同深度的节点处于同一层，方便表示。</li>
<li>节点和节点之间的线叫做<strong>边</strong>。</li>
<li>路径：指从树上一点到另外一点所经过的<strong>不重合的</strong>点和边的集合，题目中有时会单指点或边的集合。</li>
<li>一颗 $n$ 个节点的树，一定有 $n-1$ 条边</li>
</ul>
<h4 id="无根树"><a href="#无根树" class="headerlink" title="无根树"></a>无根树</h4><hr>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>是一种<strong>特殊的树</strong>。</p>
<ul>
<li>所有节点的度都不超过2的树称为二叉树。</li>
<li>因为每个二叉树的节点最多只会有两个子结点，它的两个子节点一般会被称为左、右儿子，两棵子树一般会被称为左、右子树。</li>
<li>左、右儿子甚至根节点本身都有可能缺失（一个节点都没有可以称为空二叉树）。</li>
</ul>
<h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><p>二叉树也有两个比较特殊的类型：<strong>满二叉树和完全二叉树</strong>。<br><img src="/./Tree/FullBinaryTree.png"></p>
<ul>
<li><strong>满二叉树</strong>：所有层的节点全满。<ul>
<li>满二叉树的一些规律<ul>
<li>第 $n$ 层的节点个数为 $2^{n-1}$</li>
<li>深度为 $n$ 的满二叉树节点数为 $2^0 + 2^1 + 2^2 + \dots + 2^{n-1}&#x3D; 2^n-1$</li>
</ul>
</li>
</ul>
</li>
<li><strong>完全二叉树</strong>：除了最后一层以外，其他层的节点个数全满，而且最后一层的节点从左到右排满直到最后一个节点。<ul>
<li>完全二叉树的一些规律<ul>
<li>完全二叉树的节点个数不会少于 $(2^{n-1}-1)+1 &#x3D; 2^{n-1}$</li>
<li>完全二叉树的节点个数不会多于 $2^{n} - 1$</li>
<li>一棵完全二叉树，设当前节点为 $t$，其父节点为 $t&#x2F;2$，其左儿子为 $2t$，其右儿子为 $2t+1$，借助该规律，我们可以将完全二叉树使用数组进行存储。<br><img src="/./Tree/BinaryTree_NodeNumber.drawio.png"></li>
</ul>
</li>
</ul>
</li>
<li>完全二叉树的存储<ul>
<li>完全二叉树由于它的特性，可以简单用数组来模拟其结构</li>
<li>一般会以数组$[1]$位置为根节点建立二叉树</li>
<li>数组$[t]$位置的左儿子和右儿子对应的位置分别为$[2t]$和$[2t+1]$，父节点的位置为$[t&#x2F;2]$。</li>
<li>堆、线段树等数据结构的建立也会参考这个方式</li>
</ul>
</li>
</ul>
<p>完全二叉树的建立（使用数组），使用这种方法建立非完全二叉树，会导致空间的浪费：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="built_in">UpdateData</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子节点存在</span></span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">2</span> * t);</span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">2</span> * t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以使用其他方法来完成一般二叉树的存储，可以用数组下标模拟节点编号，用多个数组来记录节点信息。为了方便，我们也可以使用结构体来存储这些信息：<br><img src="/./Tree/NormalBinaryTree.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用结构体来实现上述操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> l, r, fa;</span><br><span class="line">&#125;a[<span class="number">100010</span>];</span><br></pre></td></tr></table></figure>
<p>当然，作为一种树形结构，使用指针显然是更合适的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针来实现上述操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode* l;</span><br><span class="line">    TreeNode* r;</span><br><span class="line">    TreeNode* fa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* root;</span><br></pre></td></tr></table></figure>
<p>使用指针的一些操作：</p>
<ul>
<li>新建节点：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode *l, *r, *fa;   <span class="comment">// 初始为 NULL</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)&#123; value = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br></pre></td></tr></table></figure></li>
<li>根节点初始化：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br></pre></td></tr></table></figure></li>
<li>插入节点：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(TreeNode* fa, TreeNode* p, <span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">// flag = 0 插入到左边</span></span><br><span class="line">    <span class="comment">// flag = 1 插入到右边</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">        fa-&gt;l = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa-&gt;r = p;</span><br><span class="line">    p-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line"><span class="built_in">Insert</span>(fa, treeNode, flag);</span><br></pre></td></tr></table></figure></li>
<li>删除节点  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 删除节点</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历可分为先序遍历、中序遍历和后序遍历，这三种方式以访问根节点的时间来区分。<br><strong>先序遍历（Degree-Left-Right, DLR）</strong>：根→左→右<br><strong>中序遍历（Left-Degree-Right, LDR）</strong>：左→根→右<br><strong>先序遍历（Left-Right-Degree, LRD）</strong>：左→右→根</p>
<!-- ![](./Tree/DLR_LDR_LRD.png) -->
<img src="./Tree/DLR_LDR_LRD.png" width=350px height=auto>

<p>在该图中，先序遍历的结果为 <code>1 2 4 5 3 6 7</code>，先序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">preOrder</span>(treeNode-&gt;l);</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">preOrder</span>(treeNode-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">preOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>在该图中，中序遍历的结果为 <code>4 2 5 1 6 3 7</code>，中序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">inOrder</span>(treeNode-&gt;l);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">inOrder</span>(treeNode-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>在该图中，后序遍历的结果为 <code>4 5 2 6 7 3 1</code>，后序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">postOrder</span>(treeNode-&gt;l);</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">postOrder</span>(treeNode-&gt;r);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">postOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>除了上述的几种遍历方式，还有层级遍历（BFS）方式对树进行遍历。层级遍历是借助队列（Queue）来实现的，其过程可以描述如下：<br><img src="/./Tree/BFSTree.png"></p>
<p>层级遍历的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">1</span>, rear = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear) &#123;</span><br><span class="line">        TreeNode* p = q[front];     <span class="comment">// 选取队列中最前面的节点</span></span><br><span class="line">        front++;</span><br><span class="line">        cout &lt;&lt; p-&gt;value &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;l)    q[++rear] = p-&gt;l;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;r)    q[++rear] = p-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(root);</span><br></pre></td></tr></table></figure>
<h4 id="计算节点的深度"><a href="#计算节点的深度" class="headerlink" title="计算节点的深度"></a>计算节点的深度</h4><p>我们可以在遍历树的时候同时进行节点深度的记录，简单来讲就是：<br>$$depth_{儿子} &#x3D; depth_{父亲} + 1$$</p>
<h3 id="有根树-Tree"><a href="#有根树-Tree" class="headerlink" title="有根树(Tree)"></a>有根树(Tree)</h3><p>这里不再是二叉树这种特殊的树，而是一般意义的树。</p>
<h4 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h4><ul>
<li><code>vector/链表</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector 方式</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nodes[N + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 x 和 y之间构建一条边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    nodes[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 x 的所有儿子</span></span><br><span class="line"><span class="type">int</span> l = nodes[x].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    nodes[x][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: nodes[x]) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> where;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *head[N + <span class="number">1</span>], a[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>], l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    a[++i].where = y;</span><br><span class="line">    a[l].next = head[x];</span><br><span class="line">    head[x] = &amp;a[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 x 的所有儿子</span></span><br><span class="line"><span class="keyword">for</span> (Node* p = head[x]; p; p-&gt;next) &#123;</span><br><span class="line">    p-&gt;where;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="有根树遍历"><a href="#有根树遍历" class="headerlink" title="有根树遍历"></a>有根树遍历</h4><p>遍历一棵树一般有 DFS 和 BFS 两种方式。<br><strong>DFS</strong>：深度优先搜索，从一个节点开始，选择一条路径并走到底，并通过回溯来访问所有节点。<br><strong>BFS</strong>：广度优先搜索，也称层级顺序探索，从一个节点开始，遍历该节点的所有子节点，或称按照深度从小到大的顺序依次遍历所有点。<br><img src="./Tree/RootTreeDFS.png" width=350px height=auto></p>
<ul>
<li><strong>有根树的DFS序</strong><br>有根树的 DFS 序是指，从根节点开始的深度优先搜索过程中，依次记录的点所生成的序列。<br>对于上图，所生成的 DFS 序即为 <code>ABCDEFGHIJKLMN</code>。当然这个只是其中一种 DFS 序，因为 <code>A</code> 可以走向 <code>B</code>，也可以走向 <code>E</code>，当然也可以走向 <code>F</code>。不同的走向会有不同的 DFS 序。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; dfn;      <span class="comment">// 用于存储 DFS 序, 常用 DFN 表示 DFS 序</span></span><br><span class="line">                      <span class="comment">// dfn 中的元素即为 DFS 序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="comment">// for x的所有儿子y &#123; dfs(y); &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (Node* p = x; p; p-&gt;next)&#123; <span class="built_in">dfs</span>(p-&gt;next) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(root);</span><br></pre></td></tr></table></figure></li>
<li><strong>有根树的BFS序</strong><br>有根树的 BFS 序是指，从根节点开始的广度优先搜索过程中，依次记录的点所生成的序列。<br>对于上图，所生成的 BFS 序即为 <code>ABENCDFMGJHIKL</code>。当然这个只是其中一种 BFS 序，因为同一深度可能会有不同的遍历顺序，如深度为 $2$ 时，<code>BEN</code>、<code>BNE</code>、<code>EBN</code>、…都是可能出现的顺序，不同的顺序会有不同的 BFS 序。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 root 加入队列 q;</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历队列 q</span></span><br><span class="line">    <span class="keyword">while</span>(队列 q 非空) &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>();    <span class="comment">// 取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();        <span class="comment">// x 出队</span></span><br><span class="line">        <span class="keyword">for</span> x的所有儿子y &#123;</span><br><span class="line">            y 入队;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="无根树-Unrooted-Tree"><a href="#无根树-Unrooted-Tree" class="headerlink" title="无根树(Unrooted Tree)"></a>无根树(Unrooted Tree)</h3><p>无根树即没有固定根结点的树，树中的节点只有相邻关系而没有父子关系。无根树有几种等价的形式化定义（建议搭配图论一起学习）：</p>
<ul>
<li>有 $n$ 个结点， $n−1$ 条边的连通无向图</li>
<li>无向无环的连通图</li>
<li>任意两个结点之间有且仅有一条简单路径的无向图</li>
<li>任何边均为桥的连通图</li>
<li>没有圈，且在任意不同两点间添加一条边之后所得图含唯一的一个圈的图</li>
</ul>
<p>如下图所示，即一棵无根树：<br><img src="./Tree/UnrootTree.png" width=350px height=auto><br>无根树中的任意一个节点可以被指定为根，变成一棵有根树。</p>
<h4 id="无根树的遍历"><a href="#无根树的遍历" class="headerlink" title="无根树的遍历"></a>无根树的遍历</h4><p>遍历一棵无根树一般也有 DFS 和 BFS 两种方式。<br>遍历无根树时，可以从任意一个节点开始，以类似有根树的方式，遍历整棵树。唯一的区别是在进入一个新节点时，需要记录这个节点的来源节点，在遍历新节点的相邻节点时，避免重复访问来源节点即可。</p>
<ul>
<li><strong>无根树的 DFS</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> x的所有响铃节点y &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">-1</span>, x);</span><br></pre></td></tr></table></figure></li>
<li><strong>无根树的 BFS</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 x 加入队列 q，x 的来源为空</span></span><br><span class="line">    <span class="keyword">while</span> (队列 q 非空) &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>();</span><br><span class="line">        from = x的来源节点;</span><br><span class="line">        q.pop;</span><br><span class="line">        <span class="keyword">for</span> x的所有相邻节点 y &#123;</span><br><span class="line">            <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">                y 入队;</span><br><span class="line">                记录 y 的来源节点为 x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(x);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><ul>
<li>树的直径是指树上任意两个节点之间最长（路径的长度一般指的是路径经过的边的数量）的路径。</li>
<li>一棵树可以存在很多条直径，他们的长度相等。</li>
<li>树的直径的中间节点被称为树的中心（图中C节点），如果直径上有偶数个节点，那么中间的两个节点都可以是树的中心。</li>
<li>树的中心到其它点的最长路径最短。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-07T12:06:30.000Z" title="2024/5/7 20:06:30">2024-05-07</time>发表</span><span class="level-item"><time dateTime="2024-05-22T12:07:12.232Z" title="2024/5/22 20:07:12">2024-05-22</time>更新</span><span class="level-item">10 分钟读完 (大约1450个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/07/Heap/">Heap</a></p><div class="content"><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>[TOC]</p>
<h3 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h3><h4 id="二叉堆的基本概念和基本性质"><a href="#二叉堆的基本概念和基本性质" class="headerlink" title="二叉堆的基本概念和基本性质"></a>二叉堆的基本概念和基本性质</h4><p>堆是一种树形结构，有二叉树就有二叉堆。</p>
<ul>
<li>二叉堆总是一棵完全二叉树</li>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>根节点的值为整个堆中的最小&#x2F;最大值。<ul>
<li>父节点中的值<strong>大于等于</strong>两个子节点中的值，根节点的值最大的堆称为<strong>大根堆</strong>。</li>
<li>父节点中的值<strong>小于等于</strong>两个子节点中的值，根节点的值最小的堆称为<strong>小根堆</strong>。</li>
</ul>
</li>
<li>我们可以在堆中插入和删除元素，然后通过调整元素的位置来维护堆的性质。</li>
</ul>
<h4 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h4><ul>
<li>堆的初始化<br>在建立堆之前，需要初始化一些东西：<ul>
<li>一个空数组，用于存储堆中的元素</li>
<li>一个记录堆中元素个数的变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heap[MAXSIZE + <span class="number">1</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>堆中元素的插入<br>堆在插入时，需要首先将插入元素放在数组末尾，然后插入元素不断的和其父节点比较，直到位置合适。下面是对小根堆插入过程的模拟：<br><img src="/./Heap/HeapInsert.png"><br>小根堆插入的代码如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; heap[k] &lt; heap[k/<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[k/<span class="number">2</span>]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
大根堆和小根堆插入元素的方式基本相同，只需要改变大于&#x2F;小于符号，插入操作的时间复杂度为 $O(log;n)$</li>
<li>堆顶元素的删除<br>堆最常用的功能就是<strong>维护最小&#x2F;最大值</strong>。在使用小根堆时，我们经常会求得最小的数字，然后让它出堆，这时就要从堆中删除堆顶数据。<br>这时除了堆顶为空，它的左子树堆和右子树堆仍满堆结构。为了操作简单，一般选择<strong>将堆尾部元素放到堆顶，然后将其逐步下移的方式</strong>，下移时，如进行交换操作，交换的是该节点左右儿子中较小的一个与该节点。<br>下图模拟小根堆删除堆顶元素的操作：<br><img src="/./Heap/HeapDelete.png"><br>小根堆删除元素的代码如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">        <span class="type">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k*<span class="number">2</span>+<span class="number">1</span> &lt; len &amp;&amp; heap[j+<span class="number">1</span>] &lt; heap[j])  j++;</span><br><span class="line">        <span class="keyword">if</span>(heap[k] &lt;= heap[j])  <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆中任意位置的删除<br>删除堆中的任意一个元素时，我们可以发现这个时候这个元素下的左子树堆和右子树堆也满足堆结构，但是我们不可以像删除堆顶节点一样，和数组尾部元素互换，然后尝试下移，原因如下：<br><img src="/./Tree/NormalHeapDelete.drawio.png"><br>此时无需向下调整，因为 $5&lt;8$ 且 $5&lt;9$，依旧满足小根堆的性质，但是其父节点 $6&gt;5$，破坏了小根堆的性质，因此此时需要上移。<br>所以我们删除堆中的任意一个元素，跟数组尾元素互换时，不仅要考虑下移，还有可能会上移。小根堆中删除一个位于数组位置 <code>pos</code> 的元素的代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == len) &#123;</span><br><span class="line">        heap[len] = <span class="number">0</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = heap[pos], y = heap[len];</span><br><span class="line">    <span class="built_in">swap</span>(heap[pos], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">        <span class="comment">// 堆尾的数比原数大, 尝试上移</span></span><br><span class="line">        <span class="built_in">up</span>(pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 堆尾的数比原数小, 尝试下移</span></span><br><span class="line">        <span class="built_in">down</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="STL-中的-priority-queue-优先队列"><a href="#STL-中的-priority-queue-优先队列" class="headerlink" title="STL 中的 priority_queue(优先队列)"></a>STL 中的 priority_queue(优先队列)</h3><p>STL 库中的 <code>priority_queue</code> 是一个很类似于堆的结构，它包含如下操作：</p>
<ul>
<li><code>empty</code> - 判断是否为空</li>
<li><code>size</code> - 返回队列内元素个数</li>
<li><code>top</code> - 访问队首元素</li>
<li><code>push</code> - 往队列中插入一个元素</li>
<li><code>pop</code> - 弹出队首元素</li>
</ul>
<p>这里的 <code>priority_queue</code> 相当于堆，队首元素相当于堆顶元素。<br>我们可以使用如下语句创建一个小根堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>这段C++语句创建了一个优先队列 <code>q</code>，其中元素类型为 <code>int</code>，底层容器使用 <code>vector&lt;int&gt;</code>，并且使用 <code>greater&lt;int&gt;</code> 作为比较器。在优先队列中，当元素被插入队列时，会根据比较器的规则进行排序，从而实现堆的性质。</p>
<p>在这段语句中，<code>greater&lt;int&gt;</code> 是一个函数对象，代表使用“大于”运算符进行比较。因此，当要创建一个小根堆时，即希望队列中的元素按照从小到大的顺序排列，可以利用 greater<int> 作为比较器，这样队列中的最小元素将位于队首。<br>同样的，我们可以使用如下语句创建一个大根堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法 1：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 写法 2：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code> 创建一个小根堆后，可以按以下方式操作这个小根堆：</p>
<ul>
<li>插入元素：使用 push() 方法将元素插入小根堆。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(<span class="number">5</span>); <span class="comment">// 插入元素5</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 插入元素3</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">7</span>); <span class="comment">// 插入元素7</span></span><br></pre></td></tr></table></figure></li>
<li>获取堆顶元素：使用 top() 方法获取小根堆的头部元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> topElement = q.<span class="built_in">top</span>(); <span class="comment">// 获取小根堆的头部元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Top element of the min heap: &quot;</span> &lt;&lt; topElement &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li>删除堆顶元素：使用 pop() 方法删除小根堆顶部的元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 删除小根堆的头部元素</span></span><br></pre></td></tr></table></figure></li>
<li>查看堆是否为空：使用 empty() 方法检查小根堆是否为空。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min heap is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min heap is not empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarMyself.jpg" alt="NilEra"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">NilEra</p><p class="is-size-6 is-block">C/C++ Developer!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jinan Shandong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">25</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/NilEra-K" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/NilEra-K" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://nano.chemtian.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Thymol Blue</span></span><span class="level-right"><span class="level-item tag">nano.chemtian.top</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CppDev/"><span class="level-start"><span class="level-item">CppDev</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/QT6/"><span class="level-start"><span class="level-item">QT6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="level-start"><span class="level-item">软件源</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">大数据技术</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/"><span class="level-start"><span class="level-item">ECharts</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/"><span class="level-start"><span class="level-item">HBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Axure-RP-9/"><span class="level-start"><span class="level-item">Axure RP 9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构/算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/"><span class="level-start"><span class="level-item">哈希(Hash)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/"><span class="level-start"><span class="level-item">栈(Stack)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/"><span class="level-start"><span class="level-item">树(Tree)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"><span class="level-start"><span class="level-item">PyTorch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/"><span class="level-start"><span class="level-item">闲聊</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/%E8%AE%A1%E5%88%92/"><span class="level-start"><span class="level-item">计划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-12T07:13:57.000Z">2024-06-12</time></p><p class="title"><a href="/2024/06/12/SparkQuickIN/">SparkQuickIN</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/">Spark</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-11T08:03:22.000Z">2024-06-11</time></p><p class="title"><a href="/2024/06/11/OnlineTravelBigdataPlatform/">OnlineTravelBigdataPlatform</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-10T09:32:28.000Z">2024-06-10</time></p><p class="title"><a href="/2024/06/10/ScalaQuickIN/">ScalaQuickIN</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-02T14:43:53.000Z">2024-06-02</time></p><p class="title"><a href="/2024/06/02/QuickPassHBase/">QuickPassHBase</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-27T10:18:43.000Z">2024-05-27</time></p><p class="title"><a href="/2024/05/27/Evaluation-Indicators-in-AI/">Evaluation Indicators in AI</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Axure-RP-9/"><span class="tag">Axure RP 9</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CppDev/"><span class="tag">CppDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECharts/"><span class="tag">ECharts</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kaggle/"><span class="tag">Kaggle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QT6/"><span class="tag">QT6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tomcat/"><span class="tag">Tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="tag">大数据技术</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E5%88%92/"><span class="tag">计划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="tag">软件源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%B2%E8%81%8A/"><span class="tag">闲聊</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE/"><span class="tag">项目</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a><p class="is-size-7"><span>&copy; 2024 NilEra</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024 前方⚡高能</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdnjs.loli.net/ajax/libs/algoliasearch/4.0.3/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdnjs.loli.net/ajax/libs/instantsearch.js/4.3.1/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"2TB5ZZYPCO","apiKey":"00a43f1d62ca7b24c8b78d5f0223c065","indexName":"dev_nilera_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>