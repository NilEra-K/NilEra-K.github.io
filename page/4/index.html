<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>Hello, NilEra :-)</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hello, NilEra :-)"><meta name="msapplication-TileImage" content="/img/StarLogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hello, NilEra :-)"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="努力做自己喜欢的事"><meta property="og:type" content="blog"><meta property="og:title" content="Hello, NilEra :-)"><meta property="og:url" content="https://hello-nilera.com/"><meta property="og:site_name" content="Hello, NilEra :-)"><meta property="og:description" content="努力做自己喜欢的事"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hello-nilera.com/img/og_image.png"><meta property="article:author" content="NilEra"><meta property="article:tag" content="Hello NilEra"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hello-nilera.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hello-nilera.com"},"headline":"Hello, NilEra :-)","image":["https://hello-nilera.com/img/og_image.png"],"author":{"@type":"Person","name":"NilEra"},"publisher":{"@type":"Organization","name":"Hello, NilEra :-)","logo":{"@type":"ImageObject","url":"https://hello-nilera.com/img/StarLogo.svg"}},"description":"努力做自己喜欢的事"}</script><link rel="icon" href="/img/StarLogo.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?249654dcf9a3bf70708fdfc6e2b1ec2b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="F6BD78C6BD0096D2218CF88334111125"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/me">我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-02T14:43:53.000Z" title="2024/6/2 22:43:53">2024-06-02</time>发表</span><span class="level-item"><time dateTime="2024-07-07T13:04:01.539Z" title="2024/7/7 21:04:01">2024-07-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/">HBase</a></span><span class="level-item">1 小时读完 (大约6723个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/02/QuickPassHBase/">QuickPassHBase</a></p><div class="content"><h2 id="快速上手HBase"><a href="#快速上手HBase" class="headerlink" title="快速上手HBase"></a>快速上手HBase</h2><p>[TOC]</p>
<h3 id="⚙-1-HBase简介"><a href="#⚙-1-HBase简介" class="headerlink" title="⚙ 1. HBase简介"></a>⚙ 1. HBase简介</h3><h4 id="1-1-HBase的定义"><a href="#1-1-HBase的定义" class="headerlink" title="1.1 HBase的定义"></a>1.1 HBase的定义</h4><p><strong>Apache HBase</strong> 是以 HDFS 为数据存储的，一种分布式、可扩展的 NoSQL 数据库。</p>
<p>HBase 的设计理念依据 Google 的 BigTable 论文，论文中对于数据模型的首句介绍。</p>
<p><strong>BigTable是一个稀疏的、分布式的、持久的多维排序映射(Map)。该映射由行键、列键和时间戳索引作为键(Key)，映射中的每个值(Value)都是一个未解释的字节数组。</strong></p>
<p>HBase 使用与 BigTable 非常相似的数据模型。用户将数据行存储在带标签的表中。数据行具有可排序的键和任意数量的列。该表存储稀疏，因此如果用户喜欢，同一表中的行可以具有疯狂变化的列。</p>
<h4 id="1-2-HBase的数据模型"><a href="#1-2-HBase的数据模型" class="headerlink" title="1.2 HBase的数据模型"></a>1.2 HBase的数据模型</h4><h5 id="1-2-1-HBase-的逻辑结构"><a href="#1-2-1-HBase-的逻辑结构" class="headerlink" title="1.2.1 HBase 的逻辑结构"></a>1.2.1 HBase 的逻辑结构</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;row_key1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;personal_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZhangSan&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;156****0000&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;office_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;tel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010-1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shandong&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;row_key11&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;personal_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;133****0000&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;office_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;tel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;010-1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;row_key2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>列族→</td>
        <td colspan="3">personal_info</td> 
        <td colspan="3">office_info</td> 
    </tr>
    <tr>
        <td>RowKey↓</td>
        <td>name</td> 
        <td>city</td>
        <td>phone</td>
        <td>tel</td>
        <td>address</td>
    </tr>
    <tr>
        <td>row_key1</td>
        <td>ZhangSan</td> 
        <td>Beijing</td>
        <td>156****0000</td>
        <td>010-1234567</td>
        <td>Shandong</td>
    </tr>
    <tr>
        <td>row_key11</td>
        <td></td> 
        <td>Shanghai</td>
        <td>131****0000</td>
        <td>010-1234567</td>
        <td></td>
    </tr>
    <tr>
        <td>row_key2</td>
        <td>...</td> 
        <td>...</td>
        <td>...</td>
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>在上面的表格中：</p>
<ul>
<li><code>personal_info</code>、<code>office_info</code>称为<strong>列族</strong></li>
<li><code>name</code>、<code>city</code>、<code>phone</code>、<code>tel</code>、<code>address</code>称为<strong>列</strong></li>
<li><code>row_key1</code>、<code>row_key11</code>称为<strong>行键</strong>。</li>
<li>将一整张大表按照<strong>行</strong>进行拆分，拆分为多个表，拆分后的每个表称为**块(Region)**，用于实现分布式结构。</li>
<li>将一整张大表按照<strong>列族</strong>进行拆分，拆分为多个**存储(Store)**，用于在底层存储到不同的文件夹中，便于文件对应。</li>
</ul>
<p>存储数据<strong>稀疏</strong>，数据存储<strong>多维</strong>，不同的行具有不同的列。数据存储整体有序，按照RowKey的字典序排列，RowKey为一个Byte数组。</p>
<h5 id="1-2-2-HBase-的物理结构"><a href="#1-2-2-HBase-的物理结构" class="headerlink" title="1.2.2 HBase 的物理结构"></a>1.2.2 HBase 的物理结构</h5><p>物理存储结构即为数据映射关系，而在概念视图的空单元格，底层实际根本不存储。</p>
<p>在HDFS中划分好的存储Store如下：</p>
<table>
    <tr>
        <td></td>
        <td colspan="3">personal_info</td> 
    </tr>
    <tr>
        <td>RowKey</td>
        <td>name</td> 
        <td>city</td>
        <td>phone</td>
    </tr>
    <tr>
        <td>row_key1</td>
        <td>ZhangSan</td> 
        <td>Beijing</td>
        <td>156****0000</td>
    </tr>
    <tr>
        <td>row_key11</td>
        <td></td> 
        <td>Shanghai</td>
        <td>131****0000</td>
    </tr>
    <tr>
        <td>row_key2</td>
        <td>...</td> 
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>其底层一定是以映射(Map)的方式进行存储的，格式为**<code>(Key, Value)</code><strong>，<code>Value</code>一定是</strong>“ZhangSan”**这种字段。那么<code>Key</code>是什么呢？</p>
<p>为了确定<code>Value</code>值**”ZhangSan”<strong>，我们需要用</strong>Key<strong>对应到</strong>Value**，于是得到存储如下：</p>
<table>
<thead>
<tr>
<th>Row Key</th>
<th>Column Family</th>
<th>Column Qualifier</th>
<th>Timestamp</th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>row_key1</td>
<td>personal_info</td>
<td>name</td>
<td>t1</td>
<td>Put</td>
<td>ZhangSan</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>city</td>
<td>t2</td>
<td>Put</td>
<td>Beijing</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t3</td>
<td>Put</td>
<td>156****0000</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t4</td>
<td>Put</td>
<td>156****0001</td>
</tr>
<tr>
<td>row_key1</td>
<td>personal_info</td>
<td>phone</td>
<td>t5</td>
<td>Delete</td>
<td>156****0001</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>因为 HDFS 是无法修改数据的，而 HBase 需要修改数据，那么就需要解决这一问题，于是就有了**时间戳(Timestamp)**。不同版本（version）的数据根据 <strong>Timestamp</strong> 进行区分，读取数据默认读取最新的版本。</p>
<p>在上面的表格中，<code>t4</code>相对于<code>t3</code>来说就是进行了修改，将<code>t3</code>时的**<code>phone</code><strong>从<code>156****0000</code>修改为<code>t4</code>时的<code>156****0001</code>，读取时默认读取<code>t4</code>时的</strong><code>phone</code>**值，通过这种方式完成了修改。</p>
<p>同样的，我们也不好删除数据，因此我们只需要插入一条**<code>Type</code>**为<code>Delete</code>的数据即可。</p>
<h5 id="1-2-3-数据模型"><a href="#1-2-3-数据模型" class="headerlink" title="1.2.3 数据模型"></a>1.2.3 数据模型</h5><ul>
<li><p><strong>Name Space</strong> 命名空间</p>
<p>类似于关系型数据库的 <strong>Database</strong> 概念，每个命名空间下有多个表。HBase 两个自带的命名空间，分别是 <code>hbase</code> 和<code>default</code>，<code>hbase</code> 中存放的是 HBase 内置的表，<code>default</code>表是用户默认使用的命名空间。</p>
</li>
<li><p><strong>Table</strong></p>
<p>类似于关系型数据库的<strong>表</strong>概念。不同的是，HBase 定义表时<strong>只需要声明列族</strong>即可，<strong>不需要声明具体的列</strong>。因为数据存储时稀疏的，所有往HBase写入数据时，字段<strong>可以动态、按需指定</strong>。因此，和关系型数据库相比，HBase能够轻松应对字段变更的场景。</p>
<p>需要注意的是，<strong>列族</strong>的存在是<strong>动态</strong>添加列（或称字段）的基础。</p>
</li>
<li><p><strong>Row</strong></p>
<p>HBase 表中的每行数据都由<em>*一个行键(RowKey)<strong>和</strong>多个列(Column)<strong>组成，数据是按照 RowKey的字典顺序存储的，</strong>*并且查询数据时只能根据 RowKey进行检索</em>**，所以RowKey的设计十分重要。</p>
</li>
<li><p><strong>Column</strong></p>
<p>HBase 中的每个列都由<strong>列族(Column Family)<strong>和</strong>列限定符(Column Qualifier)<strong>进行限定，例如<code>info:name, info:age</code>。建表时，只需指明列族，而</strong>列限定符无需预先定义</strong>。列限定符听起来很高端，其实就是列名的意思。</p>
</li>
<li><p><strong>Time Stamp</strong></p>
<p>用于标识数据的**不同版本(Version)**，每条数据写入时，系统会自动为其加上该字段，其值为写入 HBase 的时间。</p>
</li>
<li><p><strong>Cell</strong></p>
<p>由 <code>&#123;rowkey, Column Family: Column Qualifier, Timestamp&#125;</code> 唯一确定的单元，<code>Cell</code> 中的数据全部是字节码形式存储。</p>
</li>
</ul>
<h4 id="1-3-HBase-基本架构"><a href="#1-3-HBase-基本架构" class="headerlink" title="1.3 HBase 基本架构"></a>1.3 HBase 基本架构</h4><img src="./QuickPassHBase/HBaseStructure.png" alt="HBase基本架构" style="zoom:33%;" />

<ul>
<li><p><strong>Master</strong></p>
<p><strong>主要进程</strong>，具体实现类为<code>HMaster</code>，通常部署在<code>NameNode</code>上。</p>
<p><strong>主要功能</strong>：负责通过 <code>ZK</code> 监控 <code>RegionServer</code> 进程状态，同时是所有元数据变化的接口，内部启动监控执行 <code>region</code> 的故障转移和拆分的线程。</p>
<p><strong>功能的详细描述</strong>：</p>
<ul>
<li><p>管理元数据表格 <code>hbase:meta</code>：接收用户对表格创建、修改、删除的命令并执行。</p>
</li>
<li><p>监控 <code>RegionServer</code> 是否需要进行<strong>负载均衡</strong>、<strong>故障转移</strong>和<strong>Region拆分</strong>。通过启动多个后台线程监控实现上述功能：</p>
<ul>
<li><p><code>LoadBalancer</code> 负载均衡器</p>
<p>周期性监控 <code>region</code>分布在 <code>RegionServer</code> 上面是否均衡，由参数 <code>hbase.balancer.period</code>控制周期时间，默认5分钟。</p>
</li>
<li><p><code>CatalogJanitor</code>元数据管理器</p>
<p>定期检查和清理<code>hbase:meta</code>中的数据。</p>
</li>
<li><p><code>MasterProcWAL</code> Master 预写日志处理器</p>
<p>把Master需要执行的任务记录到预写日志WAL中，如果Master宕机，则让BackupMaster继续操作。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RegionServer</strong></p>
<p><strong>主要进程</strong>，具体实现类为<code>HRegionServer</code>，通常部署在<code>DataNode</code>上。</p>
<p><strong>功能</strong>：主要负责数据 <code>Cell</code> 的处理，同时在执行区域的拆分和合并的时候，由 <code>RegionServer</code> 来实际执行。</p>
<p><strong>功能的详细描述</strong>：</p>
<ul>
<li>负责数据 <code>Cell</code> 的处理，例如写入数据<code>put</code>，查询数据<code>get</code>等。</li>
<li>拆分合并 <code>region</code> 的实际执行者，有 <strong>Master</strong> 监控，有<code>RegionServer</code> 执行。</li>
</ul>
</li>
<li><p><strong>ZooKeeper</strong></p>
<p>HBase 通过 <code>ZooKeeper</code> 来做 <code>Master</code>的高可用、记录 <code>RegionServer</code> 的部署信息、并且存储有 <code>meta</code> 表的位置信息。<br>HBase 对于数据的读写操作时是直接访问 <code>ZooKeeper</code> 的，在 2.3 版本推出 <code>Master Registry</code> 模式，客户端可以直接访问 <code>Master</code>。使用此功能，会加大对 <code>Master</code>的压力，减轻对 <code>ZooKeeper</code> 的压力。</p>
</li>
<li><p><strong>HDFS</strong></p>
<p><code>HDFS</code> 为 HBase 提供最终的底层数据存储服务，同时为 HBase 提供高容错的支持。</p>
</li>
</ul>
<p>上图中的<code>Region</code>由三个<code>RegionServer</code>随机管理，尽量均衡。表名<code>hbase:meta</code>是一个特例，他存储在<strong>HDFS</strong>，但是由<strong>Master</strong>管理。</p>
<h3 id="🔧-2-快速上手"><a href="#🔧-2-快速上手" class="headerlink" title="🔧 2. 快速上手"></a>🔧 2. 快速上手</h3><h4 id="2-1-安装部署"><a href="#2-1-安装部署" class="headerlink" title="2.1 安装部署"></a>2.1 安装部署</h4><h5 id="2-1-1-分布式部署"><a href="#2-1-1-分布式部署" class="headerlink" title="2.1.1 分布式部署"></a>2.1.1 分布式部署</h5><ol>
<li><p>至少 3 台虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101</span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证 <strong>ZooKeeper</strong> 正常部署，并且启动 <strong>ZooKeeper</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证 <strong>Hadoop</strong> 正常部署，并且启动 <strong>Hadoop</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <strong>HBase</strong> 环境</p>
<p>① 下载 HBase 安装包（压缩包），这里假设为<code>hbase-2.4.11-bin.tar.gz</code></p>
<p>② 解压 HBase 安装包到一个文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /path/to/hbase-2.4.11-bin.tar.gz -C /path/to/module</span><br></pre></td></tr></table></figure>

<p>③ 在用户目录下，添加用户环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#HBase_HOME</span></span><br><span class="line"><span class="built_in">export</span> HBASE_HOME = /path/to/module/hbase-2.4.11</span><br><span class="line"><span class="built_in">export</span> PATH = <span class="variable">$PATH</span>:<span class="variable">$HBASE_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>④ 使环境变量生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure>

<p>⑤ 修改配置文件</p>
<ul>
<li><p><code>hbase-env.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示是否需要 HBase 管理维护一个自带的 ZooKeeper, 默认为 true</span></span><br><span class="line"><span class="comment"># 我们需要使用本机已经配置好的 ZooKeeper, 所以修改为 False</span></span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hbase-site.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101,hadoop102,hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase数据在HDFS中的存放路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop101:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase的运行模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- false为单机模式, HBase和ZooKeeper会运行在同一个JVM虚拟机中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- true 为分布式模式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper快照的存储位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里替换为自己的 /path/to/ZooKeeperDir --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/zookeeper-3.4.6/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- HBase 安全模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在分布式模式下, 设置为 false --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>regionservers</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101</span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br></pre></td></tr></table></figure></li>
</ul>
<p>⑥ 解决 <code>log4j</code> 不兼容的问题，移除 <code>HBase</code>或者 <code>Hadoop</code>的 <code>.jar</code>包</p>
<p>⑦ 使用 <code>scp</code> 命令同步 HBase 配置，需要提前设置好免密登录。或者使用 <code>xsync</code></p>
</li>
<li><p>启动 HBase 服务</p>
<ul>
<li><p>单点启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单点启动HMaster</span></span><br><span class="line">hbase-daemon.sh start master</span><br><span class="line"><span class="comment">#单点启动HRegionServer</span></span><br><span class="line">hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>集群启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="2-1-2-高可用服务"><a href="#2-1-2-高可用服务" class="headerlink" title="2.1.2 高可用服务"></a>2.1.2 高可用服务</h5><ol>
<li><p>如果 HBase 已经启动，先关闭HBase</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件 <code>backup-masters</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用touch命令或者echo命令均可</span></span><br><span class="line"><span class="built_in">touch</span> /path/to/hbase-2.1.4/conf/backup-masters</span><br><span class="line">vim /path/to/hbase-2.1.4/conf/backup-masters</span><br></pre></td></tr></table></figure>

<p>添加内容：<code>hadoop102</code></p>
</li>
<li><p>使用 <code>scp</code> 命令分发配置文件</p>
</li>
<li><p>启动HBase，正常启动进程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop101 -&gt; HMaster HRegionServer</span><br><span class="line">hadoop102 -&gt; HMaster HRegionServer</span><br><span class="line">hadoop103 -&gt; HRegionServer</span><br></pre></td></tr></table></figure>

<p>其中，<code>hadoop101</code> 的 <code>HMaster</code> 先启动作为主节点，<code>hadoop102</code> 的 <code>HMaster</code>后启动，作为**备用节点(Backup-Master)**。</p>
</li>
</ol>
<h4 id="2-2-使用操作"><a href="#2-2-使用操作" class="headerlink" title="2.2 使用操作"></a>2.2 使用操作</h4><h5 id="2-2-1-Shell操作"><a href="#2-2-1-Shell操作" class="headerlink" title="2.2.1 Shell操作"></a>2.2.1 Shell操作</h5><p>使用命令 <code>hbase shell</code> 启动 HBase 的 <code>Shell</code> 命令界面，所有命令均可以使用 <code>help</code> 查到。</p>
<p>当我们在 <code>hbase shell</code>中输入<code>help</code>命令时，将会弹出HBase的使用提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; help</span><br><span class="line">HBase Shell, version 2.1.8, rd8333e556c8ed739cf39dab58ddc6b43a50c0965, Tue Nov 19 15:29:04 UTC 2019</span><br><span class="line">Type &#x27;help &quot;COMMAND&quot;&#x27;, (e.g. &#x27;help &quot;get&quot;&#x27; -- the quotes are necessary) for help on a specific command.</span><br><span class="line">Commands are grouped. Type &#x27;help &quot;COMMAND_GROUP&quot;&#x27;, (e.g. &#x27;help &quot;general&quot;&#x27;) for help on a command group.</span><br><span class="line"></span><br><span class="line">COMMAND GROUPS:</span><br><span class="line">  Group name: general</span><br><span class="line">  Commands: processlist, status, table_help, version, whoami</span><br><span class="line"></span><br><span class="line">  Group name: ddl</span><br><span class="line">  Commands: alter, alter_async, alter_status, clone_table_schema, create, describe, disable, disable_all, drop, drop_all, enable, enable_all, exists, get_table, is_disabled, is_enabled, list, list_regions, locate_region, show_filters</span><br><span class="line"></span><br><span class="line">  Group name: namespace</span><br><span class="line">  Commands: alter_namespace, create_namespace, describe_namespace, drop_namespace, list_namespace, list_namespace_tables</span><br><span class="line"></span><br><span class="line">  Group name: dml</span><br><span class="line">  Commands: append, count, delete, deleteall, get, get_counter, get_splits, incr, put, scan, truncate, truncate_preserve</span><br><span class="line"></span><br><span class="line">  Group name: tools</span><br><span class="line">  Commands: assign, balance_switch, balancer, balancer_enabled, catalogjanitor_enabled, catalogjanitor_run, catalogjanitor_switch, cleaner_chore_enabled, cleaner_chore_run, cleaner_chore_switch, clear_block_cache, clear_compaction_queues, clear_deadservers, close_region, compact, compact_rs, compaction_state, flush, hbck_chore_run, is_in_maintenance_mode, list_deadservers, major_compact, merge_region, move, normalize, normalizer_enabled, normalizer_switch, split, splitormerge_enabled, splitormerge_switch, stop_master, stop_regionserver, trace, unassign, wal_roll, zk_dump</span><br><span class="line"></span><br><span class="line">  Group name: replication</span><br><span class="line">  Commands: add_peer, append_peer_exclude_namespaces, append_peer_exclude_tableCFs, append_peer_namespaces, append_peer_tableCFs, disable_peer, disable_table_replication, enable_peer, enable_table_replication, get_peer_config, list_peer_configs, list_peers, list_replicated_tables, remove_peer, remove_peer_exclude_namespaces, remove_peer_exclude_tableCFs, remove_peer_namespaces, remove_peer_tableCFs, set_peer_bandwidth, set_peer_exclude_namespaces, set_peer_exclude_tableCFs, set_peer_namespaces, set_peer_replicate_all, set_peer_serial, set_peer_tableCFs, show_peer_tableCFs, update_peer_config</span><br><span class="line"></span><br><span class="line">  Group name: snapshots</span><br><span class="line">  Commands: clone_snapshot, delete_all_snapshot, delete_snapshot, delete_table_snapshots, list_snapshots, list_table_snapshots, restore_snapshot, snapshot</span><br><span class="line"></span><br><span class="line">  Group name: configuration</span><br><span class="line">  Commands: update_all_config, update_config</span><br><span class="line"></span><br><span class="line">  Group name: quotas</span><br><span class="line">  Commands: list_quota_snapshots, list_quota_table_sizes, list_quotas, list_snapshot_sizes, set_quota</span><br><span class="line"></span><br><span class="line">  Group name: security</span><br><span class="line">  Commands: grant, list_security_capabilities, revoke, user_permission</span><br><span class="line"></span><br><span class="line">  Group name: procedures</span><br><span class="line">  Commands: list_locks, list_procedures</span><br><span class="line"></span><br><span class="line">  Group name: visibility labels</span><br><span class="line">  Commands: add_labels, clear_auths, get_auths, list_labels, set_auths, set_visibility</span><br><span class="line"></span><br><span class="line">  Group name: rsgroup</span><br><span class="line">  Commands: add_rsgroup, balance_rsgroup, get_rsgroup, get_server_rsgroup, get_table_rsgroup, list_rsgroups, move_namespaces_rsgroup, move_servers_namespaces_rsgroup, move_servers_rsgroup, move_servers_tables_rsgroup, move_tables_rsgroup, remove_rsgroup, remove_servers_rsgroup</span><br><span class="line"></span><br><span class="line">SHELL USAGE:</span><br><span class="line">Quote all names in HBase Shell such as table and column names.  Commas delimit</span><br><span class="line">command parameters.  Type &lt;RETURN&gt; after entering a command to run it.</span><br><span class="line">Dictionaries of configuration used in the creation and alteration of tables are</span><br><span class="line">Ruby Hashes. They look like this:</span><br><span class="line"></span><br><span class="line">  &#123;&#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;, ...&#125;</span><br><span class="line"></span><br><span class="line">and are opened and closed with curley-braces.  Key/values are delimited by the</span><br><span class="line">&#x27;=&gt;&#x27; character combination.  Usually keys are predefined constants such as</span><br><span class="line">NAME, VERSIONS, COMPRESSION, etc.  Constants do not need to be quoted.  Type</span><br><span class="line">&#x27;Object.constants&#x27; to see a (messy) list of all constants in the environment.</span><br><span class="line"></span><br><span class="line">If you are using binary keys or values and need to enter them in the shell, use</span><br><span class="line">double-quote&#x27;d hexadecimal representation. For example:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\x03\x3f\xcd&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">get <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;key\003\023\011&quot;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">put <span class="string">&#x27;t1&#x27;</span>, <span class="string">&quot;test\xef\xff&quot;</span>, <span class="string">&#x27;f1:&#x27;</span>, <span class="string">&quot;\x01\x33\x40&quot;</span></span></span><br><span class="line"></span><br><span class="line">The HBase shell is the (J)Ruby IRB with the above HBase-specific commands added.</span><br><span class="line">For more on the HBase Shell, see http://hbase.apache.org/book.html</span><br></pre></td></tr></table></figure>

<p>根据上述信息，我们可以进一步的操作 HBase 数据库。我们实际开发中常用的**命令组(COMMAND GROUPS)**有：<code>general</code>、<code>namespace</code>、<code>ddl</code>、<code>dml</code>等，下面依次介绍这些内容：</p>
<ul>
<li><p><strong>通用命令 <code>general</code></strong></p>
<ul>
<li><p>查看 HBase 状态 <code>status</code>，提供 HBase 的状态，如服务器的数量等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; status</span><br><span class="line">1 active master, 0 backup masters, 1 servers, 0 dead, 4.0000 average load</span><br><span class="line">Took 0.5268 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 HBase 版本 <code>version</code>，提供正在使用 HBase 版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; version</span><br><span class="line">2.1.8, rd8333e556c8ed739cf39dab58ddc6b43a50c0965, Tue Nov 19 15:29:04 UTC 2019</span><br><span class="line">Took 0.0002 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>表引用命令提供帮助 <code>table_help</code></p>
</li>
<li><p>提供有关用户的信息 <code>whoami</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; whoami</span><br><span class="line">nilera (auth:SIMPLE)</span><br><span class="line">    groups: nilera</span><br><span class="line">Took 0.0283 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>操作命名空间 <code>Namespace</code></strong></p>
<p>**命名空间(Namespace)**，相当于MySQL数据库中的DataBase。<code>Namespace</code> 命令包括：<code>alter namespace</code>、<code>create_namespace</code>、<code>describe_namespace</code>、<code>drop_namespace</code>、<code>list_namespace</code>、<code>list_namespace_tables</code>。下面将对一些常用命令进行介绍：</p>
<ul>
<li><p>查看全部命名空间 <code>list_namespace</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.5484 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建命名空间 <code>create_namespace</code></p>
<p>用法：<code>create_namespace &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create_namespace &#x27;bigdata&#x27;</span><br><span class="line">Took 0.0432 seconds</span><br><span class="line">hbase(main):002:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">bigdata</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0224 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除命名空间 <code>drop_namespace</code></p>
<p>用法：<code>drop_namespace &#39;ns&#39;</code>，删除命名空间时，命名空间必须为空。</p>
</li>
<li><p>查看命名空间 <code>describe_namespace</code></p>
<p>用法：<code>describe_namespace &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; describe_namespace &#x27;bigdata&#x27;</span><br><span class="line">DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;bigdata&#x27;&#125;</span><br><span class="line">Took 0.0068 seconds</span><br><span class="line">=&gt; 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看命名空间下的表 <code>list_namespace_tables</code></p>
<p>用法：<code>list_namespace_tables &#39;ns&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace_tables &#x27;default&#x27;</span><br><span class="line">TABLE</span><br><span class="line">logs</span><br><span class="line">user</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.3790 seconds</span><br><span class="line">=&gt; [&quot;logs&quot;, &quot;user&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据定义语言 <code>ddl</code></strong></p>
<p><strong>DDL(Data Definition Language)数据定义语言</strong>，主要是进行定义&#x2F;改变表的结构、数据类型、表之间的链接等操作。<code>ddl</code> 相关命令如下：<code>alter</code>、<code>alter_async</code>、<code>alter_status</code>、<code>clone_table_schema</code>、<code>create</code>、<code>describe</code>、<code>disable</code>、<code>disable_all</code>、<code>drop</code>、<code>drop_all</code>、<code>enable</code>、<code>enable_all</code>、<code>exists</code>、<code>get_table</code>、<code>is_disabled</code>、<code>is_enabled</code>、<code>list</code>、<code>list_regions</code>、<code>locate_region</code>、<code>show_filters</code>。下面将对一些常用命令进行介绍：</p>
<ul>
<li><p>创建表 <code>create</code></p>
<p><strong>常见用法：</strong></p>
<p>① <code>create &#39;ns:tb&#39;, &#123;NAME =&gt; &#39;cf&#39;, VERSIONS =&gt; 5&#125;</code></p>
<p>​	在命名空间 <code>ns</code> 下，创建一张表 <code>tb</code>，定义一个列族 <code>cf</code>。</p>
<p>② 当在默认命名空间<code>default</code>下创建表时，可以省略 <code>ns</code></p>
<p>③ <code>create &#39;tb&#39;, &#39;cf1&#39;, &#39;cf2&#39;</code></p>
<p>​	在默认命名空间<code>default</code>下，创建一张表<code>tb</code>，并定义两个列族 <code>cf1</code>、<code>cf2</code></p>
<p>④ <code>create &#39;tb&#39;, &#123;NAME =&gt; &#39;cf1&#39;, VERSIONS =&gt; 5&#125;, &#123;NAME =&gt; &#39;cf2&#39;, VERSIONS =&gt; 5&#125;</code></p>
<p>​	在默认命名空间<code>default</code>下，创建一张表<code>tb</code>，并定义两个列族 <code>cf1</code>、<code>cf2</code>，并同时指定两个列族的版本为 <code>5</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create &#x27;bigdata:person&#x27;, &#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; 5&#125;, &#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; 5&#125;</span><br><span class="line">Created table bigdata:person</span><br><span class="line">Took 1.5638 seconds</span><br><span class="line">=&gt; Hbase::Table - bigdata:person</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表的详细信息 <code>describe</code></p>
<p><strong>用法</strong>：<code>describe &#39;tb&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.1536 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表 <code>alter</code></p>
<p>表名创建时写的所有和列族相关的信息，都可以后续通过<code>alter</code>修改，包括<strong>增加</strong>、<strong>删除</strong>列族。</p>
<p>① 增加列族和修改信息都使用覆盖的方法</p>
<p>​	修改列族的版本，<code>VERSIONS =&gt; 6</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; 6</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 4.0145 seconds</span><br></pre></td></tr></table></figure>

<p>​	添加列族 <code>tel</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;tel&#x27;, VERSIONS =&gt; 6</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.4498 seconds</span><br></pre></td></tr></table></figure>

<p>​	查看修改后的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;msg&#x27;, VERSIONS =&gt; &#x27;6&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&#123;NAME =&gt; &#x27;tel&#x27;, VERSIONS =&gt; &#x27;6&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fal</span><br><span class="line">se&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN</span><br><span class="line">_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0795 seconds</span><br></pre></td></tr></table></figure>

<p>② 删除列族</p>
<p>​	删除列族可以用以下两种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; alter &#x27;bigdata:person&#x27;, NAME =&gt; &#x27;tel&#x27;, METHOD =&gt; &#x27;delete&#x27;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.1046 seconds</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; alter &#x27;bigdata:person&#x27;, &#x27;delete&#x27; =&gt; &#x27;msg&#x27;</span><br><span class="line">Updating all regions with the new schema...</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">Took 2.9721 seconds</span><br></pre></td></tr></table></figure>

<p>​	然后查询修改后的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;bigdata:person&#x27;</span><br><span class="line">Table bigdata:person is ENABLED</span><br><span class="line">bigdata:person</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;name&#x27;, VERSIONS =&gt; &#x27;5&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;fa</span><br><span class="line">lse&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, I</span><br><span class="line">N_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0391 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用表 <code>disable</code></p>
<p><strong>用法</strong>： <code>disable &#39;ns:tb&#39;</code>或<code>disable &#39;tb&#39;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; disable &#x27;bigdata:person&#x27;</span><br><span class="line">Took 0.9384 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表 <code>drop</code></p>
<p><strong>用法</strong>： <code>drop &#39;ns:tb&#39;</code>或<code>drop &#39;tb&#39;</code>，删除表时需要保证表是禁用的，否则会出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; drop &#x27;bigdata:person&#x27;</span><br><span class="line"></span><br><span class="line">ERROR: Table bigdata:person is enabled. Disable it first.</span><br><span class="line"></span><br><span class="line">For usage try &#x27;help &quot;drop&quot;&#x27;</span><br><span class="line"></span><br><span class="line">Took 0.0248 seconds</span><br></pre></td></tr></table></figure>

<p>​	禁用表后再删除表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; drop &#x27;bigdata:person&#x27;</span><br><span class="line">Took 1.7106 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据操纵语言 <code>dml</code></strong></p>
<p><strong>DML(Data Manipulation Language)数据操纵语言</strong>，主要是对数据进行增加、删除、修改操作。</p>
<ul>
<li><p>写入数据 <code>put</code></p>
<p>在 <code>HBase</code> 中如果想要写入数据，只能添加结构中最底层的 <code>Cell</code>。可以手动写入时间戳指定 <code>Cell</code> 的版本，推荐不写，默认使用当前的系统时间。如果重复写入相同 <code>rowKey</code>，相同列的数据，会写入多个版本进行覆盖。所以他同时兼具<strong>写入</strong>和<strong>修改</strong>的功能。</p>
<p><strong>用法</strong>：</p>
<p>① <code>put &#39;ns:tb&#39;, &#39;rk&#39;, &#39;col&#39;, &#39;value&#39;</code></p>
<p>​	向命名空间<code>ns</code>中的<code>tb</code>表中的行键为<code>rk</code>，列为<code>col</code>的位置写入值<code>value</code>。其中<code>col</code>为<code>cf:col</code>（即<code>列族:列名</code>）的格式。</p>
<p>​	如果重复向相同行号<code>rk</code>，相同<code>col</code>写数据，则会进行覆盖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">Took 0.2415 seconds</span><br><span class="line">hbase(main):002:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">Took 0.0121 seconds</span><br><span class="line">hbase(main):003:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;wangwu&#x27;</span><br><span class="line">Took 0.0342 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1002&#x27;, &#x27;info:name&#x27;, &#x27;zhaoliu&#x27;</span><br><span class="line">Took 0.0082 seconds</span><br><span class="line">hbase(main):005:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#x27;info:age&#x27;, &#x27;10&#x27;</span><br><span class="line">Took 0.0050 seconds</span><br><span class="line">hbase(main):006:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#x27;info:sex&#x27;, &#x27;male&#x27;</span><br><span class="line">Took 0.0054 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>put &#39;t1&#39;, &#39;r1&#39;, &#39;c1&#39;, &#39;value&#39;</code>用法同上。</p>
</li>
<li><p>读取数据 <code>get/scan</code></p>
<p>读取数据的方法有两个：<code>get</code> 和 <code>scan</code></p>
<ul>
<li><p><code>get</code>最大范围是一行数据，也可以进行列的过滤，读取数据的结果为多行 <code>Cell</code>。</p>
</li>
<li><p><code>scan</code>是扫描数据，能够读取多行数据，不建议扫描过多数据，推荐使用 <code>startRow</code> 和 <code>stopRow</code> 来控制读取的数据，默认范围左闭右开。</p>
</li>
</ul>
<p>① <code>get</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>											<span class="comment">#查看&#x27;r1&#x27;的数据</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;TIMERANGE =&gt; [ts1, ts2]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>&#125;						<span class="comment">#过滤单列, 只显示 &#x27;c1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>]&#125;			<span class="comment">#过滤多列, 只显示 &#x27;c1&#x27;, &#x27;c2&#x27;, &#x27;c3&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMESTAMP =&gt; ts1&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMERANGE =&gt; [ts1, ts2], VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;COLUMN =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMESTAMP =&gt; ts1, VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;FILTER =&gt; <span class="string">&quot;ValueFilter(=, &#x27;binary:abc&#x27;)&quot;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;c1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;CONSISTENCY =&gt; <span class="string">&#x27;TIMELINE&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">t.get <span class="string">&#x27;r1&#x27;</span>, &#123;CONSISTENCY =&gt; <span class="string">&#x27;TIMELINE&#x27;</span>, REGION_REPLICA_ID =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1001&#x27;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:name                               timestamp=1717580289267, value=wangwu</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0645 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):002:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#123;COLUMN =&gt; &#x27;info:name&#x27;&#125;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:name                               timestamp=1717580289267, value=wangwu</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0107 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):003:0&gt; get &#x27;bigdata:student&#x27;, &#x27;1003&#x27;, &#123;COLUMN =&gt; &#x27;info:age&#x27;&#125;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> info:age                                timestamp=1717580366636, value=10</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0185 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>scan</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;hbase:meta&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;hbase:meta&#x27;</span>, &#123;COLUMNS =&gt; <span class="string">&#x27;info:regioninfo&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;ns1:t1&#x27;</span>, &#123;COLUMNS =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">&#x27;xyz&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;COLUMNS =&gt; [<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">&#x27;xyz&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;COLUMNS =&gt; <span class="string">&#x27;c1&#x27;</span>, TIMERANGE =&gt; [1303668804000, 1303668904000]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;REVERSED =&gt; <span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;ALL_METRICS =&gt; <span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;METRICS =&gt; [<span class="string">&#x27;RPC_RETRIES&#x27;</span>, <span class="string">&#x27;ROWS_FILTERED&#x27;</span>]&#125;</span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash">scan <span class="string">&#x27;t1&#x27;</span>, &#123;ROWPREFIXFILTER =&gt; <span class="string">&#x27;row2&#x27;</span>, FILTER =&gt; <span class="string">&quot;</span></span></span><br><span class="line">    (QualifierFilter (&gt;=, &#x27;binary:xyz&#x27;)) AND (TimestampsFilter ( 123, 456))&quot;&#125;</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;FILTER =&gt;</span></span></span><br><span class="line">    org.apache.hadoop.hbase.filter.ColumnPaginationFilter.new(1, 0)&#125;</span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;CONSISTENCY =&gt; &#x27;TIMELINE&#x27;&#125;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;ISOLATION_LEVEL =&gt; &#x27;READ_UNCOMMITTED&#x27;&#125;</span></span></span><br><span class="line"><span class="meta prompt_">  hbase&gt; </span><span class="language-bash"><span class="string">scan &#x27;t1&#x27;, &#123;MAX_RESULT_SIZE =&gt; 123456&#125;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717580289267, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0338 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):025:0&gt; scan &#x27;bigdata:student&#x27;, &#123;STARTROW =&gt; &#x27;1001&#x27;, STOPROW =&gt; &#x27;1003&#x27;&#125;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717580289267, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line">2 row(s)</span><br><span class="line">Took 0.0118 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据 <code>delete/deleteall</code></p>
<p>删除数据的方式有两个：<code>delete</code>和<code>deleteall</code></p>
<ul>
<li><code>delete</code> 表示删除一个版本的数据，即为 <code>1</code> 个 <code>Cell</code>，不填写版本默认删除最新的一个版本。</li>
<li><code>deleteall</code> 表示删除所有版本的数据，即为当前行当前列的多个 <code>Cell</code>。执行命令会标记数据为要删除，不会直接彻底删除，删除只在特定时期清理磁盘时进行。</li>
</ul>
<p>① <code>delete</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;zhangsan&#x27;</span><br><span class="line">Took 0.3910 seconds</span><br><span class="line">hbase(main):002:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;lisi&#x27;</span><br><span class="line">Took 0.2024 seconds</span><br><span class="line">hbase(main):003:0&gt; put &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;, &#x27;wangwu&#x27;</span><br><span class="line">Took 0.1559 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717584831277, value=wangwu</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0083 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):005:0&gt; delete &#x27;bigdata:student&#x27;, &#x27;1001&#x27;, &#x27;info:name&#x27;</span><br><span class="line">Took 0.0055 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):006:0&gt; scan &#x27;bigdata:student&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> 1001                                    column=info:name, timestamp=1717584831277, value=lisi</span><br><span class="line"> 1002                                    column=info:name, timestamp=1717580320927, value=zhaoliu</span><br><span class="line"> 1003                                    column=info:age, timestamp=1717580366636, value=10</span><br><span class="line"> 1003                                    column=info:sex, timestamp=1717581149533, value=male</span><br><span class="line">3 row(s)</span><br><span class="line">Took 0.0087 seconds</span><br></pre></td></tr></table></figure>

<p>② <code>deleteall</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="2-2-2-API操作"><a href="#2-2-2-API操作" class="headerlink" title="2.2.2 API操作"></a>2.2.2 API操作</h5><p>根据官方 API 介绍，<strong>HBase</strong> 的客户端连接由 <code>ConnectionFactory</code> 类来创建，用户使用完成之后需要手动关闭连接。同时连接是一个<strong>重量级</strong>的，推荐一个进程使用一个连接。对 <strong>HBase</strong> 的命令通过连接中的两个属性 <code>Admin</code> 和 <code>Table</code> 来实现。其中 <code>Admin</code> 主要管理 <strong>HBase</strong> 的元数据，如创建、修改表格信息，也就是 <code>DDL</code> 操作；<code>Table</code> 主要用于表格的增加、删除数据，也就是 <code>DML</code> 操作。</p>
<ul>
<li><p>环境搭建</p>
<p>使用 <code>IDEA</code> 创建 <code>Maven</code> 项目，并修改 <code>pom.xml</code> 文件，添加 <code>HBase</code> 所需要用到的依赖。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果报错, 需要排除 javax.el 拓展 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 因为 2.4.11 对应的是一个测试版本的 javax.el 包 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 需要先排除这个包后再添加正式版的 javax.el 包 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加正式版的 javax.el 包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1-b06<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>单线程使用连接</p>
<p>下面展示了一种单线程使用连接的方式，实际开发中实际上很少这样做。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdutcm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.AsyncConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接配置对象</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加配置参数</span></span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;bigdata&quot;</span>);      <span class="comment">// 这些配置都写在 hbase-site.xml 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="comment">// 默认创建同步连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以创建异步连接: 不推荐使用异步连接</span></span><br><span class="line">        CompletableFuture&lt;AsyncConnection&gt; asyncConnection = ConnectionFactory.createAsyncConnection(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用连接</span></span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多线程使用连接</p>
<p>实际开发中，因为 <strong>HBase</strong> 的连接是重量级的，所以我们在每个客户端中一般只创建一个（类似于单例模式）。所以我们对代码进行修改，如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdutcm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.AsyncConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseConnection</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接配置对象: 当完成 resources 目录的配置后, 我们可以直接注释掉创建配置的部分</span></span><br><span class="line">        <span class="comment">// 直接进行创建连接操作</span></span><br><span class="line">        <span class="comment">// Configuration conf = new Configuration();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加配置参数</span></span><br><span class="line">        <span class="comment">// 实际开发中, 不应该在代码中显式的写参数, 而是将参数写在 resources 下的配置文件中</span></span><br><span class="line">        <span class="comment">// 将虚拟机的 hbase-site.xml 放到 resources 目录下</span></span><br><span class="line">        <span class="comment">// conf.set(&quot;hbase.zookeeper.quorum&quot;, &quot;bigdata&quot;);      // 这些配置都写在 hbase-site.xml 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接</span></span><br><span class="line">        <span class="comment">// 默认创建同步连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里修改为无参构造</span></span><br><span class="line">            <span class="comment">// connection = ConnectionFactory.createConnection(conf);</span></span><br><span class="line">            <span class="comment">// 这里通过查看 ConnectionFactory.createConnection() -&gt; 查看 create() -&gt; 可以发现 HBase 官方文档添加了两个配置文件</span></span><br><span class="line">            <span class="comment">// 分别为 hbase-default.xml 和 hbase-site.xml</span></span><br><span class="line">            <span class="comment">// 所以我们可以直接复制虚拟机的 hbase-site.xml 添加到 resources 目录下, 并且将这里改为无参构造</span></span><br><span class="line">            <span class="comment">// 无参则默认使用读取本地 hbase-site.xml 文件的方式添加参数</span></span><br><span class="line">            connection = ConnectionFactory.createConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 判断连接是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 直接使用创建好的连接, 不要在 main 线程里面单独创建连接</span></span><br><span class="line">        System.out.println(HBaseConnection.connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用完连接后需要关闭连接</span></span><br><span class="line">        HBaseConnection.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 <code>Admin</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Admin</span></span><br><span class="line"><span class="comment">// Admin 的连接式轻量级的, 不是线程安全的, 不推荐池化或者缓存这个连接</span></span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br></pre></td></tr></table></figure>

<ul>
<li>创建命名空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdutcm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.NamespaceDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Admin;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseDDL</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个静态属性, 这样我们可以在不同的类中, 调用到同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> HBaseConnection.connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@brief</span> 创建命名空间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> namespace 命名空间名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createNamespace</span><span class="params">(String namespace)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 Admin</span></span><br><span class="line">        <span class="comment">// Admin 的连接式轻量级的, 不是线程安全的, 不推荐池化或者缓存这个连接</span></span><br><span class="line">        <span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用方法创建命名空间</span></span><br><span class="line">        <span class="comment">// 2.1 创建命名空间描述</span></span><br><span class="line">        NamespaceDescriptor.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> NamespaceDescriptor.create(namespace);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 给命名空间添加需求</span></span><br><span class="line">        builder.addConfiguration(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;sdutcm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3 使用 builder 构造出对应的添加完参数的对象, 完成创建</span></span><br><span class="line">        admin.createNamespace(builder.build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 admin</span></span><br><span class="line">        admin.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 测试创建命名空间</span></span><br><span class="line">        createNamespace(<span class="string">&quot;sdutcm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;其他代码&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭 HBase 连接</span></span><br><span class="line">        HBaseConnection.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; list_namespace</span><br><span class="line">NAMESPACE</span><br><span class="line">default</span><br><span class="line">hbase</span><br><span class="line">sdutcm		&lt;&lt;&lt; 可以看到 sdutcm 已经被创建出来了</span><br><span class="line">3 row(s)</span><br><span class="line">Took 8.0120 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):002:0&gt; describe_namespace &quot;sdutcm&quot;</span><br><span class="line">DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;sdutcm&#x27;, user =&gt; &#x27;sdutcm&#x27;&#125;	&lt;&lt;&lt; 这里是我们添加的描述</span><br><span class="line">Took 0.7576 seconds</span><br><span class="line">=&gt; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>多异常处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>判断表格是否存在</li>
<li>创建表格</li>
</ul>
<h3 id="📕-3-底层原理"><a href="#📕-3-底层原理" class="headerlink" title="📕 3. 底层原理"></a>📕 3. 底层原理</h3><h4 id="3-1-进程架构"><a href="#3-1-进程架构" class="headerlink" title="3.1 进程架构"></a>3.1 进程架构</h4><h5 id="3-1-1-Master架构"><a href="#3-1-1-Master架构" class="headerlink" title="3.1.1 Master架构"></a>3.1.1 Master架构</h5><h5 id="3-1-2-RegionServer架构"><a href="#3-1-2-RegionServer架构" class="headerlink" title="3.1.2 RegionServer架构"></a>3.1.2 RegionServer架构</h5><h4 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h4><h5 id="3-2-1-写入顺序"><a href="#3-2-1-写入顺序" class="headerlink" title="3.2.1 写入顺序"></a>3.2.1 写入顺序</h5><h5 id="3-2-2-刷新机制"><a href="#3-2-2-刷新机制" class="headerlink" title="3.2.2 刷新机制"></a>3.2.2 刷新机制</h5><h4 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h4><h5 id="3-3-1-读取顺序"><a href="#3-3-1-读取顺序" class="headerlink" title="3.3.1 读取顺序"></a>3.3.1 读取顺序</h5><h5 id="3-3-2-合并数据优化"><a href="#3-3-2-合并数据优化" class="headerlink" title="3.3.2 合并数据优化"></a>3.3.2 合并数据优化</h5><h4 id="3-4-文件合并"><a href="#3-4-文件合并" class="headerlink" title="3.4 文件合并"></a>3.4 文件合并</h4><h5 id="3-4-1-大合并"><a href="#3-4-1-大合并" class="headerlink" title="3.4.1 大合并"></a>3.4.1 大合并</h5><h5 id="3-4-2-小合并"><a href="#3-4-2-小合并" class="headerlink" title="3.4.2 小合并"></a>3.4.2 小合并</h5><h4 id="Region拆分"><a href="#Region拆分" class="headerlink" title="Region拆分"></a>Region拆分</h4><h5 id="自定义预分区"><a href="#自定义预分区" class="headerlink" title="自定义预分区"></a>自定义预分区</h5><h5 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h5><h3 id="🔧-企业开发"><a href="#🔧-企业开发" class="headerlink" title="🔧 企业开发"></a>🔧 企业开发</h3><h4 id="TSDB模式"><a href="#TSDB模式" class="headerlink" title="TSDB模式"></a>TSDB模式</h4><h4 id="基础表格模式"><a href="#基础表格模式" class="headerlink" title="基础表格模式"></a>基础表格模式</h4><h5 id="自定义API"><a href="#自定义API" class="headerlink" title="自定义API"></a>自定义API</h5><h5 id="整合框架"><a href="#整合框架" class="headerlink" title="整合框架"></a>整合框架</h5><h6 id="Phoenix-读写数据"><a href="#Phoenix-读写数据" class="headerlink" title="Phoenix 读写数据"></a>Phoenix 读写数据</h6><h6 id="Hive-分析数据"><a href="#Hive-分析数据" class="headerlink" title="Hive 分析数据"></a>Hive 分析数据</h6></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-27T10:18:43.000Z" title="2024/5/27 18:18:43">2024-05-27</time>发表</span><span class="level-item"><time dateTime="2024-05-27T10:18:43.645Z" title="2024/5/27 18:18:43">2024-05-27</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/27/Evaluation-Indicators-in-AI/">Evaluation Indicators in AI</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T13:50:18.000Z" title="2024/5/22 21:50:18">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-07-29T07:32:26.196Z" title="2024/7/29 15:32:26">2024-07-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/QT6/">QT6</a></span><span class="level-item">23 分钟读完 (大约3452个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Better-QT/">Better QT</a></p><div class="content"><p>[TOC]</p>
<h2 id="🍞-Better-QT"><a href="#🍞-Better-QT" class="headerlink" title="🍞 Better QT"></a>🍞 Better QT</h2><h3 id="🍦-1-Qt-的一些常用技巧"><a href="#🍦-1-Qt-的一些常用技巧" class="headerlink" title="🍦 1. Qt 的一些常用技巧"></a>🍦 1. Qt 的一些常用技巧</h3><h4 id="1-1-快捷键"><a href="#1-1-快捷键" class="headerlink" title="1.1 快捷键"></a>1.1 快捷键</h4><ul>
<li>快捷键 <code>Ctrl + Tab</code> 可以切换文件；</li>
<li>快捷键 <code>Alt + ENTER</code> 弹出代码生成提示，可以快速提示错误修改方案，类似于 IDEA 的 <code>Alt + ENTER</code>；</li>
<li>快捷键 <code>Alt + 鼠标</code> 同时输入；</li>
<li>快捷键 <code>Ctrl + R</code> 运行程序；</li>
<li>快捷键 <code>Ctrl + M</code> 创建书签（Bookmark），或者直接在某行代码前右键添加书签；</li>
<li>快捷键 <code>Ctrl + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + Shift + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + I</code> 代码对齐；</li>
<li>快捷键 <code>Ctrl + ;</code> 格式化代码；</li>
<li>快捷键 <code>Shift + Delete</code> 剪切当前行，可以当删除用；</li>
<li>快捷键 <code>Ctrl + Shift + R</code> 局部变量统一修改；</li>
<li>快捷键 <code>Ctrl + Shift + V</code> 复制历史；</li>
<li>用键盘模拟鼠标操作：  <table>
    <tr>
        <td colspan="3">功能键</td> 
        <td colspan="3">方向键</td> 
        <td>备注</td>
    </tr>
    <tr>
          <td>Ctrl</td>
          <td>Shift</td>
          <td>Alt</td>
          <td>左/右</td>
          <td>上/下</td>
          <td>Home/End</td>
          <td>方向键具有移动光标的作用</td>
    </tr>
    <tr>
          <td>×</td>
          <td>×</td>
          <td>×</td>
          <td>字符</td>
          <td>字符</td>
          <td>行首/行尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>×</td>
          <td>单词</td>
          <td>滚动条</td>
          <td>文件头/尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>单词</td>
          <td>移动</td>
          <td>行首/行尾</td>
          <td>Shift具有选中文本的作用</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>√</td>
          <td>-</td>
          <td>向上/下复制选中部分</td>
          <td>-</td>
          <td>-</td>
    </tr>
  </table></li>
<li>快捷键 <code>F1</code> 查看帮助、文档</li>
<li>快捷键 <code>F2</code> 快速到变量或者函数间切换</li>
<li>快捷键 <code>F4</code> 快速在<code>.cpp</code>文件和<code>.h</code>文件间切换</li>
<li>快捷键 <code>Ctrl + Shift + U</code> 查找所有使用该符号的地方</li>
<li>快捷键 <code>Ctrl + K</code> 打开定位器</li>
<li>快捷键 <code>Ctrl + L</code> 跳转到某一行</li>
<li>快捷键 <code>Ctrl + [Shift] + F</code> 查找&#x2F;替换当前文件[项目]当前选中的内容</li>
<li>快捷键 <code>[Shift] + F3</code> 查找下[上]一个</li>
<li>快捷键 <code>Ctrl + B</code> 编译工程</li>
<li>快捷键 <code>Ctrl + R</code> 运行工程</li>
<li>快捷键 <code>F5</code> 调试运行</li>
<li>快捷键 <code>Ctrl + Shift + F5</code> 重启调试</li>
<li>快捷键 <code>F9</code> 设置和取消断点</li>
<li>快捷键 <code>F10</code> 单步跳过</li>
<li>快捷键 <code>F11</code> 单步进入</li>
</ul>
<h4 id="1-2-Creator-片段"><a href="#1-2-Creator-片段" class="headerlink" title="1.2 Creator 片段"></a>1.2 Creator 片段</h4><p>片段简单理解一下就是已经写好的一些模式化的代码，用户可以使用内置片段或者根据自己的需要自定义片段。</p>
<ol>
<li>自带片段示例<br><img src="/./BetterQT/QtQuickSnippets.png" alt="Qt Quick Part"></li>
<li>自定义片段<br>一个用户的自定义片段需要以下几个内容：<br>$$片段 &#x3D; 一级标题 + 二级标题 + 片段文本$$<br>需要通过：编辑（Edit）→首选项（Preferences）→文本编辑器（Text Editor）→片段（Snippets）进行设置<br><img src="/./BetterQT/Qt_Custom_Snippets.png" alt="Qt Custom Snippets"><br>比如我要添加一个自定义片段 <code>note</code>，用来表示文件注释，可以选择 <code>Group</code> 为 <code>C++</code>，然后选择 <code>Add</code>，添加指定的内容：<br><img src="/./BetterQT/AddCustomSnippets.png" alt="Add Custom Snippets"></li>
</ol>
<h3 id="🍦-2-Qt-代码-文件解释"><a href="#🍦-2-Qt-代码-文件解释" class="headerlink" title="🍦 2. Qt 代码&#x2F;文件解释"></a>🍦 2. Qt 代码&#x2F;文件解释</h3><p>Qt的源代码和文件解释</p>
<h4 id="2-1-Qt-代码"><a href="#2-1-Qt-代码" class="headerlink" title="2.1 Qt 代码"></a>2.1 Qt 代码</h4><ul>
<li><p><code>hellocosbrowser.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOCOSBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOCOSBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span> : <span class="keyword">public</span> QWidget  <span class="comment">// QWidget 是所有应用程序窗口的基类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// Qt的宏, 支持 Qt 的特性, 如信号与槽、对象树、元对象等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里 HelloCOSBrowser 指定父窗口指针为 nullptr, 则它会作为一个独立的窗口进行展示, 否则则会作为父窗口的一个控件</span></span><br><span class="line">    <span class="comment">// 关于这个父窗口指针, 一个很典型的应用就是 微信</span></span><br><span class="line">    <span class="comment">// 当我们创建新窗口的时候, 如果不指定父窗口, 就会弹出一个独立的新窗口, 即电脑任务栏的图标会多出来一个</span></span><br><span class="line">    <span class="comment">// 如果指定了父窗口, 则不会创建一个独立的窗口, 即电脑任务栏处的图标不会增加</span></span><br><span class="line">    <span class="built_in">HelloCOSBrowser</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">HelloCOSBrowser</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::HelloCOSBrowser *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLOCOSBROWSER_H</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-Qt-工程文件解释"><a href="#2-2-Qt-工程文件解释" class="headerlink" title="2.2 Qt 工程文件解释"></a>2.2 Qt 工程文件解释</h4><p>文件列表</p>
<table>
<thead>
<tr>
<th align="center">文件名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>pro</code> 文件</td>
<td align="center">该文件是 Qt 的项目文件，qmake工具可以根据此文件生成 Makefile</td>
</tr>
<tr>
<td align="center"><code>pro.user</code> 文件</td>
<td align="center">该文件包含和用户相关的项目信息（用户不需要关注此文件）</td>
</tr>
<tr>
<td align="center"><code>ui</code> 文件</td>
<td align="center">Qt 的设计师界面文件</td>
</tr>
<tr>
<td align="center"><code>.cpp</code> 文件</td>
<td align="center">C++ 源文件</td>
</tr>
<tr>
<td align="center"><code>.h</code> 文件</td>
<td align="center">C++ 头文件</td>
</tr>
</tbody></table>
<h3 id="🍦-3-MOC编译器"><a href="#🍦-3-MOC编译器" class="headerlink" title="🍦 3. MOC编译器"></a>🍦 3. MOC编译器</h3><p>MOC(Meta-Object Compiler)编译器<br>C++ 编译器本身不支持 Qt 的某些机制，Qt 希望对 C++ 代码进行自动扩展，这里就需要用到宏（例如：<code>Q_Object</code>）和继承。<br>此外为了方便用户使用，希望用户无感知，可以将这一操作直接集成到框架中。</p>
<h4 id="3-1-Qt-编译过程"><a href="#3-1-Qt-编译过程" class="headerlink" title="3.1 Qt 编译过程"></a>3.1 Qt 编译过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 目标</span><br><span class="line">  ↑</span><br><span class="line">  +-------------------------+</span><br><span class="line">                            ↑</span><br><span class="line">拓展代码 -&gt; MOC编译器 -&gt; 新CPP代码</span><br></pre></td></tr></table></figure>
<p>通过上述方式，实现 Qt 的某些特性。我们可以发现，当我们写完代码进行编译后，会产生一个 <code>debug</code> 文件夹，此时我们进入该文件夹，会看到一些元对象编译器编译的文件，如 <code>moc_xxxx.cpp</code> 或 <code>moc_xxx.h</code> 等文件。</p>
<h4 id="3-2-MOC-的使用方法"><a href="#3-2-MOC-的使用方法" class="headerlink" title="3.2 MOC 的使用方法"></a>3.2 MOC 的使用方法</h4><ol>
<li>MOC 编译工具由 Qt 框架自动调用</li>
<li>扫描 C++ 头文件，寻找 <code>Q_OBJECT</code> 宏</li>
<li>生成拓展 C++ 代码，再进行预编译</li>
<li>程序员在使用时，需要继承 QObject 类或者是 QObject 子类，并且包含 <code>Q_OBJECT</code> 宏。</li>
</ol>
<h3 id="🍦-4-Qt应用程序开发"><a href="#🍦-4-Qt应用程序开发" class="headerlink" title="🍦 4. Qt应用程序开发"></a>🍦 4. Qt应用程序开发</h3><h4 id="4-1-Qt-Designer-设计师界面使用"><a href="#4-1-Qt-Designer-设计师界面使用" class="headerlink" title="4.1 Qt Designer 设计师界面使用"></a>4.1 Qt Designer 设计师界面使用</h4><p><img src="/./BetterQT/Qt_Designer.png" alt="Qt Designer"><br>① Qt 控件编辑模式<br>② Qt 信号与槽编辑模式<br>③ Qt 伙伴关系编辑模式<br>④ Qt Tab 顺序编辑模式：可以设置按下 Tab 键的高亮顺序</p>
<h4 id="4-2-Qt-核心——信号与槽"><a href="#4-2-Qt-核心——信号与槽" class="headerlink" title="4.2 Qt 核心——信号与槽"></a>4.2 Qt 核心——信号与槽</h4><p><strong>信号与槽的基本概念</strong><br><img src="/./BetterQT/QtSignalsSlots.drawio.png" alt="Qt Signals and Slots"></p>
<ul>
<li>Qt 中的信号和槽是支持多对多的，即一个信号可以对应多个槽，一个槽可以由多个信号触发。</li>
<li>Qt 中的信号无需实现，可以由函数（普通函数或者槽函数）通过 <code>emit</code> 关键字发送信号传递参数。</li>
</ul>
<h5 id="4-2-1-Qt中如何定义信号"><a href="#4-2-1-Qt中如何定义信号" class="headerlink" title="4.2.1 Qt中如何定义信号"></a>4.2.1 Qt中如何定义信号</h5><ol>
<li>继承 <code>QObject</code> 类或其派生类，同时包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>signals</code> 声明函数信号函数，不需要具体实现信号函数</li>
<li>使用 <code>emit</code> 关键字发送信号</li>
</ol>
<h5 id="4-2-2-Qt中如何定义槽函数"><a href="#4-2-2-Qt中如何定义槽函数" class="headerlink" title="4.2.2 Qt中如何定义槽函数"></a>4.2.2 Qt中如何定义槽函数</h5><ol>
<li>必须包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>[public/protected/private] slots</code> 声明函数</li>
<li>需要具体实现声明的槽函数</li>
</ol>
<h5 id="4-2-3-Qt中如何连接信号与槽（三种写法）"><a href="#4-2-3-Qt中如何连接信号与槽（三种写法）" class="headerlink" title="4.2.3 Qt中如何连接信号与槽（三种写法）"></a>4.2.3 Qt中如何连接信号与槽（三种写法）</h5><ol>
<li><code>SIGNAL/SLOT</code> 宏写法：<br><code>QObject::connect(this, SIGNAL(...), this, SLOT(...));</code></li>
<li>函数指针写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, &amp;SlotFunction)</code></li>
<li>lambda 表达式写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, [=]() &#123; qDebug() &lt;&lt; &quot;...&quot;; &#125;)</code></li>
</ol>
<p>三种写法的比较：</p>
<table>
    <tr>
        <td rowspan="2" colspan="3">连接信号与槽</td> 
        <td colspan="2">宏</td>
        <td colspan="2">函数指针</td>
    </tr>
    <tr>
        <td>编译</td>
        <td>运行</td>
        <td>编译</td>
        <td>运行</td>
    </tr>
    <tr>
        <td rowspan="4">参数类型</td>
        <td colspan="2">完全相同</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td rowspan="2">隐式转换</td>
        <td>向上</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td>向下</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">不可以隐式转换</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
        <tr>
        <td rowspan="3">参数个数</td>
        <td colspan="2">信号=槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号>槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号<槽</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
</table>

<ul>
<li>这样看来好像宏写法相对于函数指针的写法来说，可能会带来一些问题，因为有时候宏写法通过编译后，在运行阶段可能会出现一些问题；而函数指针写法可以在出现这一问题之前（编译阶段）提前发现这一问题，使得程序无法通过编译。</li>
<li>但是事实上，宏写法还是存在一定的好处，当信号函数出现重载时，使用函数指针时，无法直接进行连接（会产生报错），只能使用类型转换来进行函数指针类型的转换，如<code>static_cast&lt;void QSpinBox::*)(int)&gt;</code>。</li>
<li>一般情况下，推荐使用函数指针方式连接信号与槽。</li>
<li>当面对信号与槽函数有重载的情况时，推荐使用宏方式连接。</li>
<li>对于短小的槽函数的调用且功能不被复用时，推荐使用 lambda 方式连接。</li>
</ul>
<h5 id="4-2-4-其他连接信号与槽的方式"><a href="#4-2-4-其他连接信号与槽的方式" class="headerlink" title="4.2.4 其他连接信号与槽的方式"></a>4.2.4 其他连接信号与槽的方式</h5><ul>
<li>使用 Qt Designer 连接信号与槽<br><img src="/./BetterQT/Designer_Connect.png" alt="Qt Designer Connect"></li>
<li>使用”转到槽”方式</li>
<li>信号与槽自动绑定<br>使用 <code>void on_&lt;对象名&gt;_&lt;信号名&gt;(信号参数);</code> 时可以不使用 <code>connect</code> 进行连接，但是当对象名、信号名或参数发生变化时，连接将会失效，且编译不会有错误提示。</li>
</ul>
<h4 id="4-3-Qt-窗口"><a href="#4-3-Qt-窗口" class="headerlink" title="4.3 Qt 窗口"></a>4.3 Qt 窗口</h4><h5 id="4-3-1-窗口的类型"><a href="#4-3-1-窗口的类型" class="headerlink" title="4.3.1 窗口的类型"></a>4.3.1 窗口的类型</h5><p><strong>顶层窗口、次级窗口（父、子窗口）</strong><br><img src="/./BetterQT/Qt_Windows.png" alt="Qt Windows"><br>在该图中，①可以称为顶层窗口（父窗口），②可以称为次级窗口（子窗口）。窗口中的某些按钮、输入框…等就是控件。</p>
<h5 id="4-3-2-设置窗口标志"><a href="#4-3-2-设置窗口标志" class="headerlink" title="4.3.2 设置窗口标志"></a>4.3.2 设置窗口标志</h5><p>在 Qt 中可以使用 <code>setWindowFlags()</code> 来设置窗口标志</p>
<ol>
<li><p>设置窗口无标题栏<br><img src="/./BetterQT/Window_With_No_Title.png" alt="Window With No Title"></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint);</span><br></pre></td></tr></table></figure></li>
<li><p>设置窗口无边框<br><img src="/./BetterQT/Window_With_No_Frame.png" alt="Window With No Frame"></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure></li>
<li><p>设置窗口置顶</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
<p> 如果按照上述方式依次设置窗口标志，我们会发现当设置第 $3$ 步时前面两步的操作都失效了，这是因为设置窗口置顶时，会覆盖前面的设置。我们可以使用“或”符连接这些标志，解决这一问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-4-窗口坐标系与几何布局"><a href="#4-4-窗口坐标系与几何布局" class="headerlink" title="4.4 窗口坐标系与几何布局"></a>4.4 窗口坐标系与几何布局</h4><h5 id="4-4-1-窗口的坐标系"><a href="#4-4-1-窗口的坐标系" class="headerlink" title="4.4.1 窗口的坐标系"></a>4.4.1 窗口的坐标系</h5><img src="./BetterQT/CoordinateSystem.png" alt="Window Coordinate System" style="zoom:50%;" />

<h5 id="4-4-2-窗口的几何布局"><a href="#4-4-2-窗口的几何布局" class="headerlink" title="4.4.2 窗口的几何布局"></a>4.4.2 窗口的几何布局</h5><img src="./BetterQT/WindowLayout.png" alt="Window Layout" style="zoom:50%;" />

<h4 id="4-5-添加图标"><a href="#4-5-添加图标" class="headerlink" title="4.5 添加图标"></a>4.5 添加图标</h4><h5 id="4-5-1-为窗口添加图标"><a href="#4-5-1-为窗口添加图标" class="headerlink" title="4.5.1 为窗口添加图标"></a>4.5.1 为窗口添加图标</h5><ol>
<li>准备图标文件</li>
<li>调用 <code>setWindowIcon</code> 方法</li>
</ol>
<h5 id="4-5-2-为应用程序添加图标（一般使用这种方式）"><a href="#4-5-2-为应用程序添加图标（一般使用这种方式）" class="headerlink" title="4.5.2 为应用程序添加图标（一般使用这种方式）"></a>4.5.2 为应用程序添加图标（一般使用这种方式）</h5><ol>
<li>准备图标文件 <code>logo.ico</code></li>
<li>修改 pro 工程文件 <code>RC_ICONS = &lt;Path&gt;</code></li>
<li>通过此种方式修改图标，可执行程序 <code>.exe</code> 的图标会修改，且不需要额外单独设置窗口图标。</li>
</ol>
<h4 id="4-6-部署产品的三种方式"><a href="#4-6-部署产品的三种方式" class="headerlink" title="4.6 部署产品的三种方式"></a>4.6 部署产品的三种方式</h4><ol>
<li><p>手动部署（不常用，比较繁琐）<br>进入 <code>.exe</code> 文件所在的文件夹（<code>debug</code>目录），双击运行 <code>.exe</code> 文件，会提示缺少的文件（包括<code>dll</code>动态库、<code>plugin</code>插件等），然后找到对应的文件移动到 <code>.exe</code> 文件的同级目录下即可，如下：<br><img src="/./BetterQT/EXE_File_Dictionary.png" alt="EXE File Dictionary"><br>如果配置了环境变量则大概率不会出现报错提示缺少库的问题，那么这种方式就会失效。</p>
</li>
<li><p>使用 windeployqt 部署<br>① 查找 <code>windeployqt.exe</code> 程序<br>② 将 <code>windeployqt.exe</code> 加入环境变量<br>③ 再命令行界面执行命令 <code>windeployqt.exe &lt;exe_file_dir&gt;</code> 完成操作<br><img src="/./BetterQT/WIN_DEPLOY_QT_1.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_2.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_3.png" alt="WIN DEPLOY QT"></p>
</li>
<li><p>使用creator 部署<br>① 项目导航窗口→运行→部署→添加自定义部署<br><img src="/./BetterQT/CREATOR_DEPLOY_1.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_2.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_3.png" alt="CREATOR DEPLOY"><br>② 输入 <code>windeployqt.exe</code> 程序及对应的命令行参数<br><img src="/./BetterQT/CREATOR_DEPLOY_4.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_5.png" alt="CREATOR DEPLOY"><br>③ 执行部署命令<br><img src="/./BetterQT/CREATOR_DEPLOY_6.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_OK.png" alt="CREATOR DEPLOY OK"></p>
</li>
</ol>
<h3 id="🍦-5-Qt-常用控件"><a href="#🍦-5-Qt-常用控件" class="headerlink" title="🍦 5. Qt 常用控件"></a>🍦 5. Qt 常用控件</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/index.html">Qt 6.7</a></p>
<p>一个不错的 Qt 中文文档：<a target="_blank" rel="noopener" href="http://qt5.digitser.top/5.15/zh-CN/">Qt 中文文档 5.15.1 版本</a></p>
<h4 id="5-1-QLabel-标签控件"><a href="#5-1-QLabel-标签控件" class="headerlink" title="5.1 QLabel 标签控件"></a>5.1 <code>QLabel</code> 标签控件</h4><p><code>QLabel</code> 的本质其实就是显示数据。其可以显示文本数据、图片数据。</p>
<img src="./BetterQT/QLabelShowData.png" style="zoom: 20%;" >

<p>了解了这些我们再来看 <code>QLabel</code> 的一些常用属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#text-prop"><code>text</code></a></strong><code>: QString</code></td>
<td align="left">文本内容：纯文本</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#openExternalLinks-prop"><code>openExternalLinks</code></a></strong><code>:bool</code></td>
<td align="left">文本内容：超链接</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#textFormat-prop"><code>textFormat</code></a></strong> <code>: Qt::TextFormat</code></td>
<td align="left">文本内容：不同类型的文本，如富文本等</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#alignment-prop"><code>alignment</code></a></strong><code>: Qt::Alignment</code></td>
<td align="left">文本格式：对齐方式</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#indent-prop"><code>indent</code></a></strong><code>: int</code></td>
<td align="left">文本格式：缩进</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#margin-prop"><code>margin</code></a></strong><code> : int</code></td>
<td align="left">文本格式：边距</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#wordWrap-prop"><code>wordWrap</code></a></strong><code>: bool</code></td>
<td align="left">文本格式：换行</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#pixmap-prop"><code>pixmap</code></a></strong><code>: QPixmap</code></td>
<td align="left">图片内容：显示图片</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#hasSelectedText-prop"><code>hasSelectedText</code></a></strong><code>: const bool</code></td>
<td align="left">方法：文本是否被选中</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#scaledContents-prop"><code>scaledContents</code></a></strong><code>: bool</code></td>
<td align="left">方法：是否缩放内容</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#selectedText-prop"><code>selectedText</code></a></strong><code>: const QString</code></td>
<td align="left">方法：获取选中的内容</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#textInteractionFlags-prop"><code>textInteractionFlags</code></a></strong><code>: Qt::TextInteractionFlags</code></td>
<td align="left">方法：指定标签应如何与用户输入交互，若它显示文本</td>
</tr>
</tbody></table>
<h4 id="5-2-QLineEdit-单行输入框控件"><a href="#5-2-QLineEdit-单行输入框控件" class="headerlink" title="5.2 QLineEdit 单行输入框控件"></a>5.2 <code>QLineEdit</code> 单行输入框控件</h4><p><code>QLineEdit</code> 的本质是用于不确定的输入，如用户的手机号、用户的密码。这样就给了用户一定的自由，但是我们同时需要制定一系列的规则，以校验用户的输入。例如用户输入手机号，我们需要制定一个长度为 <code>11</code> 位的规则，并且输入字符中不包含字母等，以方便开发人员进行校验。当然我们也可以配合一些其他操作来优化用户体验，如：清空（如：快速清空内容）、提示（如：提示输入格式）、记忆（如：记忆之前的输入）等。</p>
<img src="./BetterQT/QLineEditGetData.png" style="zoom: 20%;" >

<p>了解了这些我们可以看一下 <code>QLineEdit</code> 的一些常用属性（不完全，具体还是需要看文档）：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qlineedit.html#clearButtonEnabled-prop"><code>clearButtonEnabled</code></a></strong><code>: bool</code></td>
<td>清空文本框内容<br />该属性保存行编辑不为空时是否显示清除按钮。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlineedit.html#placeholderText-prop"><code>placeholderText</code></a></strong><code>: QString</code></td>
<td>占位符文本，可以用于提示输入内容。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qlineedit.html#inputMask-prop"><code>inputMask</code></a></strong><code>: QString</code></td>
<td>掩码</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T02:13:00.000Z" title="2024/5/22 10:13:00">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-05-22T04:33:42.112Z" title="2024/5/22 12:33:42">2024-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/">ECharts</a></span><span class="level-item">5 分钟读完 (大约751个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Build-Tomcat/">IDEA 2022 搭建 Tomcat 环境</a></p><div class="content"><p>[TOC]</p>
<h2 id="Tomcat-环境的搭建"><a href="#Tomcat-环境的搭建" class="headerlink" title="Tomcat 环境的搭建"></a>Tomcat 环境的搭建</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/what_how_why2020/article/details/114100385">参考教程</a></p>
<h3 id="下载-Tomcat"><a href="#下载-Tomcat" class="headerlink" title="下载 Tomcat"></a>下载 Tomcat</h3><p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/index.html">Tomcat官网地址</a><br><img src="https://img-blog.csdnimg.cn/direct/d5e359b939c040b8978dc243e260f662.png#pic_center" alt="Tomcat官网"><br>在 Tomcat 官网中下载指定版本的 Tomcat，左侧 Download 处有相应版本，这里推荐 Tomcat 9 版本（因为Tomcat 10 在配置时会出现一定的问题）。<br><img src="https://img-blog.csdnimg.cn/direct/30b899f91e23440abc83c30ac92a1ccd.png#pic_center" alt="TomcatDownload"><br>下载后解压到指定位置即可。</p>
<h3 id="配置环境变量即可"><a href="#配置环境变量即可" class="headerlink" title="配置环境变量即可"></a>配置环境变量即可</h3><p>配置 Tomcat 环境变量前一定要配置好 Java 的环境变量，尤其是JAVA_HOME，这里我一开始并没有配置 <code>JAVA_HOME</code>，我的环境变量是<code>JAVA_HOME_180=xxx</code>，这种方式Tomcat是找不到<code>JAVA_HOME</code>的，因此我又重新配置了<code>JAVA_HOME</code>。<br>我的 <code>JAVA_HOME</code> 环境变量为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=D:\JDK\jdk1.8.0_231</span><br></pre></td></tr></table></figure>
<p>下面是 Tomcat 的环境变量配置：<br>新建 <code>CATALINA_HOME</code> 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_HOME=D:\tomcat\apache-tomcat-9.0.89</span><br></pre></td></tr></table></figure>
<p>修改<code>Path</code>，在 <code>Path</code> 后添加（新建）如下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%CATALINA_HOME%\lib</span><br><span class="line">%CATALINA_HOME%\bin</span><br><span class="line">%CATALINA_HOME%\lib\servlet-api.jar</span><br></pre></td></tr></table></figure>

<h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>在命令行中，执行命令：<code>startup.bat</code>，若正常打印相关配置变量、且 Tomcat 进程被阻塞，即证明环境搭建成功。访问<code>localhost:8080</code>，出现以下界面即证明成功搭建。<br><img src="https://img-blog.csdnimg.cn/direct/28287d7ab3a145e396be286cc559d6e8.png#pic_center" alt="TomcatSuccess"><br>使用 <code>shutdown.bat</code> 命令即可使阻塞的 Tomcat 进程被关闭，推荐使用这种方式关闭 Tomcat。</p>
<h3 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h3><ol>
<li>协议处理程序初始化失败：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_59125846/article/details/122178889">参考教程</a><br>这个问题有可能是由于8080端口被占用了，在Windows中可以使用如下命令查看端口的占用情况： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|<span class="built_in">findstr</span> &quot;<span class="number">8080</span>&quot;</span><br></pre></td></tr></table></figure>
 如果确实被占用了，可以使用如下命令杀死端口号为 <code>&lt;PIDNUM&gt;</code> 的进程。 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> -PID &lt;PIDNUM&gt; -F</span><br></pre></td></tr></table></figure></li>
<li>闪退<br>可能原因是：环境变量配置不正确，仔细检查环境变量的配置。</li>
<li>乱码<br>问题描述：打开startup.bat后汉字乱码<br>解决方法：在.\apache-tomcat-9.0.43\conf下打开logging.properties文件<br>将<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>替换为<code>java.util.logging.ConsoleHandler.encoding = GBK</code></li>
</ol>
<h2 id="社区版-IDEA-如何配置-Tomcat"><a href="#社区版-IDEA-如何配置-Tomcat" class="headerlink" title="社区版 IDEA 如何配置 Tomcat"></a>社区版 IDEA 如何配置 Tomcat</h2><p>CSDN 上大多数教程使用 Maven 创建 Tomcat 项目，但是这种方法实在是过于麻烦，社区版和专业版又有些不同，找不到很多东西。</p>
<p>如何配置 IDEA 2022 社区版中的 Tomcat</p>
<ol>
<li>安装插件<br>在 File → Settings → Plugin 中安装插件，搜索 Tomcat，安装插件。<br><img src="https://img-blog.csdnimg.cn/direct/240fa059550945a28d84ff346ecfb0f7.png#pic_center" alt="SmartTomcat"></li>
<li>配置Tomcat路径<br>安装插件后，在 File → Settings → Plugin → Tomcat Server<br>添加配置如下：<br><img src="https://img-blog.csdnimg.cn/direct/0c4778a942504a91b01fcfbb42555f29.png#pic_center" alt="SmartTomcatConfig"></li>
<li>完成</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-19T08:33:06.000Z" title="2024/5/19 16:33:06">2024-05-19</time>发表</span><span class="level-item"><time dateTime="2024-07-29T07:32:43.979Z" title="2024/7/29 15:32:43">2024-07-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span> / </span><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/">Kaggle</a></span><span class="level-item">38 分钟读完 (大约5697个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/19/BELKA-2024/">BELKA_2024</a></p><div class="content"><p>[TOC]</p>
<h1 id="Leash-Bio-Predict-New-Medicines-with-BELKA"><a href="#Leash-Bio-Predict-New-Medicines-with-BELKA" class="headerlink" title="Leash Bio - Predict New Medicines with BELKA"></a>Leash Bio - Predict New Medicines with BELKA</h1><p>用 <em><strong>BELKA</strong></em> 预测新药</p>
<p>Predict small molecule-protein interactions using the Big Encoded Library for Chemical Assessment (BELKA)</p>
<p>使用化学评估大编码库（BELKA）预测小分子蛋白质相互作用</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>In this competition, you’ll develop machine learning (ML) models to predict the binding affinity of small molecules to specific protein targets – a critical step in drug development for the pharmaceutical industry that would pave the way for more accurate drug discovery. You’ll help predict which drug-like small molecules (chemicals) will bind to three possible protein targets.</p>
<p>在这场比赛中，你将开发机器学习（ML）模型来预测小分子与特定<strong>蛋白质靶标（目标蛋白）</strong>的结合亲和力——这是制药行业药物开发的关键一步，将为更准确的药物发现铺平道路。你将帮助预测哪种药物样的小分子（化学物质）将与三种可能的蛋白质靶点结合。</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Small molecule drugs are chemicals that interact with cellular protein machinery and affect the functions of this machinery in some way. Often, drugs are meant to inhibit the activity of single protein targets, and those targets are thought to be involved in a disease process. A classic approach to identify such candidate molecules is to physically make them, one by one, and then expose them to the protein target of interest and test if the two interact. This can be a fairly laborious and time-intensive process.</p>
<p><em>小分子药物是与细胞蛋白质机制相互作用并以某种方式影响该机制功能的化学物质。通常，药物旨在抑制单个蛋白质靶标的活性，而这些靶标被认为与疾病过程有关。识别这类候选分子的一种经典方法是一个接一个地进行物理制造，然后将其暴露于感兴趣的蛋白质靶点，并测试两者是否相互作用。这可能是一个相当费力和耗时的过程。</em></p>
<p>The US Food and Drug Administration (FDA) has approved roughly <a target="_blank" rel="noopener" href="https://www.fda.gov/drugs/development-approval-process-drugs/new-drugs-fda-cders-new-molecular-entities-and-new-therapeutic-biological-products">2,000 novel molecular entities</a> in its <a target="_blank" rel="noopener" href="https://www.fda.gov/about-fda/histories-fda-regulated-products/summary-nda-approvals-receipts-1938-present">entire history</a>. However, the number of chemicals in druglike space has been <a target="_blank" rel="noopener" href="https://www.nature.com/articles/432823a">estimated to be 10^60</a>, a space far too big to physically search. There are likely effective treatments for human ailments hiding in that chemical space, and better methods to find such treatments are desirable to us all.</p>
<p><em>美国食品药品监督管理局（FDA）已经批准了大约<a target="_blank" rel="noopener" href="https://www.fda.gov/drugs/development-approval-process-drugs/new-drugs-fda-cders-new-molecular-entities-and-new-therapeutic-biological-products">2000种新型分子实体</a>在其<a target="_blank" rel="noopener" href="https://www.fda.gov/about-fda/histories-fda-regulated-products/summary-nda-approvals-receipts-1938-present">整个历史</a>. 然而，类药物领域的化学物质数量<a target="_blank" rel="noopener" href="https://www.nature.com/articles/432823a">估计为$10^60$</a>，这个空间太大了，无法进行物理搜索。在这个化学空间里，可能有有效的治疗人类疾病的方法，而找到更好的治疗方法对我们所有人来说都是可取的。</em></p>
<p>To evaluate potential search methods in small molecule chemistry, competition host Leash Biosciences physically tested some 133M small molecules for their ability to interact with one of three protein targets using DNA-encoded chemical library (DEL) technology. This dataset, the Big Encoded Library for Chemical Assessment (BELKA), provides an excellent opportunity to develop predictive models that may advance drug discovery.</p>
<p><em>为了评估小分子化学中潜在的搜索方法，比赛主办方Leash Biosciences使用DNA编码化学文库（DEL）技术对约133M个小分子进行了物理测试，以确定它们与三个蛋白质靶标之一相互作用的能力。该数据集，即化学评估大编码库（BELKA），为开发可能促进药物发现的预测模型提供了极好的机会。</em></p>
<p>Datasets of this size are rare and restricted to large pharmaceutical companies. The current best-curated public dataset of this kind is perhaps <a target="_blank" rel="noopener" href="https://www.bindingdb.org/rwd/bind/index.jsp">bindingdb</a>, which, at 2.8M binding measurements, is much smaller than BELKA.</p>
<p><em>这种规模的数据集非常罕见，仅限于大型制药公司。目前这类最好的公共数据集可能是<a target="_blank" rel="noopener" href="https://www.bindingdb.org/rwd/bind/index.jsp">bindingdb</a>，在2.8M的结合测量值下，比BELKA小得多。</em></p>
<p>This competition aims to revolutionize small molecule binding prediction by harnessing ML techniques. Recent advances in ML approaches suggest it might be possible to search chemical space by inference using well-trained computational models rather than running <a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">laboratory</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">experiments</a>. Similar progress in <a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">other</a> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">fields</a> suggest using ML to search across vast spaces could be a generalizable approach applicable to many domains. We hope that by providing BELKA we will democratize aspects of computational drug discovery and assist the community in finding new lifesaving medicines.</p>
<p><em>这项竞赛旨在通过利用ML技术彻底改变小分子结合预测。ML方法的最新进展表明，使用训练有素的计算模型而不是进行<a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">实验室</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">实验</a>，通过推理搜索化学空间是可能的。<a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf">其他</a> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">领域</a>的类似进展表明，使用ML在广阔的空间中搜索可能是一种适用于许多领域的通用方法。我们希望通过提供BELKA，我们将使计算药物发现的各个方面民主化，并帮助社区寻找新的救命药物。</em></p>
<p>Here, you’ll build predictive models to estimate the binding affinity of unknown chemical compounds to specified protein targets. You may use the training data provided; alternatively, there are a number of methods to make small molecule binding predictions without relying on empirical binding data (e.g. <a target="_blank" rel="noopener" href="https://github.com/gcorso/DiffDock">DiffDock</a>, and this contest was designed to allow for such submissions).</p>
<p><em>在这里，你将建立预测模型来估计未知化合物与特定蛋白质靶标的结合亲和力。您可以使用提供的培训数据；或者，有许多方法可以在不依赖经验结合数据的情况下进行小分子结合预测（例如<a target="_blank" rel="noopener" href="https://github.com/gcorso/DiffDock">DiffDock</a>，而本次竞赛旨在允许此类提交）。</em></p>
<p>Your work will contribute to advances in small molecule chemistry used to accelerate drug discovery.</p>
<p><em>你的工作将有助于促进用于加速药物发现的小分子化学的进步。</em></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>This metric for this competition is the average precision calculated for each (protein, split group) and then averaged for the final score. Please see this <a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/leash-BELKA/discussion/503232">forum post</a> for important details.</p>
<p><em>这项比赛的指标是为每个（蛋白质、分组）计算的平均精度，然后为最终得分取平均值。请参阅此<a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/leash-BELKA/discussion/503232">论坛帖子</a>了解重要细节。</em></p>
<p>Here’s the <a target="_blank" rel="noopener" href="https://www.kaggle.com/code/metric/leash-average-map">code</a> for the implementation.</p>
<p><em>这是<a target="_blank" rel="noopener" href="https://www.kaggle.com/code/metric/leash-average-map">代码</a>以供实施。</em></p>
<h3 id="Submission-File"><a href="#Submission-File" class="headerlink" title="Submission File"></a>Submission File</h3><p>For each <code>id</code> in the test set, you must predict a probability for the binary target <code>binds</code> target. The file should contain a header and have the following format:</p>
<p><em>对于测试集中的每个</em><code>id</code>，<em>您必须预测二进制目标“绑定”目标的概率。该文件应包含一个标头，并具有以下格式：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,binds</span><br><span class="line">295246830,0.5</span><br><span class="line">295246831,0.5</span><br><span class="line">295246832,0.5</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure>

<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul>
<li><strong>April 4, 2024</strong> - Start Date.</li>
<li><strong>July 1, 2024</strong> - Entry Deadline. You must accept the competition rules before this date in order to compete.</li>
<li><strong>July 1, 2024</strong> - Team Merger Deadline. This is the last day participants may join or merge teams.</li>
<li><strong>July 8, 2024</strong> - Final Submission Deadline.</li>
</ul>
<p>All deadlines are at 11:59 PM UTC on the corresponding day unless otherwise noted. The competition organizers reserve the right to update the contest timeline if they deem it necessary.</p>
<h2 id="Prizes"><a href="#Prizes" class="headerlink" title="Prizes"></a>Prizes</h2><ul>
<li>First Prize: $12,000</li>
<li>Second Prize: $10,000</li>
<li>Third Prize: $10,000</li>
<li>Fourth Prize: $8,000</li>
<li>Fifth Prize: $5,000</li>
<li>Top Student Group: $5,000 to the highest performing student team. A team would be considered a student team if majority members (e.g. at least 3 out of a 5 member team) are students enrolled in a high school or university degree. In the case of an even number of members, half of them must be students.</li>
</ul>
<h2 id="Competition-Host"><a href="#Competition-Host" class="headerlink" title="Competition Host"></a>Competition Host</h2><p><a target="_blank" rel="noopener" href="https://www.leash.bio/">Leash Biosciences</a> is a discovery-stage biotechnology company that seeks to improve medicinal chemistry with machine learning approaches and massive data collection. Leash is comprised of wet lab scientists and dry lab scientists in equal numbers, and is proudly headquartered in Salt Lake City, Utah, USA.</p>
<h2 id="Additional-Details"><a href="#Additional-Details" class="headerlink" title="Additional Details"></a>Additional Details</h2><h3 id="Chemical-Representations"><a href="#Chemical-Representations" class="headerlink" title="Chemical Representations"></a>Chemical Representations</h3><p>One of the goals of this competition is to explore and compare many different ways of representing molecules. Small molecules <a target="_blank" rel="noopener" href="https://jcheminf.biomedcentral.com/articles/10.1186/s13321-020-00460-5">have</a> <a target="_blank" rel="noopener" href="https://wires.onlinelibrary.wiley.com/doi/10.1002/wcms.1603">been</a> [represented](<a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acsinfocus.7e7006?ref=infocus/AI_&">https://pubs.acs.org/doi/10.1021/acsinfocus.7e7006?ref=infocus%2FAI_&amp;</a> Machine Learning) <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10689004/">with</a> SMILES, graphs, 3D structures, and more, including more esoteric methods <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1801.10130">such as spherical convolutional neural nets</a>. We encourage competitors to explore not only different methods of making predictions but also to try different ways of representing the molecules.</p>
<p>We provide the molecules in SMILES format.</p>
<p><em>这场比赛的目标之一是探索和比较许多不同的分子表现方式。小分子已经用SMILES、图形、3D结构等表示，包括更深奥的方法，如球形卷积神经网络。我们鼓励竞争对手不仅探索不同的预测方法，还尝试不同的分子表示方法。</em></p>
<p><em>我们提供SMILES格式的分子。</em></p>
<h3 id="SMILES"><a href="#SMILES" class="headerlink" title="SMILES"></a>SMILES</h3><p>SMILES is a concise string notation used to represent the structure of chemical molecules. It encodes the molecular graph, including atoms, bonds, connectivity, and stereochemistry as a linear sequence of characters, by traversing the molecule graph. SMILES is widely used in machine learning applications for chemistry, such as molecular property prediction, drug discovery, and materials design, as it provides a standardized and machine-readable format for representing and manipulating chemical structures.</p>
<p>The SMILES in this dataset should be sufficient to be translated into any other chemical representation format that you want to try. A simple way to perform some of these translations is with <a target="_blank" rel="noopener" href="https://www.rdkit.org/docs/GettingStartedInPython.html">RDKit</a>.</p>
<p><em>SMILES是一种简明的字符串表示法，用于表示化学分子的结构。它通过遍历分子图，将分子图（包括原子、键、连接性和立体化学）编码为线性字符序列。SMILES广泛用于化学的机器学习应用，如分子性质预测、药物发现和材料设计，因为它为表示和操纵化学结构提供了标准化和机器可读的格式。</em><br><em>该数据集中的SMILES应该足以转换为您想要尝试的任何其他化学表示格式。执行其中一些翻译的一种简单方法是使用<a target="_blank" rel="noopener" href="https://www.rdkit.org/docs/GettingStartedInPython.html">RDKit</a>.</em></p>
<h3 id="Details-about-the-experiments"><a href="#Details-about-the-experiments" class="headerlink" title="Details about the experiments"></a>Details about the experiments</h3><h3 id="DELs-are-libraries-of-small-molecules-with-unique-DNA-barcodes-covalently-attached"><a href="#DELs-are-libraries-of-small-molecules-with-unique-DNA-barcodes-covalently-attached" class="headerlink" title="DELs are libraries of small molecules with unique DNA barcodes covalently attached"></a>DELs are libraries of small molecules with unique DNA barcodes covalently attached</h3><p>Traditional <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nrd3368">high-throughput screening</a> requires keeping individual small molecules in separate, identifiable tubes and demands a lot of liquid handling to test each one of those against the protein target of interest in a separate reaction. The logistical overhead of these efforts tends to restrict screening collections, called libraries, to 50K-5M small molecules. A scalable solution to this problem, DNA-encoded chemical libraries, was <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">described in 2009</a>. As DNA sequencing got <a target="_blank" rel="noopener" href="https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost">cheaper and cheaper</a>, it became clear that DNA itself could be used as a label to identify, and deconvolute, collections of molecules in a complex mixture. <a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41573-023-00713-6">DELs</a> <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8369695/">leverage</a> this DNA sequencing technology.</p>
<p>These barcoded small molecules are in a pool (many in a single tube, rather than one tube per small molecule) and are exposed to the protein target of interest in solution. The protein target of interest is then rinsed to remove small molecules in the DEL that don’t bind the target, and the remaining binders are collected and their DNA sequenced.</p>
<p><strong>DEL是共价连接有独特DNA条形码的小分子库</strong><br><em>传统<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nrd3368">高通量筛选</a>需要将单个小分子保持在单独的、可识别的管中，并且需要大量的液体处理来在单独的反应中针对感兴趣的蛋白质靶标测试其中的每一个。这些工作的后勤开销往往将筛选收藏（称为文库）限制在5000万至500万个小分子以内。这个问题的一个可扩展的解决方案，DNA编码的化学文库，<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">在2009年描述</a>. 随着DNA测序变得<a target="_blank" rel="noopener" href="https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost">越来越便宜</a>，很明显，DNA本身可以用作标签来识别和消除复杂混合物中分子的聚集。<a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41573-023-00713-6%E5%BD%B1%E5%93%8D%E5%8A%9Bhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC8369695/">DELs</a>这种DNA测序技术。</em><br><em>这些条形码小分子在一个池中（许多在单管中，而不是每个小分子一管），并暴露于溶液中感兴趣的蛋白质靶标。然后冲洗感兴趣的蛋白质靶标，以去除DEL中不与靶标结合的小分子，收集剩余的结合物并对其DNA进行测序。</em></p>
<h3 id="DELs-are-manufactured-by-combining-different-building-blocks"><a href="#DELs-are-manufactured-by-combining-different-building-blocks" class="headerlink" title="DELs are manufactured by combining different building blocks"></a>DELs are manufactured by combining different building blocks</h3><p>An intuitive way to think about DELs is to imagine a Mickey Mouse head as an example of a small molecule in the DEL. We attach the DNA barcode to Mickey’s chin. Mickey’s left ear is connected by a zipper; Mickey’s right ear is connected by velcro. These attachment points of zippers and velcro are analogies to different chemical reactions one might use to construct the DEL.</p>
<p>We could purchase ten different Mickey Mouse faces, ten different zipper ears, and ten different velcro ears, and use them to construct our small molecule library. By creating every combination of these three, we’ll have 1,000 small molecules, but we only needed thirty building blocks (faces and ears) to make them. This combinatorial approach is what allows DELs to have so many members: the library in this competition is composed of 133M small molecules. The 133M small molecule library used here, AMA014, was provided by <a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>. It has a triazine core and superficially resembles the DELs described <a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">here</a>.</p>
<p><strong>DEL是通过组合不同的构建块来制造的</strong><br>一个思考DEL的直观方法是想象一个米老鼠的头作为DEL中一个小分子的例子。我们把DNA条形码贴在米奇的下巴上。米奇的左耳由拉链连接；米奇的右耳是用尼龙搭扣连接的。拉链和尼龙搭扣的这些连接点类似于可能用于构建DEL的不同化学反应。<br>我们可以购买十个不同的米老鼠脸、十个不同拉链耳朵和十个不同尼龙搭扣耳朵，并用它们来构建我们的小分子库。通过创建这三者的每一个组合，我们将拥有1000个小分子，但我们只需要30个构建块（脸和耳朵）就可以制造它们。这种组合方法使DEL能够拥有如此多的成员：这场竞争中的文库由133M个小分子组成。这里使用的133M小分子文库AMA014由<a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>提供。它有一个三嗪核心，表面上类似于<a target="_blank" rel="noopener" href="https://www.nature.com/articles/nchembio.211">此处</a>描述的DEL。</p>
<img src="https://www.googleapis.com/download/storage/v1/b/kaggle-user-content/o/inbox%2F1095143%2F1901c6caa0c6c011617f4dec525d7bbe%2FKaggle%20v2%20(1).png?generation=1712179256934503&alt=media">

<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Leash Biosciences is grateful for the generous cosponsorship of <a target="_blank" rel="noopener" href="https://www.topharvestcap.com/">Top Harvest Capital</a> and <a target="_blank" rel="noopener" href="https://www.alphama.com.cn/en/about/">AlphaMa</a>.</p>
<h2 id="Citation"><a href="#Citation" class="headerlink" title="Citation"></a>Citation</h2><p>Andrew Blevins, Ian K Quigley, Brayden J Halverson, Nate Wilkinson, Rebecca S Levin, Agastya Pulapaka, Walter Reade, Addison Howard. (2024). Leash Bio - Predict New Medicines with BELKA. Kaggle. <a target="_blank" rel="noopener" href="https://kaggle.com/competitions/leash-BELKA">https://kaggle.com/competitions/leash-BELKA</a></p>
<hr>
<h2 id="Dataset-Description"><a href="#Dataset-Description" class="headerlink" title="Dataset Description"></a>Dataset Description</h2><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>The examples in the competition dataset are represented by a binary classification of whether a given small molecule is a binder or not to one of three protein targets. The data were collected using DNA-encoded chemical library (DEL) technology.</p>
<p><em>比赛数据集中的例子由给定小分子是否与三个蛋白质靶标之一结合的二元分类表示。使用DNA编码化学文库（DEL）技术收集数据。</em></p>
<p>We represent chemistry with SMILES (<a target="_blank" rel="noopener" href="https://archive.epa.gov/med/med_archive_03/web/html/smiles.html">Simplified Molecular-Input Line-Entry System</a>) and the labels as binary binding classifications, one per protein target of three targets.</p>
<p>我们用SMILES（<a target="_blank" rel="noopener" href="https://archive.epa.gov/med/med_archive_03/web/html/smiles.html">简化分子输入 行输入系统</a>)和二元绑定分类来表示化学，三个靶标中的每个蛋白质靶标都有一个。</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a><strong>Files</strong></h2><p><strong>[train&#x2F;test].[csv&#x2F;parquet]</strong> - The train or test data, available in both the csv and parquet formats.</p>
<ul>
<li><code>id</code> - A unique example_id that we use to identify the molecule-binding target pair.</li>
<li><code>buildingblock1_smiles</code> - The structure, in SMILES, of the first building block</li>
<li><code>buildingblock2_smiles</code> - The structure, in SMILES, of the second building block</li>
<li><code>buildingblock3_smiles</code> - The structure, in SMILES, of the third building block</li>
<li><code>molecule_smiles</code> - The structure of the fully assembled molecule, in SMILES. This includes the three building blocks and the triazine core. Note we use a <code>[Dy]</code> as the stand-in for the DNA linker.</li>
<li><code>protein_name</code> - The protein target name</li>
<li><code>binds</code> - The target column. A binary class label of whether the molecule binds to the protein. Not available for the test set.</li>
</ul>
<p><strong>sample_submission.csv</strong> - A sample submission file in the correct format</p>
<p><strong>[train&#x2F;test].[csv&#x2F;parquet]</strong> - 训练或测试数据，csv和parquet格式均可。</p>
<ul>
<li><code>id</code> - 我们用来识别分子结合靶标对的唯一示例_id。</li>
<li><code>buildingblock1_smiles</code> - 第一个构建块的结构，以SMILES表示</li>
<li><code>buildingblock2_smiles</code> - 第二个构建块的结构，以SMILES表示</li>
<li><code>buildingblock3_smiles</code> - 第三个构建块的结构，以SMILES表示</li>
<li><code>molecule_smiles</code> - 完全组装的分子的结构，以SMILES表示。这包括三个构建块和三嗪核心。请注意，我们使用<code>[Dy]</code>作为DNA连接子的替代。</li>
<li><code>protein_name</code> - 蛋白质靶标名称</li>
<li><code>binds</code> - 目标列。分子是否与蛋白质结合的二进制类标签。不适用于测试集。</li>
</ul>
<h2 id="Competition-data"><a href="#Competition-data" class="headerlink" title="Competition data"></a><strong>Competition data</strong></h2><p>All data were generated in-house at Leash Biosciences. We are providing roughly 98M training examples per protein, 200K validation examples per protein, and 360K test molecules per protein. To test generalizability, the test set contains building blocks that are not in the training set. These datasets are very imbalanced: roughly 0.5% of examples are classified as binders; we used 3 rounds of selection in triplicate to identify binders experimentally. Following the competition, Leash will make all the data available for future use (3 targets × 3 rounds of selection × 3 replicates × 133M molecules, or 3.6B measurements).</p>
<p><em>所有数据均由Leash Biosciences公司内部生成。我们为每种蛋白质提供了大约 98M 个训练实例，为每种蛋白提供了 200K 个验证实例，为每个蛋白质提供了 360K 个测试分子。为了测试可推广性，测试集包含不在训练集中的构建块。这些数据集非常不平衡：大约0.5%的示例被归类为绑定；我们使用了三轮一式三份的选择来实验鉴定粘合剂。比赛结束后，Leash将提供所有数据供未来使用（3个靶标×3轮选择×3个重复×3.33M个分子，或3.6B测量值）。</em></p>
<h2 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a><strong>Targets</strong></h2><p>Proteins are encoded in the genome, and names of the genes encoding those proteins are typically bestowed by their discoverers and regulated by the <a target="_blank" rel="noopener" href="https://www.genenames.org/">Hugo Gene Nomenclature Committee</a>. The protein products of these genes can sometimes have different names, often due to the history of their discovery.</p>
<p>We screened three protein targets for this competition.</p>
<p>蛋白质在基因组中编码，编码这些蛋白质的基因的名称通常由其发现者命名，并由<a target="_blank" rel="noopener" href="https://www.genenames.org/">雨果基因命名委员会</a>监管。这些基因的蛋白质产物有时可能有不同的名称，通常是由于它们的发现历史。<br>我们为这次比赛筛选了三个蛋白质靶点。</p>
<h3 id="EPHX2-sEH"><a href="#EPHX2-sEH" class="headerlink" title="EPHX2 (sEH)"></a><strong>EPHX2 (sEH)</strong></h3><p>The first target, epoxide hydrolase 2, is encoded by the EPHX2 genetic locus, and its protein product is commonly named “soluble epoxide hydrolase”, or abbreviated to sEH. Hydrolases are enzymes that catalyze certain chemical reactions, and EPHX2&#x2F;sEH also hydrolyzes certain phosphate groups. EPHX2&#x2F;sEH is a potential drug target for high blood pressure and diabetes progression, and small molecules inhibiting EPHX2&#x2F;sEH from earlier DEL efforts <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8429121/">made it to clinical trials</a>.</p>
<p>EPHX2&#x2F;sEH was also screened with DELs, and hits predicted with ML approaches, in a <a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html">recent</a> <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452">study</a> but the screening data were not published. We included EPHX2&#x2F;sEH to allow contestants an external gut check for model performance by comparing to these previously-published results.</p>
<p>We screened EPHX2&#x2F;sEH <a target="_blank" rel="noopener" href="https://www.caymanchem.com/product/10011669/soluble-epoxide-hydrolase-(human-recombinant)">purchased from Cayman Chemical</a>, a life sciences commercial vendor. For those contestants wishing to incorporate protein structural information in their submissions, the amino sequence is positions 2-555 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/P34913/entry#sequences">P34913</a>, the crystal structure can be found in <a target="_blank" rel="noopener" href="https://www.rcsb.org/structure/3i28">PDB entry 3i28</a>, and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/P34913">34913</a>. Additional EPHX2&#x2F;sEH crystal structures with ligands bound can be found in PDB.</p>
<p>第一个靶标环氧化物水解酶2由EPHX2基因座编码，其蛋白产物通常被命名为“可溶性环氧化物水解酶”，或缩写为sEH。水解酶是催化某些化学反应的酶，EPHX2&#x2F;sEH也水解某些磷酸基团。EPHX2&#x2F;sEH是高血压和糖尿病进展的潜在药物靶点，早期DEL研究中抑制EPHX2&#x2F;s EH的小分子<a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8429121/">已进入临床试验</a>.<br>EPHX2&#x2F;sEH也用DEL进行了筛选，并用ML方法预测了命中率(<a target="_blank" rel="noopener" href="https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html%E5%AD%A6%E4%B9%A0https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452)%E4%BD%86%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B2%A1%E6%9C%89%E5%85%AC%E5%B8%83%E3%80%82%E6%88%91%E4%BB%AC%E7%BA%B3%E5%85%A5%E4%BA%86EPHX2/sEH%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B8%8E%E4%B9%8B%E5%89%8D%E5%85%AC%E5%B8%83%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%EF%BC%8C%E8%AE%A9%E5%8F%82%E8%B5%9B%E8%80%85%E8%83%BD%E5%A4%9F%E5%AF%B9%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%A4%96%E9%83%A8%E6%A3%80%E6%9F%A5%E3%80%82">https://blog.research.google/2020/06/unlocking-chemome-with-dna-encoded.html学习https://pubs.acs.org/doi/10.1021/acs.jmedchem.0c00452)但筛选数据没有公布。我们纳入了EPHX2/sEH，通过与之前公布的结果进行比较，让参赛者能够对模型性能进行外部检查。</a><br>我们筛选了EPHX2&#x2F;sEH<a target="_blank" rel="noopener" href="https://www.caymanchem.com/product/10011669/soluble-epoxide-hydrolase-%EF%BC%88%E4%BA%BA%E7%B1%BB%E9%87%8D%E7%BB%84%EF%BC%89%EF%BC%89%EF%BC%8C%E4%B8%80%E5%AE%B6%E7%94%9F%E5%91%BD%E7%A7%91%E5%AD%A6%E5%95%86%E4%B8%9A%E4%BE%9B%E5%BA%94%E5%95%86%E3%80%82%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E5%B8%8C%E6%9C%9B%E5%9C%A8%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81%E4%B8%AD%E5%8A%A0%E5%85%A5%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%82%E8%B5%9B%E8%80%85%EF%BC%8C%E6%B0%A8%E5%9F%BA%E9%85%B8%E5%BA%8F%E5%88%97%E4%BD%8D%E4%BA%8EUniProt%E6%9D%A1%E7%9B%AE%E7%9A%842-555%E4%BD%8D[P34913](https://www.uniprot.org/uniprotkb/P34913/entry#sequences)%EF%BC%8C%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%9C%A8[PDB%E6%9D%A1%E7%9B%AE3i28]%E4%B8%AD%E6%89%BE%E5%88%B0(https://www.rcsb.org/structure/3i28)%EF%BC%8C%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E5%9C%A8AlphaFold2%E6%9D%A1%E7%9B%AE[34913]%E4%B8%AD%E6%89%BE%E5%88%B0(https://alphafold.ebi.ac.uk/entry/P34913">购自开曼化学</a>. 在PDB中可以发现具有结合配体的额外的EPHX2&#x2F;sEH晶体结构。</p>
<h3 id="BRD4"><a href="#BRD4" class="headerlink" title="BRD4"></a><strong>BRD4</strong></h3><p>The second target, bromodomain 4, is encoded by the BRD4 locus and its protein product is also named BRD4. Bromodomains bind to protein spools in the nucleus that DNA wraps around (called histones) and affect the likelihood that the DNA nearby is going to be transcribed, producing new gene products. Bromodomains play roles in cancer progression and a number of drugs <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10096006/">have been discovered to inhibit their activities</a>.</p>
<p>BRD4 <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01670">has been screened with DEL approaches previously</a> but the screening data were not published. We included BRD4 to allow contestants to evaluate candidate molecules for oncology indications.</p>
<p>We screened BRD4 <a target="_blank" rel="noopener" href="https://www.activemotif.com/catalog/details/31594/recombinant-brd4-44-460-protein">purchased from Active Motif</a>, a life sciences commercial vendor. For those contestants wishing to incorporate protein structural information in their submissions, the amino acid sequence is positions 44-460 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/O60885/entry#sequences">O60885-1</a>, the crystal structure (for a single domain) can be found in PDB entry <a target="_blank" rel="noopener" href="https://www.rcsb.org/structure/7USK">7USK</a> and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/O60885">O60885</a>. Additional BRD4 crystal structures with ligands bound can be found in PDB.</p>
<h3 id="ALB-HSA"><a href="#ALB-HSA" class="headerlink" title="ALB (HSA)"></a><strong>ALB (HSA)</strong></h3><p>The third target, serum albumin, is encoded by the ALB locus and its protein product is also named ALB. The protein product is sometimes abbreviated as HSA, for “human serum albumin”. ALB, the most <a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/books/NBK459198/">common protein in the blood</a>, is used to drive osmotic pressure (to bring fluid back from tissues into blood vessels) and to transport many ligands, hormones, fatty acids, and more.</p>
<p>Albumin, being the most abundant protein in the blood, often plays a role in absorbing candidate drugs in the body and sequestering them from their target tissues. Adjusting candidate drugs to bind less to albumin and other blood proteins <a target="_blank" rel="noopener" href="https://pubs.acs.org/doi/10.1021/acsptsci.2c00115">is a strategy to help these candidate drugs be more effective</a>.</p>
<p>ALB <a target="_blank" rel="noopener" href="https://pubmed.ncbi.nlm.nih.gov/25650139/">has been screened with DEL approaches previously</a> but the screening data were not published. We included ALB to allow contestants to build models that might have a larger impact on drug discovery across many disease types. The ability to predict ALB binding well would allow drug developers to improve their candidate small molecule therapies much more quickly than physically manufacturing many variants and testing them against ALB empirically in an iterative process.</p>
<p>We screened ALB <a target="_blank" rel="noopener" href="https://www.abcam.com/products/proteins-peptides/recombinant-human-serum-albumin-protein-his-tag-ab217817.html">purchased from Active Motif</a>. For those contestants wishing to incorporate protein structural information in their submissions, the amino acid sequence is positions 25 to 609 from UniProt entry <a target="_blank" rel="noopener" href="https://www.uniprot.org/uniprotkb/P02768/entry#sequences">P02768</a>, the crystal structure can be found in PDB entry <a target="_blank" rel="noopener" href="https://www.ebi.ac.uk/pdbe/entry/pdb/1AO6">1AO6</a>, and predicted structure can be found in AlphaFold2 entry <a target="_blank" rel="noopener" href="https://alphafold.ebi.ac.uk/entry/P02768">P02768</a>. Additional ALB crystal structures with ligands bound can be found in PDB.</p>
<p>Good luck!</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-07T12:22:34.000Z" title="2024/5/7 20:22:34">2024-05-07</time>发表</span><span class="level-item"><time dateTime="2024-05-27T02:24:04.468Z" title="2024/5/27 10:24:04">2024-05-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/">树(Tree)</a></span><span class="level-item">17 分钟读完 (大约2598个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/07/Tree/">Tree</a></p><div class="content"><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h2><p>[TOC]</p>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树是一种非常重要的非线性数据结构，树的一个节点可能会生出多个分支。一般而言，一棵树会包含一个根节点，向下延伸出若干子节点，每个末端的节点被称为叶子节点。<br><img src="/./Tree/Tree.png"></p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>有根树存在一个<strong>根节点Root</strong>，如下：<br><img src="/./Tree/RootTree.drawio.png"><br>对于图中概念的一些补充：</p>
<ul>
<li>节点拥有的子节点个数叫做节点的<strong>度</strong>。</li>
<li>具有相同深度的节点处于同一层，方便表示。</li>
<li>节点和节点之间的线叫做<strong>边</strong>。</li>
<li>路径：指从树上一点到另外一点所经过的<strong>不重合的</strong>点和边的集合，题目中有时会单指点或边的集合。</li>
<li>一颗 $n$ 个节点的树，一定有 $n-1$ 条边</li>
</ul>
<h4 id="无根树"><a href="#无根树" class="headerlink" title="无根树"></a>无根树</h4><hr>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>二叉树</strong>是一种<strong>特殊的树</strong>。</p>
<ul>
<li>所有节点的度都不超过2的树称为二叉树。</li>
<li>因为每个二叉树的节点最多只会有两个子结点，它的两个子节点一般会被称为左、右儿子，两棵子树一般会被称为左、右子树。</li>
<li>左、右儿子甚至根节点本身都有可能缺失（一个节点都没有可以称为空二叉树）。</li>
</ul>
<h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><p>二叉树也有两个比较特殊的类型：<strong>满二叉树和完全二叉树</strong>。<br><img src="/./Tree/FullBinaryTree.png"></p>
<ul>
<li><strong>满二叉树</strong>：所有层的节点全满。<ul>
<li>满二叉树的一些规律<ul>
<li>第 $n$ 层的节点个数为 $2^{n-1}$</li>
<li>深度为 $n$ 的满二叉树节点数为 $2^0 + 2^1 + 2^2 + \dots + 2^{n-1}&#x3D; 2^n-1$</li>
</ul>
</li>
</ul>
</li>
<li><strong>完全二叉树</strong>：除了最后一层以外，其他层的节点个数全满，而且最后一层的节点从左到右排满直到最后一个节点。<ul>
<li>完全二叉树的一些规律<ul>
<li>完全二叉树的节点个数不会少于 $(2^{n-1}-1)+1 &#x3D; 2^{n-1}$</li>
<li>完全二叉树的节点个数不会多于 $2^{n} - 1$</li>
<li>一棵完全二叉树，设当前节点为 $t$，其父节点为 $t&#x2F;2$，其左儿子为 $2t$，其右儿子为 $2t+1$，借助该规律，我们可以将完全二叉树使用数组进行存储。<br><img src="/./Tree/BinaryTree_NodeNumber.drawio.png"></li>
</ul>
</li>
</ul>
</li>
<li>完全二叉树的存储<ul>
<li>完全二叉树由于它的特性，可以简单用数组来模拟其结构</li>
<li>一般会以数组$[1]$位置为根节点建立二叉树</li>
<li>数组$[t]$位置的左儿子和右儿子对应的位置分别为$[2t]$和$[2t+1]$，父节点的位置为$[t&#x2F;2]$。</li>
<li>堆、线段树等数据结构的建立也会参考这个方式</li>
</ul>
</li>
</ul>
<p>完全二叉树的建立（使用数组），使用这种方法建立非完全二叉树，会导致空间的浪费：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="built_in">UpdateData</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子节点存在</span></span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">2</span> * t);</span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">2</span> * t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们可以使用其他方法来完成一般二叉树的存储，可以用数组下标模拟节点编号，用多个数组来记录节点信息。为了方便，我们也可以使用结构体来存储这些信息：<br><img src="/./Tree/NormalBinaryTree.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用结构体来实现上述操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> l, r, fa;</span><br><span class="line">&#125;a[<span class="number">100010</span>];</span><br></pre></td></tr></table></figure>
<p>当然，作为一种树形结构，使用指针显然是更合适的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针来实现上述操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode* l;</span><br><span class="line">    TreeNode* r;</span><br><span class="line">    TreeNode* fa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* root;</span><br></pre></td></tr></table></figure>
<p>使用指针的一些操作：</p>
<ul>
<li>新建节点：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode *l, *r, *fa;   <span class="comment">// 初始为 NULL</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)&#123; value = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br></pre></td></tr></table></figure></li>
<li>根节点初始化：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* root;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br></pre></td></tr></table></figure></li>
<li>插入节点：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(TreeNode* fa, TreeNode* p, <span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">// flag = 0 插入到左边</span></span><br><span class="line">    <span class="comment">// flag = 1 插入到右边</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">        fa-&gt;l = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa-&gt;r = p;</span><br><span class="line">    p-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line"><span class="built_in">Insert</span>(fa, treeNode, flag);</span><br></pre></td></tr></table></figure></li>
<li>删除节点  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 删除节点</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历可分为先序遍历、中序遍历和后序遍历，这三种方式以访问根节点的时间来区分。<br><strong>先序遍历（Degree-Left-Right, DLR）</strong>：根→左→右<br><strong>中序遍历（Left-Degree-Right, LDR）</strong>：左→根→右<br><strong>先序遍历（Left-Right-Degree, LRD）</strong>：左→右→根</p>
<!-- ![](./Tree/DLR_LDR_LRD.png) -->
<img src="./Tree/DLR_LDR_LRD.png" width=350px height=auto>

<p>在该图中，先序遍历的结果为 <code>1 2 4 5 3 6 7</code>，先序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">preOrder</span>(treeNode-&gt;l);</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">preOrder</span>(treeNode-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">preOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>在该图中，中序遍历的结果为 <code>4 2 5 1 6 3 7</code>，中序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">inOrder</span>(treeNode-&gt;l);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">inOrder</span>(treeNode-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>在该图中，后序遍历的结果为 <code>4 5 2 6 7 3 1</code>，后序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;l)     <span class="built_in">postOrder</span>(treeNode-&gt;l);</span><br><span class="line">    <span class="keyword">if</span>(treeNode-&gt;r)     <span class="built_in">postOrder</span>(treeNode-&gt;r);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">postOrder</span>(root);</span><br></pre></td></tr></table></figure>

<p>除了上述的几种遍历方式，还有层级遍历（BFS）方式对树进行遍历。层级遍历是借助队列（Queue）来实现的，其过程可以描述如下：<br><img src="/./Tree/BFSTree.png"></p>
<p>层级遍历的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">1</span>, rear = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear) &#123;</span><br><span class="line">        TreeNode* p = q[front];     <span class="comment">// 选取队列中最前面的节点</span></span><br><span class="line">        front++;</span><br><span class="line">        cout &lt;&lt; p-&gt;value &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;l)    q[++rear] = p-&gt;l;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;r)    q[++rear] = p-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(root);</span><br></pre></td></tr></table></figure>
<h4 id="计算节点的深度"><a href="#计算节点的深度" class="headerlink" title="计算节点的深度"></a>计算节点的深度</h4><p>我们可以在遍历树的时候同时进行节点深度的记录，简单来讲就是：<br>$$depth_{儿子} &#x3D; depth_{父亲} + 1$$</p>
<h3 id="有根树-Tree"><a href="#有根树-Tree" class="headerlink" title="有根树(Tree)"></a>有根树(Tree)</h3><p>这里不再是二叉树这种特殊的树，而是一般意义的树。</p>
<h4 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h4><ul>
<li><code>vector/链表</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector 方式</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nodes[N + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 x 和 y之间构建一条边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    nodes[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 x 的所有儿子</span></span><br><span class="line"><span class="type">int</span> l = nodes[x].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    nodes[x][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: nodes[x]) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> where;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *head[N + <span class="number">1</span>], a[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>], l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    a[++i].where = y;</span><br><span class="line">    a[l].next = head[x];</span><br><span class="line">    head[x] = &amp;a[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 x 的所有儿子</span></span><br><span class="line"><span class="keyword">for</span> (Node* p = head[x]; p; p-&gt;next) &#123;</span><br><span class="line">    p-&gt;where;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="有根树遍历"><a href="#有根树遍历" class="headerlink" title="有根树遍历"></a>有根树遍历</h4><p>遍历一棵树一般有 DFS 和 BFS 两种方式。<br><strong>DFS</strong>：深度优先搜索，从一个节点开始，选择一条路径并走到底，并通过回溯来访问所有节点。<br><strong>BFS</strong>：广度优先搜索，也称层级顺序探索，从一个节点开始，遍历该节点的所有子节点，或称按照深度从小到大的顺序依次遍历所有点。<br><img src="./Tree/RootTreeDFS.png" width=350px height=auto></p>
<ul>
<li><strong>有根树的DFS序</strong><br>有根树的 DFS 序是指，从根节点开始的深度优先搜索过程中，依次记录的点所生成的序列。<br>对于上图，所生成的 DFS 序即为 <code>ABCDEFGHIJKLMN</code>。当然这个只是其中一种 DFS 序，因为 <code>A</code> 可以走向 <code>B</code>，也可以走向 <code>E</code>，当然也可以走向 <code>F</code>。不同的走向会有不同的 DFS 序。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; dfn;      <span class="comment">// 用于存储 DFS 序, 常用 DFN 表示 DFS 序</span></span><br><span class="line">                      <span class="comment">// dfn 中的元素即为 DFS 序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="comment">// for x的所有儿子y &#123; dfs(y); &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (Node* p = x; p; p-&gt;next)&#123; <span class="built_in">dfs</span>(p-&gt;next) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(root);</span><br></pre></td></tr></table></figure></li>
<li><strong>有根树的BFS序</strong><br>有根树的 BFS 序是指，从根节点开始的广度优先搜索过程中，依次记录的点所生成的序列。<br>对于上图，所生成的 BFS 序即为 <code>ABENCDFMGJHIKL</code>。当然这个只是其中一种 BFS 序，因为同一深度可能会有不同的遍历顺序，如深度为 $2$ 时，<code>BEN</code>、<code>BNE</code>、<code>EBN</code>、…都是可能出现的顺序，不同的顺序会有不同的 BFS 序。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 root 加入队列 q;</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历队列 q</span></span><br><span class="line">    <span class="keyword">while</span>(队列 q 非空) &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>();    <span class="comment">// 取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();        <span class="comment">// x 出队</span></span><br><span class="line">        <span class="keyword">for</span> x的所有儿子y &#123;</span><br><span class="line">            y 入队;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="无根树-Unrooted-Tree"><a href="#无根树-Unrooted-Tree" class="headerlink" title="无根树(Unrooted Tree)"></a>无根树(Unrooted Tree)</h3><p>无根树即没有固定根结点的树，树中的节点只有相邻关系而没有父子关系。无根树有几种等价的形式化定义（建议搭配图论一起学习）：</p>
<ul>
<li>有 $n$ 个结点， $n−1$ 条边的连通无向图</li>
<li>无向无环的连通图</li>
<li>任意两个结点之间有且仅有一条简单路径的无向图</li>
<li>任何边均为桥的连通图</li>
<li>没有圈，且在任意不同两点间添加一条边之后所得图含唯一的一个圈的图</li>
</ul>
<p>如下图所示，即一棵无根树：<br><img src="./Tree/UnrootTree.png" width=350px height=auto><br>无根树中的任意一个节点可以被指定为根，变成一棵有根树。</p>
<h4 id="无根树的遍历"><a href="#无根树的遍历" class="headerlink" title="无根树的遍历"></a>无根树的遍历</h4><p>遍历一棵无根树一般也有 DFS 和 BFS 两种方式。<br>遍历无根树时，可以从任意一个节点开始，以类似有根树的方式，遍历整棵树。唯一的区别是在进入一个新节点时，需要记录这个节点的来源节点，在遍历新节点的相邻节点时，避免重复访问来源节点即可。</p>
<ul>
<li><strong>无根树的 DFS</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> x的所有响铃节点y &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">-1</span>, x);</span><br></pre></td></tr></table></figure></li>
<li><strong>无根树的 BFS</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 x 加入队列 q，x 的来源为空</span></span><br><span class="line">    <span class="keyword">while</span> (队列 q 非空) &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>();</span><br><span class="line">        from = x的来源节点;</span><br><span class="line">        q.pop;</span><br><span class="line">        <span class="keyword">for</span> x的所有相邻节点 y &#123;</span><br><span class="line">            <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">                y 入队;</span><br><span class="line">                记录 y 的来源节点为 x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(x);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><ul>
<li>树的直径是指树上任意两个节点之间最长（路径的长度一般指的是路径经过的边的数量）的路径。</li>
<li>一棵树可以存在很多条直径，他们的长度相等。</li>
<li>树的直径的中间节点被称为树的中心（图中C节点），如果直径上有偶数个节点，那么中间的两个节点都可以是树的中心。</li>
<li>树的中心到其它点的最长路径最短。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-07T12:06:30.000Z" title="2024/5/7 20:06:30">2024-05-07</time>发表</span><span class="level-item"><time dateTime="2024-05-22T12:07:12.232Z" title="2024/5/22 20:07:12">2024-05-22</time>更新</span><span class="level-item">10 分钟读完 (大约1450个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/07/Heap/">Heap</a></p><div class="content"><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>[TOC]</p>
<h3 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h3><h4 id="二叉堆的基本概念和基本性质"><a href="#二叉堆的基本概念和基本性质" class="headerlink" title="二叉堆的基本概念和基本性质"></a>二叉堆的基本概念和基本性质</h4><p>堆是一种树形结构，有二叉树就有二叉堆。</p>
<ul>
<li>二叉堆总是一棵完全二叉树</li>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>根节点的值为整个堆中的最小&#x2F;最大值。<ul>
<li>父节点中的值<strong>大于等于</strong>两个子节点中的值，根节点的值最大的堆称为<strong>大根堆</strong>。</li>
<li>父节点中的值<strong>小于等于</strong>两个子节点中的值，根节点的值最小的堆称为<strong>小根堆</strong>。</li>
</ul>
</li>
<li>我们可以在堆中插入和删除元素，然后通过调整元素的位置来维护堆的性质。</li>
</ul>
<h4 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h4><ul>
<li>堆的初始化<br>在建立堆之前，需要初始化一些东西：<ul>
<li>一个空数组，用于存储堆中的元素</li>
<li>一个记录堆中元素个数的变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heap[MAXSIZE + <span class="number">1</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>堆中元素的插入<br>堆在插入时，需要首先将插入元素放在数组末尾，然后插入元素不断的和其父节点比较，直到位置合适。下面是对小根堆插入过程的模拟：<br><img src="/./Heap/HeapInsert.png"><br>小根堆插入的代码如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; heap[k] &lt; heap[k/<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[k/<span class="number">2</span>]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
大根堆和小根堆插入元素的方式基本相同，只需要改变大于&#x2F;小于符号，插入操作的时间复杂度为 $O(log;n)$</li>
<li>堆顶元素的删除<br>堆最常用的功能就是<strong>维护最小&#x2F;最大值</strong>。在使用小根堆时，我们经常会求得最小的数字，然后让它出堆，这时就要从堆中删除堆顶数据。<br>这时除了堆顶为空，它的左子树堆和右子树堆仍满堆结构。为了操作简单，一般选择<strong>将堆尾部元素放到堆顶，然后将其逐步下移的方式</strong>，下移时，如进行交换操作，交换的是该节点左右儿子中较小的一个与该节点。<br>下图模拟小根堆删除堆顶元素的操作：<br><img src="/./Heap/HeapDelete.png"><br>小根堆删除元素的代码如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">        <span class="type">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k*<span class="number">2</span>+<span class="number">1</span> &lt; len &amp;&amp; heap[j+<span class="number">1</span>] &lt; heap[j])  j++;</span><br><span class="line">        <span class="keyword">if</span>(heap[k] &lt;= heap[j])  <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆中任意位置的删除<br>删除堆中的任意一个元素时，我们可以发现这个时候这个元素下的左子树堆和右子树堆也满足堆结构，但是我们不可以像删除堆顶节点一样，和数组尾部元素互换，然后尝试下移，原因如下：<br><img src="/./Tree/NormalHeapDelete.drawio.png"><br>此时无需向下调整，因为 $5&lt;8$ 且 $5&lt;9$，依旧满足小根堆的性质，但是其父节点 $6&gt;5$，破坏了小根堆的性质，因此此时需要上移。<br>所以我们删除堆中的任意一个元素，跟数组尾元素互换时，不仅要考虑下移，还有可能会上移。小根堆中删除一个位于数组位置 <code>pos</code> 的元素的代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == len) &#123;</span><br><span class="line">        heap[len] = <span class="number">0</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = heap[pos], y = heap[len];</span><br><span class="line">    <span class="built_in">swap</span>(heap[pos], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">        <span class="comment">// 堆尾的数比原数大, 尝试上移</span></span><br><span class="line">        <span class="built_in">up</span>(pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 堆尾的数比原数小, 尝试下移</span></span><br><span class="line">        <span class="built_in">down</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="STL-中的-priority-queue-优先队列"><a href="#STL-中的-priority-queue-优先队列" class="headerlink" title="STL 中的 priority_queue(优先队列)"></a>STL 中的 priority_queue(优先队列)</h3><p>STL 库中的 <code>priority_queue</code> 是一个很类似于堆的结构，它包含如下操作：</p>
<ul>
<li><code>empty</code> - 判断是否为空</li>
<li><code>size</code> - 返回队列内元素个数</li>
<li><code>top</code> - 访问队首元素</li>
<li><code>push</code> - 往队列中插入一个元素</li>
<li><code>pop</code> - 弹出队首元素</li>
</ul>
<p>这里的 <code>priority_queue</code> 相当于堆，队首元素相当于堆顶元素。<br>我们可以使用如下语句创建一个小根堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>这段C++语句创建了一个优先队列 <code>q</code>，其中元素类型为 <code>int</code>，底层容器使用 <code>vector&lt;int&gt;</code>，并且使用 <code>greater&lt;int&gt;</code> 作为比较器。在优先队列中，当元素被插入队列时，会根据比较器的规则进行排序，从而实现堆的性质。</p>
<p>在这段语句中，<code>greater&lt;int&gt;</code> 是一个函数对象，代表使用“大于”运算符进行比较。因此，当要创建一个小根堆时，即希望队列中的元素按照从小到大的顺序排列，可以利用 greater<int> 作为比较器，这样队列中的最小元素将位于队首。<br>同样的，我们可以使用如下语句创建一个大根堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法 1：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 写法 2：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code> 创建一个小根堆后，可以按以下方式操作这个小根堆：</p>
<ul>
<li>插入元素：使用 push() 方法将元素插入小根堆。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(<span class="number">5</span>); <span class="comment">// 插入元素5</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 插入元素3</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">7</span>); <span class="comment">// 插入元素7</span></span><br></pre></td></tr></table></figure></li>
<li>获取堆顶元素：使用 top() 方法获取小根堆的头部元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> topElement = q.<span class="built_in">top</span>(); <span class="comment">// 获取小根堆的头部元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Top element of the min heap: &quot;</span> &lt;&lt; topElement &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li>删除堆顶元素：使用 pop() 方法删除小根堆顶部的元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 删除小根堆的头部元素</span></span><br></pre></td></tr></table></figure></li>
<li>查看堆是否为空：使用 empty() 方法检查小根堆是否为空。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min heap is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min heap is not empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-05T01:08:40.000Z" title="2024/5/5 09:08:40">2024-05-05</time>发表</span><span class="level-item"><time dateTime="2024-05-07T12:30:33.967Z" title="2024/5/7 20:30:33">2024-05-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/">哈希(Hash)</a></span><span class="level-item">20 分钟读完 (大约3030个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/05/Hash/">Hash</a></p><div class="content"><h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h2><p>[TOC]</p>
<h3 id="哈希的基本概念"><a href="#哈希的基本概念" class="headerlink" title="哈希的基本概念"></a>哈希的基本概念</h3><ul>
<li>哈希（Hash）在我的理解中是一种映射关系，例如，将学生映射到学号上、将口红的颜色映射到一个色号上。</li>
<li>哈希函数（Hash Function）就是将一种你想要查询的关键字，比如说姓名、手机号码、数字或者字符串等，映射成便于查找的东西(一般来说是一个数字)的函数。</li>
<li>一般而言，一个好的哈希函数可以帮我们将我们想要查找的东西，从一个<strong>较大集合</strong>映射到一个<strong>较小集合</strong>，然后我们可以将这个<strong>较小集合</strong>中的信息<strong>存储</strong>下来，例如存入一个数组，这个用于存储较小集合的数组就称之为<strong>哈希表</strong>。<ul>
<li>一张格式如下的表：<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0001</td>
<td align="center">张三</td>
</tr>
<tr>
<td align="center">0002</td>
<td align="center">李四</td>
</tr>
<tr>
<td align="center">0003</td>
<td align="center">王五</td>
</tr>
<tr>
<td align="center">0004</td>
<td align="center">赵六</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
</li>
<li>这张表就可以理解为一个姓名和学号的哈希表，我们通过学号就可以获得学号对应的人的姓名，即：<code>学号[0001] -&gt; &quot;张三&quot;</code>，反映到代码中，可以理解为一个一维数组通过下标直接访问。</li>
</ul>
</li>
<li>而在一些加密工作中，可能需要将要简单的组合复杂化，比如密码组合，这时会有一种类似反向哈希（加密）的过程。</li>
<li>比较常见的哈希函数的例子：<br>$$H(x) &#x3D; x ; mod ; 11$$</li>
<li>这个函数可以让我们将任意的整数映射到 <code>0 ~ 10</code> 的范围中</li>
</ul>
<h3 id="哈希的基本操作"><a href="#哈希的基本操作" class="headerlink" title="哈希的基本操作"></a>哈希的基本操作</h3><ul>
<li>定义哈希函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> modnum = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> hashTable[modnum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈希函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % modnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在哈希表中插入元素  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在哈希表中插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">hash</span>(x);</span><br><span class="line">    hashTable[addr] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在哈希表中查找元素  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在哈希表中查找元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isExist</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">hash</span>(x);</span><br><span class="line">    <span class="keyword">return</span> hashTable[addr] == x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="哈希表中解决冲突的方式"><a href="#哈希表中解决冲突的方式" class="headerlink" title="哈希表中解决冲突的方式"></a>哈希表中解决冲突的方式</h3><p><strong>不同关键字</strong>通过<strong>相同哈希函数</strong>计算出<strong>相同的哈希地址</strong>，该种现象称为哈希冲突或哈希碰撞，或者称为哈希冲突。<br>哈希表在存放数据时有可能出现冲突的情况，以上文中的哈希函数为例我们分别向其中插入元素，如下：<br><img src="/./Hash/Hash.png"><br>因为希望哈希表底层数组的容量小于实际要存储的关键字的数量，这就会导致一个问题：<strong>冲突的发生是必然的，我们能做的是尽量的降低冲突率</strong>。</p>
<p>冲突的解决方式一般有以下两种：</p>
<h4 id="方式-1：顺延"><a href="#方式-1：顺延" class="headerlink" title="方式 1：顺延"></a>方式 1：顺延</h4><p>一种很好想到的解决方式是将哈希表中插入时产生冲突的元素向后顺延，直到找到一个空位置再进行插入。这种方式称为<strong>顺延</strong>，也有说法称之为<strong>线性探测</strong>。<br><img src="/./Hash/HashCrash1.png"><br>此时插入和查找的代码也要发生相应的改变，插入时需要我们需要找到一个空位置来执行插入操作；相对应的查找方式也要做出改变，当我们查询一个数时，也要查询哈希函数对应的位置，并依次比较连续的非空的哈希表中的值：</p>
<ul>
<li>插入操作  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">hash</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(hashTable[addr] NOT <span class="literal">NULL</span>) &#123; <span class="comment">// 当哈希表的插入位置不为空</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % modnum;</span><br><span class="line">    &#125;</span><br><span class="line">    hashTable[addr] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查找操作  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">isExist</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">hash</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(hashTable[addr] NOT <span class="literal">NULL</span>) &#123; <span class="comment">// 当哈希表的查询位置不为空(查询一段连续的哈希表)</span></span><br><span class="line">        <span class="keyword">if</span>(hashTable[addr] == x) &#123;    <span class="comment">// 如果查询到指定元素, 返回 true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addr = (addr + <span class="number">1</span>) % modnum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以定义多种解决冲突的顺延函数，即<code>addr = (addr + 1) % modnum</code>，实际使用中可以是每次$+k$，或者$+1^2$，$+2^2$，$+3^2$，…等。</li>
</ul>
<p>但是这种顺延方式会存在<strong>一定的问题</strong>：插入时可能会出现多次冲突，当哈希表即将满的时候，插入操作的冲突可能会出现的更多，此时插入和查询操作都会变成一个非常耗时的操作。</p>
<h4 id="方式-2：哈希链表"><a href="#方式-2：哈希链表" class="headerlink" title="方式 2：哈希链表"></a>方式 2：哈希链表</h4><p>我们可以通过链表的方式，来实现在一个位置放置多个元素的操作。在 C++ 的 STL 库中，我们可以使用 STL 库中提供的 <code>vector</code> 来简单的替代链表。<br>通过这种方式，每次查找元素时，先找到对应的链表头，然后遍历这个位置的整张链表即可。<br><img src="/./Hash/HashCrash2.png"></p>
<p>此时的哈希表的定义、插入操作和查询操作要发生相应的变化：</p>
<ul>
<li><p>定义哈希函数</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> modnum = <span class="number">11</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; hashTable[modnum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈希函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % modnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入操作</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">hash</span>(x);</span><br><span class="line">    hashTable[addr].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询操作</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">isExist</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">hash</span>(x);</span><br><span class="line">    <span class="type">int</span> tableSize = hashTable[addr].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 这里不使用 for(int i = 0; i &lt; hashTable[addr].size(); i++) 的写法, 而是首先计算出 hashTable[addr].size()</span></span><br><span class="line">    <span class="comment">// 因为 vector 的 size() 是一个比较耗时的操作, 他是通过将 vector 按照一个一个数出来的方式来进行计数的</span></span><br><span class="line">    <span class="comment">// 在数据量小的时候可能并不明显, 当数据量大的时候可能就会出现较为严重的耗时问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[addr][i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方式还是不能彻底解决我们的问题。对于插入操作来说，时间复杂度可以看作是$O(1)$，对于查询操作来说，时间复杂度和其冲突次数相关联。</p>
</li>
</ul>
<h3 id="哈希函数的设计"><a href="#哈希函数的设计" class="headerlink" title="哈希函数的设计"></a>哈希函数的设计</h3><p>面对上面的问题，设计好哈希函数才是解决问题的关键。哈希函数在设计的时候，一般要注意几个原则：</p>
<ul>
<li>设计哈希函数时，我们需要尽可能让查询的值均匀地存储在哈希表中，或者说尽量分散再哈希表中。</li>
<li>在手搓哈希函数时，我们会要求 $H(x) &#x3D; x ; mod; p$，其中的 $p$ 为素数</li>
<li>哈希函数中的对 $p$ 取摸的操作，会使得哈希值落在 $0 &lt;&#x3D; value &lt;&#x3D; p-1$ 的范围内，这个哈希表的长度 $p$，一般被称为<strong>哈希表的容量（Capacity）</strong>。</li>
<li>插入哈希表的元素总数除以哈希表的容量得到的数，称为<strong>负载因子</strong>，这里可以用 $\alpha$ 表示，即：<br>$$\alpha &#x3D; ElumNum \div p$$</li>
<li>当负载因子$\alpha$达到一定程度时（一般认为是$0.7\sim0.8$），则说明再对哈希表继续进行操作，就会面临大量冲突的情况，这时就要考虑<strong>增大哈希表的容量</strong>以避免出现更多的冲突。</li>
<li>哈希函数的冲突率和负载因子的关系一般如下：<br><img src="/./Hash/HashCrash3.png"></li>
</ul>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p><strong>字符串哈希</strong>是学习或者工作中经常遇到的一种操作，常用于比较两组字符串的内容等操作。通过比较两个字符串的哈希值就可以完成字符串的比较。当然这个操作也可以用于<strong>数组的哈希</strong>，因为字符串本质就是一个字符数组。<br>$$s &#x3D; s_1s_2s_3 \dots s_n\qquad s_i \in a, b \dots z$$</p>
<p>一个字符串 $s$ 由 $n$ 个字符组成，每个字符 $s_i$ 属于 $a \sim z$。<br>其哈希函数为：<br>$$\begin{aligned}H(S)<br>&amp;&#x3D;(\sum_{i&#x3D;1}^{n} c_i × base^{n-i});mod ;p\<br>&amp;&#x3D;(c_1 × base ^ {n-1} + c_2 × base ^ {n-2} + \dots + c_{n-1} × base ^ {1}) ; mod ; p\<br>&amp;&#x3D;base^{n-(n-1)}(base\dots(base(base × c_1 + c_2)));mod ;p\<br>&amp;&#x3D;base^{1}(base\dots(base(base × c_1 + c_2)+c_3)+\dots + c_n)\end{aligned};mod ;p$$</p>
<p>其中 $c_i$ 是一个和 $s_i$ 有关的数字，我们可以将字符映射到数字，例如：$a → 1$、$b → 2$ 等。这里不将 <code>a</code> 映射为 <code>0</code>，因为如果将 <code>a</code> 映射为 <code>0</code>，字符串 <code>a</code> 和 <code>ab</code> 的哈希值是相等的。<br>$base$ 是一个可以自己指定的数字，其值<strong>一般是大于字符集中的字符数量（$c_i$的最大值）的素数</strong>，这里可以取 <code>31</code>，常见的选择是 <code>9999971</code>。<br>$p$ 是一个素数，常见的选择是 <code>101</code> 或 <code>137</code>。</p>
<p>用代码实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 为什么是 res * base, 见上文的描述的公式推导</span></span><br><span class="line">        res = (res * base + (s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>)) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 $base$ 为 <code>31</code>，$p$ 为 <code>101</code> 时。<br>当 $s$ 为 $a$ 时，<code>hash(char s[], int n)</code> 的值为 1。<br>过程可以描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] res = (0 * base + (&#x27;a&#x27; - &#x27;a&#x27; + 1)) % p</span><br><span class="line">&gt;&gt;&gt; res = 1</span><br></pre></td></tr></table></figure>
<p>当 $s$ 为 $ab$ 时，<code>hash(char s[], int n)</code> 的值为 1。<br>过程可以描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] res = (0 * base + (&#x27;a&#x27; - &#x27;a&#x27; + 1)) % p</span><br><span class="line">&gt;&gt;&gt; res = 1</span><br><span class="line">[2] res = (1 * base + (&#x27;b&#x27; - &#x27;a&#x27; + 1)) % p</span><br><span class="line">&gt;&gt;&gt; res = 33</span><br></pre></td></tr></table></figure>

<p>当我们定义好一个良好的哈希函数之后，因为哈希函数的值相等的概率比较小，当两个字符串的哈希值相同的时候，我们可以认为两个字符串也相同，从而避免使用按位比较，节约时间。</p>
<p>$base$ 为什么<strong>一般是一个大于字符集中的字符数量（$c_i$的最大值）的素数</strong>呢？<br>当 $base$ 值过小时，此处假定为 $11$，会出现有可能两个字符运算完后还没有超过字母表的范围。如：字母表的范围为 $1 \sim 26$，字符串 <code>ba</code> 运算完成后的结果为 $23$，两个字符串的运算结果<strong>小于</strong> $26$，字符串<code>w</code>运算完成后的结果为 $23$，可以发现 <code>ba</code> 和 <code>w</code> 出现了冲突。</p>
<p>我们字符串的定义方式有一种好处，可以使得我们借助类似前缀和的思想，快速得到任意一段字符串 $s$ 的<strong>字串</strong>的哈希值。</p>
<ul>
<li>我们可以使用一个数组 $a$ 来记录我们计算 hash(s) 的中间过程，即：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[1] = hash(c1)</span><br><span class="line">a[2] = hash(c1c2)</span><br><span class="line">...</span><br><span class="line">a[i] = hash(c1c2...ci)</span><br></pre></td></tr></table></figure>
那么字符串 $s$ 的任意子串 $s_{l, r} &#x3D; s_ls_{l+1}\dots s_r$ 的哈希值为：<br>$$hash(s_{l, r}) &#x3D; (a[r] - a[l-1] × base^{r - l + 1});mod;p$$</li>
</ul>
<h3 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h3><p>冲突往往是不可避免的，纵使我们的哈希函数再好，也有可能会出现冲突的情况，那么我们如何尽可能避免这个问题呢？这时候，我们可以使用<strong>双哈希</strong>的方法来避免冲突。<br>在上文字符串哈希中，我们的字符串哈希函数为：</p>
<p>$$H(S) &#x3D; (\sum_{i&#x3D;1}^{n} c_i × base^{n-i});mod ;p$$</p>
<p>那么如何实现双哈希呢？我们可以选取两组 $base$ 和 $p$，然后使用这分别使用这两组 $base$ 和 $p$，分别来求取哈希值。如果这两组参数得到的哈希值都相同，我们则认为两个字符串相等。在竞赛中，最好书写双哈希，甚至三哈希，因为这样出错误的概率会呈指数级的降低。</p>
<h3 id="STL中的哈希-unordered-map"><a href="#STL中的哈希-unordered-map" class="headerlink" title="STL中的哈希 unordered_map"></a>STL中的哈希 <code>unordered_map</code></h3><p>在 C++ 的STL库中，有一个非常好用的数据结构 <code>unordered_map</code>，可以帮助我们实现大多数哈希表的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;K, V&gt; hash_table;</span><br></pre></td></tr></table></figure>
<p>其中 <code>K</code> 为我们想要存储的关键字信息，<code>V</code> 表示与他关联的一些信息。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; hash_table;</span><br></pre></td></tr></table></figure>
<p>这个表会以<code>string</code>作为<code>K</code>，<code>int</code>作为<code>V</code>进行存储，基于此我们可以很方便的实现一些功能。例如我们现在要保存一个班级上学生的年龄信息:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hash_table.<span class="built_in">find</span>(name) == hash_table.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cannot Find...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_table[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; hash_table;</span><br><span class="line">    hash_table[<span class="string">&quot;zhangsan&quot;</span>] = <span class="number">2000</span>;</span><br><span class="line">    hash_table[<span class="string">&quot;lisi&quot;</span>] = <span class="number">2001</span>;</span><br><span class="line">    <span class="built_in">query</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-04T03:41:03.000Z" title="2024/5/4 11:41:03">2024-05-04</time>发表</span><span class="level-item"><time dateTime="2024-05-08T04:13:26.627Z" title="2024/5/8 12:13:26">2024-05-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/">栈(Stack)</a></span><span class="level-item">2 分钟读完 (大约283个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/04/Stack/">栈(Stack)</a></p><div class="content"><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><ul>
<li><p>栈是一种 <strong>先进后出(First in Last Out, FILO)</strong> 的数据结构，其类似于我们生活中的衣娄，衣服只能从最顶部放入，也只能从最顶部拿出，要想拿出中间的某件衣服，就需要将顶部的衣服全部拿出，再进行后续的操作。</p>
</li>
<li><p>衣娄对应到栈上，就是以下的概念：</p>
<ul>
<li><strong>栈(Stack)</strong> 是一种类似于衣娄的数据结构，我们可以向其内部存入或者取出数据</li>
<li>栈按照 <strong>先进后出</strong> 的原则存储数据，每次新进入的数据都会被放在最上面，越先进入的越靠下，越后进入的数据越靠上。</li>
<li>我们只能对最上面的数据进行操作</li>
<li>栈的两大元素：栈的大小和栈顶指针Top（该指针指向栈最顶部的位置）</li>
</ul>
</li>
</ul>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><ul>
<li>新建栈(题目简单时可以用数组模拟栈)</li>
<li>插入数据</li>
<li>删除栈顶数据</li>
<li>查询栈顶数据</li>
<li>清空栈</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-04T03:25:27.000Z" title="2024/5/4 11:25:27">2024-05-04</time>发表</span><span class="level-item"><time dateTime="2024-05-09T10:23:05.656Z" title="2024/5/9 18:23:05">2024-05-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a></span><span class="level-item">几秒读完 (大约101个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/04/ReviewAlgorithm/">复习数据结构/算法清单</a></p><div class="content"><h2 id="复习数据结构清单"><a href="#复习数据结构清单" class="headerlink" title="复习数据结构清单"></a>复习数据结构清单</h2><p>有日期则表示在该日期已经复习完毕，或者表示复习后的最新一次更新</p>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">链接</th>
<th align="center">备用链接(Backup Link)</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>栈(Stack)</strong></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>队列(Queue)</strong></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>链表(Link List)</strong></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><strong>二叉树(Binary Tree)</strong></td>
<td align="center"><a href="https://hello-nilera.com/2024/05/07/Tree/">https://hello-nilera.com/2024/05/07/Tree/</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://blog.csdn.net/NilEra/article/details/138624929?spm=1001.2014.3001.5501">https://blog.csdn.net/NilEra/article/details/138624929?spm=1001.2014.3001.5501</a></td>
<td align="center">2024.05.09</td>
</tr>
<tr>
<td align="center"><strong>哈希(Hash)</strong></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h2 id="算法复习清单"><a href="#算法复习清单" class="headerlink" title="算法复习清单"></a>算法复习清单</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">链接</th>
<th align="center">备用链接(Backup Link)</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarMyself.jpg" alt="NilEra"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">NilEra</p><p class="is-size-6 is-block">C/C++ Developer!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jinan Shandong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/NilEra-K" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/NilEra-K" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://nano.chemtian.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Thymol Blue</span></span><span class="level-right"><span class="level-item tag">nano.chemtian.top</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CppDev/"><span class="level-start"><span class="level-item">CppDev</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/Gaming/"><span class="level-start"><span class="level-item">Gaming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/QT6/"><span class="level-start"><span class="level-item">QT6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">多线程编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">网络编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E8%AF%AD%E6%B3%95%E7%82%B9/"><span class="level-start"><span class="level-item">语法点</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/%E8%AF%AD%E6%B3%95%E7%82%B9/bind/"><span class="level-start"><span class="level-item">bind</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E8%AF%AD%E6%B3%95%E7%82%B9/enum-class/"><span class="level-start"><span class="level-item">enum class</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E8%AF%AD%E6%B3%95%E7%82%B9/%E8%99%9A%E5%87%BD%E6%95%B0/"><span class="level-start"><span class="level-item">虚函数</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/JavaDev/"><span class="level-start"><span class="level-item">JavaDev</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/JavaDev/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JavaDev/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="level-start"><span class="level-item">软件源</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">大数据技术</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/"><span class="level-start"><span class="level-item">ECharts</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/"><span class="level-start"><span class="level-item">HBase</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"><span class="level-start"><span class="level-item">数据可视化</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Axure-RP-9/"><span class="level-start"><span class="level-item">Axure RP 9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/SVN/"><span class="level-start"><span class="level-item">SVN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构/算法</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/"><span class="level-start"><span class="level-item">哈希(Hash)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/"><span class="level-start"><span class="level-item">栈(Stack)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/"><span class="level-start"><span class="level-item">树(Tree)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8-List/"><span class="level-start"><span class="level-item">线性表(List)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLMs/"><span class="level-start"><span class="level-item">LLMs</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"><span class="level-start"><span class="level-item">PyTorch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Stable-Diffusion/"><span class="level-start"><span class="level-item">Stable_Diffusion</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">网络架构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/Kolmogorov-Arnold-Networks/"><span class="level-start"><span class="level-item">Kolmogorov-Arnold Networks</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/"><span class="level-start"><span class="level-item">闲聊</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/%E8%AE%A1%E5%88%92/"><span class="level-start"><span class="level-item">计划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-24T02:01:05.000Z">2024-10-24</time></p><p class="title"><a href="/2024/10/24/LLM-FINETUNE/">LLM-FINETUNE</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLMs/">LLMs</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-17T00:46:50.000Z">2024-10-17</time></p><p class="title"><a href="/2024/10/17/Run-Others-Java-Projects/">Run-Others-Java-Projects</a></p><p class="categories"><a href="/categories/JavaDev/">JavaDev</a> / <a href="/categories/JavaDev/Project/">Project</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-20T02:07:10.000Z">2024-09-20</time></p><p class="title"><a href="/2024/09/20/List/">List</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">数据结构/算法</a> / <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8-List/">线性表(List)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-12T02:03:09.000Z">2024-09-12</time></p><p class="title"><a href="/2024/09/12/RedHat-Build-LLM/">RedHat-Build-LLM</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLMs/">LLMs</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-11T01:06:12.000Z">2024-09-11</time></p><p class="title"><a href="/2024/09/11/SVN-Quick-IN/">SVN-Quick-IN</a></p><p class="categories"><a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a> / <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/SVN/">SVN</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">八月 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Annotation/"><span class="tag">Annotation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Axure-RP-9/"><span class="tag">Axure RP 9</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-11-%E6%96%B0%E6%A0%87%E5%87%86/"><span class="tag">C++ 11 新标准</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CppDev/"><span class="tag">CppDev</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECharts/"><span class="tag">ECharts</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EasyX/"><span class="tag">EasyX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fine-Tune-%E5%BE%AE%E8%B0%83/"><span class="tag">Fine-Tune(微调)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GameDev/"><span class="tag">GameDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaDev/"><span class="tag">JavaDev</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KAN/"><span class="tag">KAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kaggle/"><span class="tag">Kaggle</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLMs/"><span class="tag">LLMs</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LM-Studio/"><span class="tag">LM-Studio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Maven/"><span class="tag">Maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis-Plus/"><span class="tag">MyBatis-Plus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PowerInfer/"><span class="tag">PowerInfer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QT6/"><span class="tag">QT6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/R/"><span class="tag">R</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RedHat/"><span class="tag">RedHat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SVN/"><span class="tag">SVN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stable-Diffusion/"><span class="tag">Stable Diffusion</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tomcat/"><span class="tag">Tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span class="tag">多线程编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="tag">大数据技术</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="tag">大模型</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E5%88%92/"><span class="tag">计划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95%E7%82%B9/"><span class="tag">语法点</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="tag">软件源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%B2%E8%81%8A/"><span class="tag">闲聊</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE/"><span class="tag">项目</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a><p class="is-size-7"><span>&copy; 2024 NilEra</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024 前方⚡高能</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdnjs.loli.net/ajax/libs/algoliasearch/4.0.3/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdnjs.loli.net/ajax/libs/instantsearch.js/4.3.1/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"2TB5ZZYPCO","apiKey":"00a43f1d62ca7b24c8b78d5f0223c065","indexName":"dev_nilera_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>