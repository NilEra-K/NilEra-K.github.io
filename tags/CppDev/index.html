<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>标签: CppDev - Hello, NilEra :-)</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hello, NilEra :-)"><meta name="msapplication-TileImage" content="/img/StarLogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hello, NilEra :-)"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="努力做自己喜欢的事"><meta property="og:type" content="blog"><meta property="og:title" content="Hello, NilEra :-)"><meta property="og:url" content="https://hello-nilera.com/"><meta property="og:site_name" content="Hello, NilEra :-)"><meta property="og:description" content="努力做自己喜欢的事"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hello-nilera.com/img/og_image.png"><meta property="article:author" content="NilEra"><meta property="article:tag" content="Hello NilEra"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hello-nilera.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hello-nilera.com"},"headline":"Hello, NilEra :-)","image":["https://hello-nilera.com/img/og_image.png"],"author":{"@type":"Person","name":"NilEra"},"publisher":{"@type":"Organization","name":"Hello, NilEra :-)","logo":{"@type":"ImageObject","url":"https://hello-nilera.com/img/StarLogo.svg"}},"description":"努力做自己喜欢的事"}</script><link rel="icon" href="/img/StarLogo.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?249654dcf9a3bf70708fdfc6e2b1ec2b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="F6BD78C6BD0096D2218CF88334111125"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/me">我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">CppDev</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-07-29T07:32:17.000Z" title="2024/7/29 15:32:17">2024-07-29</time>发表</span><span class="level-item"><time dateTime="2024-08-04T14:17:33.494Z" title="2024/8/4 22:17:33">2024-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></span><span class="level-item">2 小时读完 (大约14428个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/29/Cpp-Muti-Threaded/">Cpp_Muti_Threaded</a></p><div class="content"><h2 id="🔱-C-多线程编程"><a href="#🔱-C-多线程编程" class="headerlink" title="🔱 C++ 多线程编程"></a>🔱 C++ 多线程编程</h2><p>[TOC]</p>
<h3 id="🧶-1-进程和线程的基本概念"><a href="#🧶-1-进程和线程的基本概念" class="headerlink" title="🧶 1. 进程和线程的基本概念"></a>🧶 1. 进程和线程的基本概念</h3><h5 id="1-1-1-进程和线程的概念"><a href="#1-1-1-进程和线程的概念" class="headerlink" title="1.1.1 进程和线程的概念"></a>1.1.1 进程和线程的概念</h5><p><strong>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</strong>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道、文件、套接字等。</p>
<p><strong><u>线程</u>是进程的进程。</strong>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程的最大数量取决于CPU的核心数。</p>
<p>线程与进程的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写这些栈内存。</p>
<p>线程是进程的一个实体，是进程的一条执行路径。</p>
<p>线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。</p>
<h5 id="1-1-2-并发和并行的概念"><a href="#1-1-2-并发和并行的概念" class="headerlink" title="1.1.2 并发和并行的概念"></a>1.1.2 并发和并行的概念</h5><p><strong>并发（Concurrent）：</strong>并发指在<strong>同一时间段内</strong>，多个任务都在进行中，但并不一定同时执行。在单核 <code>CPU</code> 上，多个任务占用不同的 <code>CPU</code> 时间片，<strong>物理上还是串行执行的</strong>。但是由于每个任务所占用的 <code>CPU</code> 时间片非常短（如：<code>10ms</code>），看起来就像是多个任务在共同执行一样，这样的场景就叫做<strong>并发</strong>。</p>
<img src="./Cpp_Muti_Threaded/Concurrent.png" alt="并发" style="zoom: 50%;" >

<center>并发概念图</center>

<p><strong>并行（Parallel）：</strong>并行是指在<strong>同一时刻</strong>，多个任务同时执行。并行需要多核 <code>CPU</code> 或者多处理器系统，让不同的任务在不同的核心上同时运行。但是这并不意味着每个核心上只运行一个任务，每个核心上的运行策略其实和单核 <code>CPU</code> 没有太大区别（即也是并发的）。</p>
<img src="./Cpp_Muti_Threaded/Parallel.png" alt="并行概念图" style="zoom:50%;" >

<center>并行概念图</center>

<h3 id="🧶-2-多线程的设计"><a href="#🧶-2-多线程的设计" class="headerlink" title="🧶 2. 多线程的设计"></a>🧶 2. 多线程的设计</h3><p>开发一个任务时，要不要实现成并发程序呢？多线程一定更好吗？</p>
<p>在某些情况下多线程具有一定的优势，但是在某些情况下多线程并不具有优势，这需要根据当前程序的类型进行分析和判断。</p>
<p>程序的类型有以下两种：一种是 I&#x2F;O密集型；一种是 CPU 密集型。</p>
<h4 id="2-1-I-O-密集型程序"><a href="#2-1-I-O-密集型程序" class="headerlink" title="2.1 I&#x2F;O 密集型程序"></a>2.1 I&#x2F;O 密集型程序</h4><p>I&#x2F;O密集型，即程序里面指令的执行，涉及一些 I&#x2F;O 操作，比如设备、文件、网络操作（如等待客户端的连接）等，I&#x2F;O操作是可以将进程阻塞住的，如果我们再给这样的程序分配时间片，其实就相当于 <code>CPU</code> 空闲下来了。</p>
<p>在 I&#x2F;O 密集型的程序在执行的时候，在 I&#x2F;O 操作没有准备好时，程序是会被放在阻塞队列中的，在阻塞队列中是不受操作系统调度的。</p>
<p>正因如此，I&#x2F;O 密集型程序更适合设计成多线程程序。</p>
<p>I&#x2F;O 密集型程序不论是在单核还是多核的情况下，都是适合设计成多线程程序的，因为他不会造成 <code>CPU</code> 资源的浪费。</p>
<h4 id="2-2-CPU-密集型程序"><a href="#2-2-CPU-密集型程序" class="headerlink" title="2.2 CPU 密集型程序"></a>2.2 CPU 密集型程序</h4><p>CPU 密集型程序，即程序里面的指令都是用来做计算用的，例如大量的加减乘除、深度学习都是在进行大量的计算。</p>
<p>CPU密集型程序，在<strong>单核情况下是不适合设计成多线程程序的</strong>，因为线程的调度有额外的花费：线程的上下文切换（当前线程调度完了，该调度下一个线程）。在这种情况下，相当于只有一个计算器，单线程是一个人一直计算，而多线程是多个人一人算一段。但是传递计算器的过程会产生一定的花销。而单线程进行上下文切换时，要获取之前计算到的信息，这也是一笔开销。</p>
<p>但是其在多核情况下是比较适合设计成多线程程序的。</p>
<h3 id="🧶-3-线程同步"><a href="#🧶-3-线程同步" class="headerlink" title="🧶 3. 线程同步"></a>🧶 3. 线程同步</h3><p>线程同步有两种场景：① 线程互斥；② 线程通信</p>
<p><strong>线程互斥：</strong></p>
<ul>
<li>互斥锁 <code>mutex</code></li>
<li>原子类型 <code>atomic</code></li>
</ul>
<p><strong>线程通信：</strong></p>
<ul>
<li>条件变量 <code>condition_variable</code></li>
<li>信号量 <code>semaphore</code></li>
</ul>
<h4 id="3-1-数据竞态（竞态条件）"><a href="#3-1-数据竞态（竞态条件）" class="headerlink" title="3.1 数据竞态（竞态条件）"></a>3.1 数据竞态（竞态条件）</h4><p>一个进程中的所有线程共享整个进程的堆内存，每个线程私有自己的栈内存。</p>
<p>如下图所示，当我们有多个线程想要执行 <code>Code</code> 时，那我们就要考虑这段代码能否在多线程环境下执行。是否能在多线程环境下执行主要要看这段代码是否存在数据竞态（或称竞态条件）。</p>
<p><strong>竞态条件：</strong>代码片段 <code>Code</code> 在多线程环境下执行，随着线程的调度顺序不同，而得到不同的运行结果，这就说明这段代码存在竞态条件。简单来说就是，$Thread1→Thread2→Thread3$ 会得到一个结果，而 $Thread2→Thread1→Thread3$ 可能是另一个结果。这是我们不期待的。</p>
<p>存在竞态条件的代码片段称为<strong>临界区代码段</strong>。</p>
<img src="./Cpp_Muti_Threaded/DataCompetitionStatus.png" style="zoom:50%;" >

<p>为了保证不出现临界区代码段，我们应该要保证代码的<strong>原子操作</strong>。</p>
<p>如果在多线程环境下不存在竞态条件，那么我们称这段代码片段是<em><strong>可重入的（就是一段代码在没执行完的情况下又被运行了）</strong></em>，否则是<em><strong>不可重入</strong></em>的。</p>
<h4 id="3-2-线程互斥"><a href="#3-2-线程互斥" class="headerlink" title="3.2 线程互斥"></a>3.2 线程互斥</h4><p>线程互斥包括：① 互斥锁 <code>mutex</code>；② 原子操作<code>atomic</code>。</p>
<p><code>mutex</code> 如 <code>lock</code> 操作（悲观锁）、<code>unlock</code> 操作或者 <code>try_lock</code> 操作（活锁、乐观锁）。<code>mutex</code> 是重量级的锁。</p>
<p>但是我们有时候不需要很重量级的锁，比如我们有时候可能只是执行一个自增操作 <code>x++</code>，或者是较为简单的一些操作，这时候我们就不太需要一个重量级的锁，<code>C++ 11</code>  已经提供了 $CAS$ （无锁机制）操作，即 <code>Compare &amp; Set/Compare &amp; Swap</code>。无锁机制并不是说没有锁，而是说这个锁是轻量级的，我们可以用 $CAS$ 实现无锁队列、无锁链表、无锁数组等。</p>
<p>以 <code>C++ 11</code> 的 <code>count++</code> 为例，<code>count++</code> 在操作系统中其实进行了三步指令操作，如下图所示：</p>
<img src="./Cpp_Muti_Threaded/NotAtomic.png" style="zoom: 67%;" />

<ul>
<li>假设首先执行 $Thread \ 1$，此时执行 <code>mov eax, count</code> 指令，将 <code>count</code> 的值写到 <code>eax</code> 此时 <code>eax</code> 的值由未知数 <code>x</code> 变为 <code>0</code>；</li>
<li>然后 $Thread \ 1$ 执行 <code>add eax, 1</code> 指令，将 <code>eax</code> 寄存器中的值加 <code>1</code>；</li>
<li>此时时间片完，进行线程切换操作，切换到 $Thread \ 2$；</li>
<li>此时执行 $Thread \ 2$，执行 <code>mov eax, count</code> 指令，将 <code>count</code> 的值写到 <code>eax</code>，此时 <code>count</code> 为从全局获取到的 <code>0</code>，<code>eax</code> 为 未知数<code>x</code>，此时 <code>eax</code> 寄存器由 <code>x</code> 被写为 <code>0</code>；</li>
<li>然后 $Thread \ 2$​ 执行 <code>add eax, 1</code> 指令，将 <code>eax</code> 寄存器中的值加 <code>1</code>；</li>
<li>此时时间片完，进行线程切换操作，切换到 $Thread 1$；</li>
<li>此时执行 $Thread \ 1$，执行 <code>mov count, eax</code> 指令，将 $Thread \ 1$ 上次切换之前的 <code>eax</code> 的值（为 $1$）写到 <code>count</code> 中，<code>count</code> 由 <code>0</code> 变成 <code>1</code>；</li>
<li>此时 $Thread \ 1$ 执行完毕，切换到 $Thread \ 2$；</li>
<li>此时执行 $Thread \ 2$，执行 <code>mov count, eax</code> 指令，将 $Thread \ 2$ 上次切换之前的 <code>eax</code> 的值（为 $1$）写到 <code>count</code> 中，<code>count</code> 由 <code>1</code> 变成 <code>1</code>。</li>
</ul>
<p>我们可以发现，即使是简单的 <code>count++</code> 也不是一个原子操作。</p>
<p>对于这种操作，我们当然可以用重量级的锁（<code>lock</code>）来进行锁定，但是我们更倾向于使用 $CAS$ 来实现这个问题。</p>
<h4 id="3-2-线程通信"><a href="#3-2-线程通信" class="headerlink" title="3.2 线程通信"></a>3.2 线程通信</h4><p>线程通信包括：① 条件变量 <code>condition_variable</code>；② 信号量 <code>semaphore</code>。</p>
<p>在线程中，并不往往都是几个线程互不相干，有时候会存在一定的依赖关系，如 $Thread \ 1$ 的某段代码需要依赖于 $Thread \ 2$ 的某段代码，因为我们并不能保证线程的调度顺序（即有可能被依赖代码可能需要好久才能执行完毕，而已经有线程需要这个代码的结果了），所以我们这个时候就需要进行线程间的通信。</p>
<img src="./Cpp_Muti_Threaded/condition_variable.png" style="zoom:50%;" >

<center>条件变量</center>

<p>条件变量需要配合互斥锁（互斥量）一起使用，其构造函数就需要传入一个互斥锁（互斥量），即 <code>mutex + condition_variable</code>。一个常见的用法就是<strong>生产者——消费者模型</strong>。*<u>线程池其实就是使用了生产者——消费者模型</u>*。</p>
<p><code>mutex</code> 互斥锁就是资源计数只能是 $0$ 或 $1$ 的互斥锁，即执行 <code>mutex.lock()</code> 后锁的<strong>资源计数</strong> $1→0$，执行 <code>mutex.unlock()</code> 后锁的<strong>资源计数</strong> $0→1$。而信号量可以看作 <em><strong>资源计数没有限制</strong></em> 的 <code>mutex</code> 互斥锁。</p>
<img src="./Cpp_Muti_Threaded/semaphore.png" style="zoom: 50%;" >

<center>信号量</center>

<p>信号量都是单独使用的，不需要配合其他条件一同使用。<code>C++ 11</code> 并没有提供信号量的操作，直到 <code>C++ 20</code> 才从语言层面支持了信号量，但是我们完全可以使用 <code>C++ 11</code> 来自己实现一个信号量。信号量也可以用于实现生产者消费者模型，但是无法做到精细的控制。初始信号量为$0$，生产者生产后信号量增加，消费者消费后信号量减少。通过判断信号量来进行简单的线程间通信。</p>
<p>此外还有二元信号量的概念，<code>semaphore sem(1)</code> 资源计数 $0 &#x2F; 1$，可以完成和 <code>mutex</code> 互斥锁同样的线程互斥操作，但是其和 <code>mutex</code> 是存在一定区别的。<code>mutex</code> 只能是哪个线程获取锁，哪个线程释放锁；<code>semaphore</code> 则不同，<code>sem.wait()</code> 和 <code>sem.post()</code> 可以处在不同的线程中调用。例如：有三个线程调用了 <code>sem.wait()</code> 等待执行一块代码 <code>Code</code>，其中一个线程 $Thread \ A$ 开始执行代码，其他两个线程 $Thread \ B$ 和 $Thread \ C$ 依旧在等待。如果此时有其他代码（存在误操作或者其他原因）调用了 <code>sem.post()</code>，此时会使信号量增加，$Thread \ B$ 或 $Thread \  C$ 其中一个会执行代码，若此时 $Thread \ A$ 还没有执行完代码，这就有可能导致数据竞态问题。</p>
<h3 id="🧶-4-C-11-Windows-线程库的基本使用"><a href="#🧶-4-C-11-Windows-线程库的基本使用" class="headerlink" title="🧶 4. C++ 11 Windows 线程库的基本使用"></a>🧶 4. C++ 11 Windows 线程库的基本使用</h3><p><strong>C++ 11 线程库头文件</strong> <code>#include &lt;thread&gt;</code></p>
<ul>
<li><p>创建线程</p>
<p>可以使用 <code>std::thread</code> 来创建线程，这其实是使用线程类 <code>std::thread</code> 声明一个线程实例 <code>printThread</code> 的过程。这里我们直接这样创建线程，生成应用程序之后运行输出结果：<code>Hello World - I&#39;m NilEra @-@</code>，但是运行之后会出现错误。</p>
<p>这里出现错误的原因是：当我们启动了 <code>thread_print</code> 线程，此时程序不会在这里等待线程执行完成，而是会继续向下执行，导致出现程序已经执行到 <code>return 0</code> 时，线程还没有执行完成，因此这里会产生报错。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printThread</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World - I&#x27;m NilEra @-@&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printThread)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主程序等待线程执行完毕</p>
<p>为了解决上述出现的问题，我们需要让主程序等待的线程执行完毕再进行退出，这时我们就需要用到 <code>join()</code> 函数。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    thread_print.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分离线程</p>
<p>上述的问题还可以使用 <code>detach()</code> 函数来进行解决。当执行下面的程序时，控制台不会又任何输出，直接退出程序。</p>
<p>这是因为线程执行完线程的创建之后，紧接着执行了 <code>detach()</code>，此时线程的具体操作还未来得及执行就进行了线程的分离。进程结束之后，<code>thread_print</code> 线程还在后台运行。但是因为此时进程已经结束，线程执行的过程中不会有输出。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程分离</span></span><br><span class="line">    thread_print.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用如下代码可以更清晰的看到执行 detach() 的效果, 以及 join() 和 detach() 的区别</span></span><br><span class="line"><span class="comment">// join() 是阻塞的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">    thread_print.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断线程是否可以合并</p>
<p>有时我们需要对线程判断其是否可以进行 <code>join()</code> 操作，此时我们可以调用 <code>joinable()</code> 函数，<code>joinable()</code> 会返回一个 <code>bool</code> 值，用于判断线程是否可以进行 <code>join()</code> 操作。</p>
<p>如果我们对一个不可使用 <code>join()</code> 或者 <code>detach()</code> 的线程进行了 <code>join()</code> 和 <code>detach()</code> 操作，会出现一个 <code>SystemError</code>，在一些比较严谨的项目中，会先使用 <code>joinable()</code> 进行判断。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程需要执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_print</span><span class="params">(printHelloWorld, <span class="string">&quot;Hello Thread @-@ I&#x27;m NilEra...&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> isJoin = thread_print.<span class="built_in">joinable</span>();</span><br><span class="line">    <span class="keyword">if</span> (isJoin) &#123;</span><br><span class="line">        thread_print.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧶-5-线程函数中的数据未定义错误"><a href="#🧶-5-线程函数中的数据未定义错误" class="headerlink" title="🧶 5. 线程函数中的数据未定义错误"></a>🧶 5. 线程函数中的数据未定义错误</h3><h4 id="5-1-传递临时变量问题"><a href="#5-1-传递临时变量问题" class="headerlink" title="5.1 传递临时变量问题"></a>5.1 传递临时变量问题</h4><ul>
<li><p>错误示例：如下使用 <code>std::thread</code> 类时，传入线程函数 <code>foo</code> 和 参数 <code>a</code>，这里的参数 <code>a</code> 会被作为值传递，即传递的不是 <code>a</code> 的引用，而是 <code>a</code> 所存储的值 <code>1</code>。但是如果是值传递的话，这里调用的实际上是 <code>foo((int&amp;) 1)</code> 会产生编译错误，因为 <code>1</code> 实际上是一个右值，而<strong>非常量引用的初始值必须为左值</strong>，所以这里会产生编译错误。</p>
<p>我们平时调用 <code>foo</code> 时，可以使用 <code>foo(a)</code>，实际上我们进行了隐式转换，执行的实际上是 <code>foo((int&amp;) a)</code>。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus</span><span class="params">(foo, a)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拓展 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">const_foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;const_foo param x is : &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_plus_const</span><span class="params">(const_foo, a)</span></span>;</span><br><span class="line">	thread_plus.<span class="built_in">join</span>();</span><br><span class="line">	thread_plus_const.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-传递指针或引用指向局部变量的问题"><a href="#5-2-传递指针或引用指向局部变量的问题" class="headerlink" title="5.2 传递指针或引用指向局部变量的问题"></a>5.2 传递指针或引用指向局部变量的问题</h4><ul>
<li><p>错误示例：在下面的程序中，我们定义了一个全局线程变量，并且在 <code>test</code> 函数被调用时开启了这个线程 <code>t</code>，在 <code>main</code> 函数中，执行了 <code>test</code> 函数，在执行到 <code>t = std::thread(foo, std::ref(a));</code> 时，线程启动。这时会出现两种情况：</p>
<p>① （大概率出现）在线程启动的时候，<code>test</code> 函数已经结束了运行，而局部变量 <code>a</code> 的内存被释放，此时出现空指针错误；</p>
<p>② （小概率出现）程序正常执行，这是因为线程执行的比 <code>test</code> 函数更快，当线程执行结束时，<code>a</code> 还没有被释放。我们可以在 <code>t = std::thread(foo, std::ref(a));</code> 下添加 <code>Sleep(10)</code>，使程序暂停 <code>10 ms</code>，保证线程结束的时候 <code>test</code> 还未执行完成来观察这一现象。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	t = std::<span class="built_in">thread</span>(foo, std::<span class="built_in">ref</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;		<span class="comment">// 延长 a 的声明周期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// int a = 1;</span></span><br><span class="line">	t = std::<span class="built_in">thread</span>(foo, std::<span class="built_in">ref</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拓展 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	t = std::<span class="built_in">thread</span>(foo, std::<span class="built_in">ref</span>(a));</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-传递指针或引用指向已经释放的内存问题"><a href="#5-3-传递指针或引用指向已经释放的内存问题" class="headerlink" title="5.3 传递指针或引用指向已经释放的内存问题"></a>5.3 传递指针或引用指向已经释放的内存问题</h4><ul>
<li><p>错误示例：这个问题和上面的问题是差不多的问题，这里有可能会① 直接报编译错误；② 通过编译，但是给出不期待的结果；③ 极小概率出现正常执行的情况。</p>
<p>当我们启动线程后，手动释放 <code>ptr_a</code>，此时若线程 <code>t</code> 的执行在释放内存之前（小概率），不会出现不期待的访问结果；但是如果线程 <code>t</code> 在释放内存之后执行（大概率），则会出现不期待的结果。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">	*x += <span class="number">1</span>;</span><br><span class="line">	std::cout &lt;&lt; *x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* ptr_a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);		<span class="comment">// 定义一个指针类型的变量 ptr_a</span></span><br><span class="line">									<span class="comment">// 初始化为其内存中存储的值为 1</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(foo, ptr_a)</span></span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr_a;					<span class="comment">// 这里手动释放 ptr_a</span></span><br><span class="line"></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* x)</span> </span>&#123;</span><br><span class="line">	*x += <span class="number">1</span>;</span><br><span class="line">	std::cout &lt;&lt; *x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* ptr_a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);		<span class="comment">// 定义一个指针类型的变量 ptr_a</span></span><br><span class="line">									<span class="comment">// 初始化为其内存中存储的值为 1</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(foo, ptr_a)</span></span>;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">10</span>);						<span class="comment">// 启动线程后等待 10 ms, 此时线程大概率已经执行完毕</span></span><br><span class="line">	<span class="keyword">delete</span> ptr_a;					<span class="comment">// 这里手动释放 ptr_a</span></span><br><span class="line"></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-类成员作为入口函数，类对象被提前释放"><a href="#5-4-类成员作为入口函数，类对象被提前释放" class="headerlink" title="5.4 类成员作为入口函数，类对象被提前释放"></a>5.4 类成员作为入口函数，类对象被提前释放</h4><ul>
<li><p>错误示例：这个错误和上面的错误基本上没有区别，只不过是将要 <code>int</code> 型换成了<em>类</em> 类型。</p>
<p>在 <code>main</code> 函数中，创建了一个 <code>MyClass</code> 类型的对象 <code>obj</code>。接着，启动了一个线程 <code>t</code>，这个线程执行 <code>MyClass::func</code>，并传递 <code>obj</code> 的地址 <code>&amp;obj</code> 给它，这里的 <code>&amp;obj</code> 为 <code>this</code> 指针。当 <code>t</code> 线程启动时，它会在后台执行 <code>MyClass::func</code>，但是，<code>main</code> 函数在启动线程后立即返回，而没有等待线程完成。此时，局部变量 <code>obj</code> 会被销毁。如果 <code>t</code> 线程还没有执行完 <code>MyClass::func</code>，则它将尝试访问一个已经销毁的对象，导致未定义行为和运行时错误。</p>
<p>我们可以使用智能指针的方式来防止出现指针提前释放的情况，使用 <code>std::shared_ptr&lt;MyClass&gt;</code> 创建并管理 <code>MyClass</code> 对象的生命周期。<code>std::make_shared&lt;MyClass&gt;()</code> 创建一个 <code>shared_ptr</code>，并返回一个指向堆上分配的 <code>MyClass</code> 对象的共享指针。传递 <code>obj</code>（<code>shared_ptr</code>）给 <code>std::thread</code> 的构造函数时，会增加引用计数，确保 <code>MyClass</code> 对象在 <code>obj</code> 和线程中都有效。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Started...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Finished...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	MyClass obj;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, &amp;obj)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 正确修改 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Started...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Finished...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针</span></span><br><span class="line">	std::shared_ptr&lt;MyClass&gt; obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证线程运行结束再退出主程序</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧶-6-互斥量解决多线程数据共享问题"><a href="#🧶-6-互斥量解决多线程数据共享问题" class="headerlink" title="🧶 6. 互斥量解决多线程数据共享问题"></a>🧶 6. 互斥量解决多线程数据共享问题</h3><p><strong>数据共享问题：</strong>在多个线程中共享数据时，需要注意 <em><strong>线程安全</strong></em> 问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现<strong>数据竞争</strong>问题。数据竞争可能导致程序崩溃、产生未定义错误或者得到错误的结果。</p>
<p>为了避免数据竞争问题，需要使用<strong>同步机制</strong>来确保多个线程之间对共享数据的访问量是安全的。常见的同步机制包括<strong>互斥量</strong>、<strong>条件操作</strong>、<strong>原子操作</strong>等。</p>
<p>可以看到下面这张图，来体会一下没有锁的情况下导致的多线程数据共享的问题。我们有两个线程 <code>Thread 1</code> 和 <code>Thread 2</code>，这两个线程都在执行的过程中，其操作都是 <code>a += 1</code>。具体过程如下：<br>① 此时我们有一个变量 <code>a = 1</code>，首先 <code>Thread 1</code> 获取到了 <code>a</code>，执行操作后 <code>a=2</code>；</p>
<p>② <code>Thread 2</code> 获取到了 <code>a</code>，执行操作后 <code>a=3</code>；</p>
<p>③ <code>Thread 1</code> 获取到了 <code>a</code>，执行操作后 <code>a=4</code>；</p>
<p>④ <code>Thread 2</code> 获取到了 <code>a</code>，执行操作后 <code>a=5</code>；</p>
<p>⑤ <code>Thread 1</code> 和 <code>Thread 2</code> 同时获取到了 <code>a</code>，同时执行操作后 <code>a=6</code>；</p>
<p>一共执行了 <code>6</code> 次操作，<code>a</code> 应该由 <code>1</code> 变成 <code>7</code>。但是实际上他最终的结果是 <code>6</code> 。</p>
<img src="./Cpp_Muti_Threaded/ThreadWithNoMutex.png" style="zoom: 50%;" >

<p><strong>下面演示这种错误：</strong></p>
<p>在这个案例中，我们运行了两个线程 <code>t1</code> 和 <code>t2</code>，每个线程都让 <code>a</code> 加 <code>50,000</code>，因此我们期待的结果是 <code>100,000</code>。但是实际上运行的结果一般是小于 <code>100,000</code> 的。比如我运行了几次，分别是：<code>78,301</code>、<code>61603</code>、<code>54843</code>。说明两个线程多个瞬间同时获取到了变量 <code>a</code>。</p>
<p>当然，循环次数较小的时候也许会出现结果正确的问题，这是因为编译器帮我们汇编成了原子操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们可以使用 <strong>互斥量<code>mutex</code></strong> 对变量进行上锁操作。**互斥量的头文件是：<code>#include &lt;mutex&gt;</code>**。</p>
<p>我们修改程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();		<span class="comment">// 加锁操作</span></span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();	<span class="comment">// 解锁操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何判断线程是否是安全的</strong>：当多线程程序每一次运行的结果，和单线程程序运行的结果始终都一样，则认为你的线程是安全的。</p>
<h3 id="🧶-7-互斥量死锁"><a href="#🧶-7-互斥量死锁" class="headerlink" title="🧶 7. 互斥量死锁"></a>🧶 7. 互斥量死锁</h3><p>假设有两个线程 <code>Thread 1</code> 和 <code>Thread 2</code>，他们需要对互斥量 <code>mtx1</code> 和互斥量<code>mtx2</code> 进行访问，而且需要按照以下顺序<strong>获取互斥量的所有权（获取所有权可以理解为<em>加锁操作</em> ）</strong>：</p>
<ul>
<li><code>Thread 1</code> 先获取 <code>mtx1</code> 的所有权，再获取 <code>mtx2</code> 的所有权。</li>
<li><code>Thread 2</code> 先获取 <code>mtx2</code> 的所有权，再获取 <code>mtx1</code> 的所有权。</li>
</ul>
<p>此时如果两个线程同时运行，就会产生死锁：</p>
<p><code>Thread 1</code> 拿到了 <code>mtx1</code>，同时 <code>Thread 2</code> 拿到了 <code>mtx2</code>。</p>
<p>但是此时因为 <code>Thread 2</code> 占有 <code>mtx2</code> 所以 <code>Thread 1</code> 等待 <code>mtx2</code> 空闲；而 <code>Thread 1</code> 占有 <code>mtx1</code>，所以 <code>Thread 2</code> 等待 <code>mtx1</code> 空闲。</p>
<p>所以此时 <code>Thread 1</code> 和 <code>Thread 2</code> 都无法进一步操作，所以造成了死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 死锁模拟 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	mtx1.<span class="built_in">lock</span>();		<span class="comment">// 先获取 mtx1</span></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">1000</span>);		<span class="comment">// 这里停等 1s, 确保 thread_2 抢占到 mtx2</span></span><br><span class="line">	mtx2.<span class="built_in">lock</span>();		<span class="comment">// 再获取 mtx2</span></span><br><span class="line">	mtx2.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx2</span></span><br><span class="line">	mtx1.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	mtx2.<span class="built_in">lock</span>();		<span class="comment">// 先获取 mtx2</span></span><br><span class="line">	mtx1.<span class="built_in">lock</span>();		<span class="comment">// 再获取 mtx1</span></span><br><span class="line">	mtx1.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx1</span></span><br><span class="line">	mtx2.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_1</span><span class="params">(func_1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">	thread_1.<span class="built_in">join</span>();</span><br><span class="line">	thread_2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;THREAD OVER...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用顺序锁解决上述问题，即两个函数都先获取 <code>mtx1</code> 的所有权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	mtx1.<span class="built_in">lock</span>();		<span class="comment">// 先获取 mtx1</span></span><br><span class="line">	mtx2.<span class="built_in">lock</span>();		<span class="comment">// 再获取 mtx2</span></span><br><span class="line">	mtx2.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx2</span></span><br><span class="line">	mtx1.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	mtx1.<span class="built_in">lock</span>();		<span class="comment">// 先获取 mtx1</span></span><br><span class="line">	mtx2.<span class="built_in">lock</span>();		<span class="comment">// 再获取 mtx2</span></span><br><span class="line">	mtx2.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx2</span></span><br><span class="line">	mtx1.<span class="built_in">unlock</span>();		<span class="comment">// 释放 mtx1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_1</span><span class="params">(func_1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread_2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">	thread_1.<span class="built_in">join</span>();</span><br><span class="line">	thread_2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;THREAD OVER...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧶-8-lock-guard-和-unique-lock"><a href="#🧶-8-lock-guard-和-unique-lock" class="headerlink" title="🧶 8. lock_guard 和 unique_lock()"></a>🧶 8. <code>lock_guard</code> 和 <code>unique_lock()</code></h3><h4 id="8-1-lock-guard"><a href="#8-1-lock-guard" class="headerlink" title="8.1 lock_guard"></a>8.1 <code>lock_guard</code></h4><p><code>lock_guard</code> 是 <code>C++</code> 标准库中一种互斥量的封装类，用于保护共享数据，防止多个线程同时访问统一资源而导致的数据竞争问题。<code>lock_guard</code> 具有以下特点。</p>
<ul>
<li>当构造函数被调用时，该互斥量会被自动锁定</li>
<li>当析构函数被调用时，该互斥量会被自动解锁</li>
<li><code>std::lock_guard</code> 对象不能复制或移动，因此他只能在局部作用域中使用</li>
</ul>
<p>下面简单看几段代码，来体会一下不使用 <code>lock_guard</code> 和使用 <code>lock_guard</code> 的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不使用 lock_guard 和 unique_lock() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();		<span class="comment">// 加锁操作</span></span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();	<span class="comment">// 解锁操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们添加 <code>lock_guard</code> 后，代码会变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;	<span class="comment">// 这里调用了构造函数, mtx 自动加锁</span></span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="comment">// 这里调用了析构函数, mtx 自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以详细剖析 <code>lock_guard</code> 的源码，来深刻理解该类。</p>
<p>补充阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chaipp0607/article/details/100128842">C++ using 用法</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Mutex</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_NODISCARD</span> lock_guard &#123; <span class="comment">// class with destructor that unlocks a mutex</span></span><br><span class="line"><span class="comment">// 这里定义了一个模板类 lock_guard, 其中 _Mutex 是模板参数, 表示互斥锁的类型</span></span><br><span class="line"><span class="comment">// _NODISCARD 是一个属性, 表示这个类不应该被忽略(通常是为了警告开发者不要忽略这个类的对象创建)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> mutex_type = _Mutex;	<span class="comment">// 定义一个别名 mutex_type, 指向模板参数 _Mutex</span></span><br><span class="line">    							<span class="comment">// 这样可以方便地在类的其他地方使用 mutex_type 来表示互斥锁的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个构造函数, 接收一个互斥锁的引用 _Mtx</span></span><br><span class="line">    <span class="comment">// explicit 关键字防止隐式转换</span></span><br><span class="line">    <span class="comment">// 在构造函数体内, 调用 _MyMutex.lock() 方法锁定互斥锁</span></span><br><span class="line">    <span class="comment">// 这样, 当 lock_guard 对象被创建时, 互斥锁会自动被锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(_Mutex&amp; _Mtx)</span> : _MyMutex(_Mtx) &#123;</span> <span class="comment">// construct and lock</span></span><br><span class="line">        _MyMutex.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是另一个构造函数, 接收一个互斥锁的引用 _Mtx 和一个标记类型 adopt_lock_t</span></span><br><span class="line">    <span class="comment">// 这个构造函数不会锁定互斥锁, 假设互斥锁已经被锁定</span></span><br><span class="line">    <span class="comment">// adopt_lock_t 通常是一个空的结构体类型, 用于区分不同的构造函数</span></span><br><span class="line">    <span class="built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="type">adopt_lock_t</span>) : _MyMutex(_Mtx) &#123;&#125; <span class="comment">// construct but don&#x27;t lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数标记为 noexcept, 表示不会抛出异常</span></span><br><span class="line">    <span class="comment">// 当 lock_guard 对象被销毁时, 调用 _MyMutex.unlock() 方法解锁互斥锁</span></span><br><span class="line">    <span class="comment">// 这确保了即使在异常情况下，互斥锁也会被解锁。</span></span><br><span class="line">    ~<span class="built_in">lock_guard</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        _MyMutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式删除拷贝构造函数和赋值操作符</span></span><br><span class="line">    <span class="comment">// 防止 lock_guard 对象被复制或赋值</span></span><br><span class="line">    <span class="comment">// 这是因为互斥锁的所有权不应该在多个对象之间共享, 以避免潜在的并发问题。</span></span><br><span class="line">    <span class="built_in">lock_guard</span>(<span class="type">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    lock_guard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Mutex&amp; _MyMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>; <span class="comment">// 1. 创建 lock_guard 对象 lg </span></span><br><span class="line">        									 <span class="comment">// 2. 传递 mtx 给构造函数的参数 _Mtx</span></span><br><span class="line">                                             <span class="comment">// 3. lock_guard 构造函数被调用</span></span><br><span class="line">                                             <span class="comment">// 4. _MyMutex(_Mtx) 初始化私有成员 _MyMutex 为 mtx 的引用</span></span><br><span class="line">                                             <span class="comment">// 5. _MyMutex.lock() 锁定 mtx</span></span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// 6. 循环结束时, lg 对象销毁, 调用析构函数 _MyMutex.unlock() 解锁 mtx</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-unique-lock"><a href="#8-2-unique-lock" class="headerlink" title="8.2 unique_lock"></a>8.2 <code>unique_lock</code></h4><p><code>std::unique_lock</code> 是 <code>C++</code> 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。与 <code>lock_guard</code> 仅提供自动的加锁、解锁操作不同，<code>unique_lock</code> 还提供了对互斥量进行更加灵活的管理，包括：延迟加锁、条件变量、超时等。</p>
<p><code>std::unique_lock</code> 提供了以下几个成员函数：</p>
<ul>
<li><code>lock</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。</li>
<li><code>try_lock</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则立刻返回 <code>false</code>，否则返回 <code>true</code>。</li>
<li><code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>：尝试对互斥量进行加锁操作，，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁或超过了指定时间。</li>
<li><code>try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁或超过了指定时间点。</li>
<li><code>unlock()</code>：对互斥量进行解锁操作</li>
</ul>
<p>下面简单看几段代码，来体会一下不使用 <code>unique_lock</code> 和使用 <code>unique_lock</code> 的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不使用 unique_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();		<span class="comment">// 加锁操作</span></span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();	<span class="comment">// 解锁操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 unique_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们演示一下 <code>unique_lock</code> 的更多操作：</p>
<h5 id="8-2-1-lock-unlock-手动加锁-解锁"><a href="#8-2-1-lock-unlock-手动加锁-解锁" class="headerlink" title="8.2.1 lock()/unlock() 手动加锁&#x2F;解锁"></a>8.2.1 <code>lock()/unlock()</code> 手动加锁&#x2F;解锁</h5><p>既然 <code>unique_lock</code> 支持自动加锁和自动解锁，那么我们为什么不让它自动的加锁和解锁呢？这是因为 <code>unique_lock</code> 提供了更多的加锁方式，在使用其他加锁方式之前，我们需要保证 <code>unique_lock</code> 不能自动加锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx, std::defer_lock)</span></span>; 	<span class="comment">// 传入 defer_lock 表示构造函数什么都不做</span></span><br><span class="line">																<span class="comment">// 加锁/解锁操作需要由程序员自己完成</span></span><br></pre></td></tr></table></figure>

<p>那么下面将代码修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不使用 unique_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx, std::defer_lock)</span></span>;	<span class="comment">// 使用 unique_lock 进行自动加锁</span></span><br><span class="line">		uniqueLock.<span class="built_in">lock</span>();</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">		uniqueLock.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-2-try-lock-尝试加锁"><a href="#8-2-2-try-lock-尝试加锁" class="headerlink" title="8.2.2 try_lock 尝试加锁"></a>8.2.2 <code>try_lock</code> 尝试加锁</h5><p>尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。</p>
<h5 id="8-2-3-try-lock-for-const-std-chrono-duration-rel-time"><a href="#8-2-3-try-lock-for-const-std-chrono-duration-rel-time" class="headerlink" title="8.2.3 try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"></a>8.2.3 <code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code></h5><p>尝试对互斥量进行加锁操作，，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁或超过了指定时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::timed_mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::timed_mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">        <span class="comment">// 这里进行判断, 通过检查 try_lock_for 的返回值, 只有在成功锁定时才修改 a, 保证了互斥锁的有效性。</span></span><br><span class="line">		<span class="keyword">if</span> (uniqueLock.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">5</span>))) &#123;</span><br><span class="line">			std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">			a += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见错误：<code>&quot;try_lock_for&quot;: 不是 &quot;std::mutex&quot; 的成员</code>，<code>std::mutex</code> 不支持延迟加锁，当我们想要进行延迟加锁操作时，需要保证互斥量是时间锁，即 <code>timed_mutex</code>。</p>
<p>此外，不要想当然，以下是一种常见的错误写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不使用 unique_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::timed_mutex mtx;			<span class="comment">// 定义互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::timed_mutex&gt; <span class="title">uniqueLock</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">        <span class="comment">// try_lock_for 尝试锁定互斥锁, 但返回值没有被检查</span></span><br><span class="line">        <span class="comment">// 如果锁定失败, 代码仍然会执行 a += 1, 这会导致数据竞争</span></span><br><span class="line">		uniqueLock.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 即使 try_lock_for 失败, 代码仍然会增加 a, 这使得互斥锁形同虚设</span></span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-4-try-lock-until-const-std-chrono-time-point-abs-time"><a href="#8-2-4-try-lock-until-const-std-chrono-time-point-abs-time" class="headerlink" title="8.2.4 try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"></a>8.2.4 <code>try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code></h5><p>尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁或超过了指定时间点。</p>
<h3 id="🧶-9-call-once-实现单例模式"><a href="#🧶-9-call-once-实现单例模式" class="headerlink" title="🧶 9. call_once 实现单例模式"></a>🧶 9. <code>call_once</code> 实现单例模式</h3><h4 id="9-1-单例模式"><a href="#9-1-单例模式" class="headerlink" title="9.1 单例模式"></a>9.1 单例模式</h4><p><strong>单例模式：</strong>单例模式是一种常见的设计模式，用于确保在系统的整个声明周期内，某个类只能创建一个实例，确保该类的唯一性。<u><em>由于单例模式是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑<strong>线程安全</strong>问题。</em></u></p>
<p><strong>为什么要使用单例模式：</strong>① 节约资源，一个类只有一个实例，不存在多份实例，节省资源；② 方便控制，在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。</p>
<p><strong>单例模式分类：</strong>单例模式可以分为 <em>懒汉式</em> 和 <em>饿汉式</em> ，两者之间的区别在于创建实例的时间不同。</p>
<ul>
<li><strong>懒汉式：</strong>系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例，延迟实例化。这种方式要考虑线程安全。</li>
<li><strong>饿汉式：</strong>系统一运行，就初始化创建实例，当需要时，直接调用即可，提前实例化。这种方式本身就线程安全，没有多线程的线程安全问题。</li>
</ul>
<p><strong>单例类的特点：</strong></p>
<ul>
<li>构造函数和析构函数为私有类型，目的是禁止外部构造和析构。</li>
<li>拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。</li>
<li>类中有一个获取实例的静态方法，可以全局访问。</li>
</ul>
<h4 id="9-2-emplace-back-函数快速了解"><a href="#9-2-emplace-back-函数快速了解" class="headerlink" title="9.2 emplace_back 函数快速了解"></a>9.2 <code>emplace_back</code> 函数快速了解</h4><p>这里使用到了 <code>emplace_back</code>，<code>emplace_back</code> 是 <code>C++ 11</code> 引入的一个 <code>STL</code> 容器方法，用于在容器的末尾直接构造元素。为了更好的理解代码，这里补充一下 <code>emplace_back</code> 的基本用法：</p>
<p><code>emplace_back</code> 方法提供了一种高效、简便的方式在容器末尾添加新元素。与 <code>push_back</code> 方法不同，<code>emplace_back</code> 直接在容器内部构造元素，而不是先构造临时对象然后再移动或复制到容器中。</p>
<h5 id="9-2-1-具体示例"><a href="#9-2-1-具体示例" class="headerlink" title="9.2.1 具体示例"></a>9.2.1 具体示例</h5><p>假设我们有一个包含复杂对象的 <code>std::vector</code>，我们可以使用 <code>emplace_back</code> 来避免不必要的临时对象创建和销毁。</p>
<ul>
<li>使用 <code>push_back</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="type">int</span> a, <span class="type">const</span> std::string&amp; b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyStruct&gt; vec;</span><br><span class="line">    <span class="function">MyStruct <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;example&quot;</span>)</span></span>;				<span class="comment">// 先从外部构造 obj</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(obj); 					<span class="comment">// 复制构造</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">MyStruct</span>(<span class="number">2</span>, <span class="string">&quot;example2&quot;</span>)); <span class="comment">// 临时对象构造然后移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>emplace_back</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="type">int</span> a, <span class="type">const</span> std::string&amp; b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyStruct&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;example&quot;</span>); 	<span class="comment">// 直接在容器内构造</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">2</span>, <span class="string">&quot;example2&quot;</span>); 	<span class="comment">// 直接在容器内构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>emplace_back</code> 时，构造函数的参数直接传递给容器内的新对象构造函数，避免了临时对象的创建。</p>
<h5 id="9-2-2-在多线程中使用-emplace-back"><a href="#9-2-2-在多线程中使用-emplace-back" class="headerlink" title="9.2.2 在多线程中使用 emplace_back"></a>9.2.2 在多线程中使用 <code>emplace_back</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    threads.emplace_back(threadFunction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>emplace_back</code> 用于将新的 <code>std::thread</code> 对象添加到 <code>std::vector&lt;std::thread&gt;</code> 容器中。</p>
<p>等效的 <code>push_back</code> 用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    threads.push_back(std::thread(threadFunction));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>push_back</code> 和 <code>emplace_back</code> 都可以使用，但 <code>emplace_back</code> 更加高效，因为它避免了临时对象的创建和销毁。使用 <code>emplace_back</code> 时，<code>std::thread</code> 对象直接在 <code>threads</code> 容器中构造：</p>
<ol>
<li><strong>构造新对象</strong>：<code>emplace_back</code> 方法直接在容器的内存空间中构造新对象，而不是先在别处构造然后移动到容器中。</li>
<li><strong>传递参数</strong>：<code>emplace_back</code> 将传递的参数直接用于新对象的构造函数，此处 <code>threadFunction</code> 被作为构造函数参数传递给 <code>std::thread</code>。</li>
</ol>
<h5 id="9-2-3-总结"><a href="#9-2-3-总结" class="headerlink" title="9.2.3 总结"></a>9.2.3 总结</h5><p>**<code>push_back</code>**：需要一个已经构造好的对象（可能会导致额外的复制或移动）。</p>
<p>**<code>emplace_back</code>**：直接在容器的内存空间内构造对象，避免了额外的临时对象创建和移动操作。</p>
<p>在多线程代码中，使用 <code>emplace_back</code> 可以使代码更加高效和简洁，尤其是在添加新对象到容器时，可以避免不必要的对象拷贝和临时对象创建。</p>
<h4 id="9-3-线程不安全的懒汉模式"><a href="#9-3-线程不安全的懒汉模式" class="headerlink" title="9.3 线程不安全的懒汉模式"></a>9.3 线程不安全的懒汉模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        logFile_ &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLog</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instance Address IS: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        logFile_.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line">        <span class="keyword">if</span> (!logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to open log file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            logFile_.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Logger* instance;</span><br><span class="line">    std::ofstream logFile_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Logger* Logger::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger&amp; logger = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line">    logger.<span class="built_in">printLog</span>(<span class="string">&quot;Logging from thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Instance Address IS: Instance Address IS: 000001FE29979930Instance Address IS: 000001FE2997A2A0</span><br><span class="line">Logging from thread</span><br><span class="line">000001FE29979930</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001FE2997C330</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001FE2997C330</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001FE2997B840</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001FE2997ACD0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001FE2997C330</span><br><span class="line">Logging from thread</span><br><span class="line">Logging from thread</span><br><span class="line"></span><br><span class="line">Instance Address IS: 000001FE2997C330</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001FE2997C330</span><br><span class="line">Logging from thread</span><br></pre></td></tr></table></figure>

<p>我们可以看到多个不同的实例地址，这是因为：在多线程环境中，当多个线程同时调用 <code>getInstance</code> 方法时，有可能多个线程同时通过 <code>if (instance == nullptr)</code> 检查，并进入实例化代码块。这会导致多个线程同时创建多个实例，违背了单例模式的初衷。</p>
<h4 id="9-4-线程安全的懒汉模式"><a href="#9-4-线程安全的懒汉模式" class="headerlink" title="9.4 线程安全的懒汉模式"></a>9.4 线程安全的懒汉模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(log_mtx_)</span></span>;</span><br><span class="line">        logFile_ &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLog</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instance Address IS: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        logFile_.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line">        <span class="keyword">if</span> (!logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to open log file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            logFile_.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Logger* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx_;</span><br><span class="line">    std::mutex log_mtx_;</span><br><span class="line">    std::ofstream logFile_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Logger* Logger::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Logger::mtx_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger&amp; logger = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line">    logger.<span class="built_in">printLog</span>(<span class="string">&quot;Logging from thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 000001E13A41AFE0</span><br><span class="line">Logging from thread</span><br></pre></td></tr></table></figure>

<h4 id="9-5-饿汉模式"><a href="#9-5-饿汉模式" class="headerlink" title="9.5 饿汉模式"></a>9.5 饿汉模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        logFile_ &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLog</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instance Address IS: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        logFile_.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line">        <span class="keyword">if</span> (!logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to open log file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            logFile_.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Logger instance;</span><br><span class="line">    std::ofstream logFile_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Logger Logger::instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger&amp; logger = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line">    logger.<span class="built_in">printLog</span>(<span class="string">&quot;Logging from thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br><span class="line">Instance Address IS: 00007FF652E1F6B0</span><br><span class="line">Logging from thread</span><br></pre></td></tr></table></figure>

<h4 id="9-6-使用-call-once-实现单例模式"><a href="#9-6-使用-call-once-实现单例模式" class="headerlink" title="9.6 使用 call_once 实现单例模式"></a>9.6 使用 <code>call_once</code> 实现单例模式</h4><p>为了使用 <code>std::call_once</code> 保证 <code>Logger</code> 类的线程安全，我们可以利用 <code>std::call_once</code> 和 <code>std::once_flag</code> 来确保单例实例只被创建一次。<code>std::call_once</code> 是一个 <code>C++ 11</code> 引入的机制，用于确保给定的函数只被调用一次，即使在多线程环境下。</p>
<p>以下是一个使用 <code>std::call_once</code> 实现线程安全单例模式的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(initInstanceFlag, &amp;Logger::initSingleton);	<span class="comment">// 传入 once_flag 和 initSingleton 函数</span></span><br><span class="line">        <span class="keyword">return</span> *instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        logFile_ &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLog</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instance Address IS: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        logFile_.<span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line">        <span class="keyword">if</span> (!logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to open log file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (logFile_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            logFile_.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">initSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Logger* instance;</span><br><span class="line">    <span class="type">static</span> std::once_flag initInstanceFlag;</span><br><span class="line">    std::ofstream logFile_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员</span></span><br><span class="line">Logger* Logger::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::once_flag Logger::initInstanceFlag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger&amp; logger = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line">    logger.<span class="built_in">printLog</span>(<span class="string">&quot;Logging from thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细解释：</p>
<ol>
<li><p><strong>静态成员变量</strong>：</p>
<ul>
<li><code>static Logger* instance</code>：指向单例实例的指针。</li>
<li><code>static std::once_flag initInstanceFlag</code>：用于保证 <code>initSingleton</code> 只被调用一次的标志。</li>
</ul>
</li>
<li><p><strong><code>getInstance</code> 方法</strong>：</p>
<ul>
<li><code>std::call_once(initInstanceFlag, &amp;Logger::initSingleton)</code>：<code>std::call_once</code> 保证 <code>initSingleton</code> 在多线程环境下只被调用一次。<code>initInstanceFlag</code> 确保 <code>initSingleton</code> 只会被执行一次，即使多个线程同时调用 <code>getInstance</code>。</li>
</ul>
</li>
<li><p><strong><code>initSingleton</code> 方法</strong>：</p>
<ul>
<li><code>initSingleton</code> 是一个静态方法，用于初始化单例实例。<code>std::call_once</code> 会调用此方法来创建单例实例。</li>
</ul>
</li>
<li><p><strong>构造函数和析构函数</strong>：</p>
<ul>
<li><code>Logger</code> 的构造函数和析构函数负责打开和关闭日志文件。</li>
</ul>
</li>
<li><p><strong><code>log</code> 和 <code>printLog</code> 方法</strong>：</p>
<ul>
<li><code>log</code> 方法使用互斥锁 <code>mtx_</code> 保护对日志文件的写操作，以确保线程安全。</li>
<li><code>printLog</code> 方法输出实例的地址和消息。</li>
</ul>
</li>
</ol>
<p>运行上述代码时，所有线程都会调用 <code>Logger::getInstance()</code> 获取单例实例。由于使用了 <code>std::call_once</code>，<code>initSingleton</code> 方法只会被执行一次，从而确保整个程序中只有一个 <code>Logger</code> 实例。通过输出的实例地址，可以验证所有线程获取的都是相同的实例。</p>
<p>使用 <code>std::call_once</code> 和 <code>std::once_flag</code> 可以确保单例实例在多线程环境下只被创建一次，从而实现线程安全的懒汉单例模式。这样不仅保证了线程安全性，还避免了不必要的锁开销。</p>
<h3 id="🧶-10-condition-variable-条件变量"><a href="#🧶-10-condition-variable-条件变量" class="headerlink" title="🧶 10. condition_variable 条件变量"></a>🧶 10. <code>condition_variable</code> 条件变量</h3><p><code>conditon_variable</code> 可以用来实现一个生产者消费者程序。</p>
<p>例如对于一个队列：</p>
<ul>
<li>只要队列不满，生产者就可以进行生产</li>
<li>只要队列满了，生产者就停止生产</li>
<li>只要队列不空，消费者就可以进行消费</li>
<li>只要队列空了，消费者就停止消费</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;                 <span class="comment">// 共享缓冲区</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> maxBufferSize = <span class="number">10</span>;  <span class="comment">// 缓冲区的最大大小</span></span><br><span class="line">std::mutex mtx;                         <span class="comment">// 互斥锁, 用于保护共享缓冲区</span></span><br><span class="line">std::condition_variable cv;             <span class="comment">// 条件变量, 用于通知生产者和消费者</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">done</span><span class="params">(<span class="literal">false</span>)</span></span>;          <span class="comment">// 原子变量, 用于通知消费者生产者已经完成生产</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> numItems)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numItems; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 锁定互斥锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待直到缓冲区有空闲位置</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; maxBufferSize; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将生成的数据放入缓冲区</span></span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();      <span class="comment">// 解锁互斥锁</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();    <span class="comment">// 通知消费者缓冲区中有新数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟生产延迟</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 done 标志，通知消费者生产已经完成</span></span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// 通知消费者停止等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 锁定互斥锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待直到缓冲区有数据或生产已经完成</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>() || done; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果生产已经完成且缓冲区为空, 退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (done &amp;&amp; buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓冲区取出数据</span></span><br><span class="line">        <span class="type">int</span> item = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        lock.<span class="built_in">unlock</span>();      <span class="comment">// 解锁互斥锁</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();    <span class="comment">// 通知生产者有空闲位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟消费延迟</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numProducers = <span class="number">2</span>;     	<span class="comment">// 生产者线程数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numConsumers = <span class="number">2</span>;     	<span class="comment">// 消费者线程数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numItems     = <span class="number">40</span>;    	<span class="comment">// 每个生产者生成的项目数量</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; producers;  <span class="comment">// 生产者线程列表</span></span><br><span class="line">    std::vector&lt;std::thread&gt; consumers;  <span class="comment">// 消费者线程列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numProducers; ++i) &#123;</span><br><span class="line">        producers.<span class="built_in">emplace_back</span>(producer, i, numItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numConsumers; ++i) &#123;</span><br><span class="line">        consumers.<span class="built_in">emplace_back</span>(consumer, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有生产者线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; producer : producers) &#123;</span><br><span class="line">        producer.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有消费者线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; consumer : consumers) &#123;</span><br><span class="line">        consumer.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧶-11-线程池-Thread-Pool"><a href="#🧶-11-线程池-Thread-Pool" class="headerlink" title="🧶 11. 线程池 Thread Pool"></a>🧶 11. 线程池 Thread Pool</h3><h4 id="11-1-线程的消耗"><a href="#11-1-线程的消耗" class="headerlink" title="11.1 线程的消耗"></a>11.1 线程的消耗</h4><p>为了完成任务，创建很多线程可以吗？线程真的是越多越好吗？</p>
<ul>
<li><p>线程的创建和销毁都是非常”重”的操作</p>
<p>线程的创建和销毁都需要执行不少操作，下面的操作只是一个简化的操作，具体的操作可以深入了解操作系统的原理。</p>
<p>那么如果要在业务执行的过程中去实时的创建和销毁线程，那么是一种很消耗系统资源和性能的操作。</p>
</li>
</ul>
<img src="./CPP_Muti_Threaded/Create_Thread.png" alt="线程创建的操作(简化版)" style="zoom:50%;" >

<ul>
<li><p>线程栈本身占用大量内存</p>
<p><code>32</code> 位操作系统的地址空间大小为 $2^{32}$ 个地址，即 <code>4 GB</code>。其中一部分地址空间用于操作系统的内核空间，而另一部分则用于用户空间。通常情况下，用户空间可以是 <code>2 GB</code> 或者 <code>3 GB</code>，剩下的全部是内核空间。具体取决于操作系统的设置。由当前进程创建的所有线程，共享进程的地址空间。</p>
<p>那么一个进程最多可以开多少线程呢？</p>
<p>假设用户空间为 <code>3 GB</code>，即 $3 × 1024 &#x3D; 3072$，在 Linux 环境下使用 <code>ulimit -a</code> 可以查询到系统的一些信息，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 3795</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 3795</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>Stack Size</code> 为 <code>8192 kbytes</code>，即 <code>8 MB</code>，则可计算 $3072 ÷ 8 &#x3D; 384$，所以在 Linux 环境下，一个进程最多创建 $384$ 个线程。</p>
<p>我们将线程函数所用的栈空间就是线程栈。</p>
<img src="./Cpp_Muti_Threaded/ThreadStack.png" style="zoom: 50%;" >

<p>通过上面的描述，我们可以发现，如果线程数量太多，创建了一大批线程，还没有具体做事情，每一个线程都需要线程栈，栈几乎都被占用完了，就没内存运行其他程序了。</p>
</li>
<li><p>线程的上下文切换要占用大量时间</p>
<p>线程过多，线程的调度是需要上下文切换的，也需要花费大量的 <code>CPU</code> 时间，如果更多的时间花费到上下文切换中，那么实际业务中利用 <code>CPU</code> 的时间就降低了，<code>CPU</code> 的利用率就降低了。</p>
</li>
<li><p>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机</p>
<p>这种情况下，如果同一时间，很多 I&#x2F;O 操作都准备好了，或者说很多线程都再等待一个 I&#x2F;O 操作，有可能导致大量线程同时被唤醒，导致系统经常出现锯齿状负载或者瞬间负载量很大导致宕机。</p>
</li>
</ul>
<p>所以我们可以看出，<strong>线程不是越多越好</strong>。那么创建多少线程才是合适的呢？</p>
<p>一般来说，创建线程的数量一般由 <code>CPU</code> 的核心数来确定的，即：有几个核创建几个线程。<code>C++</code> 的很多开源库如 <code>moduo</code>、<code>libevent</code>，<code>Java</code> 的 <code>Netty</code>、<code>mina</code> 等，都采取了这一策略。</p>
<p>当然如果一个功能是重 <code>I/O</code> 的，可以做出适当的调整，增加线程数量。</p>
<h4 id="11-2-什么是线程池？为什么使使用线程池"><a href="#11-2-什么是线程池？为什么使使用线程池" class="headerlink" title="11.2 什么是线程池？为什么使使用线程池"></a>11.2 什么是线程池？为什么使使用线程池</h4><p><u>线程过多会带来调度开销，进而影响缓存局部性和整体性能</u>。操作系统上创建线程和销毁线程都是很“重”的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，业务的处理能力也会降低。</p>
<p><strong>线程池</strong>是一种预先创建一定数量线程的机制，或者说其是一种线程使用模式。</p>
<p><strong>线程池</strong>维护着多个线程，这些线程可以在需要时被重复使用，而无需每次都重新创建和销毁线程。</p>
<p><strong>线程池</strong>的主要目的是提高性能和资源利用效率，特别是在需要频繁创建和销毁大量线程的场景下，线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数据取决于可用的并发处理器、处理器内核、内存、网络 <code>sockets</code> 等数量。</p>
<p><strong>线程池的优势：</strong>线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 <code>Task</code> 任务即可，<code>Task</code> 执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的 <code>Task</code> 提供服务。</p>
<p><strong>线程池的优点：</strong></p>
<ul>
<li>线程和任务分离,提升线程重用性；</li>
<li>控制线程并发数量,降低服务器压力，统一管理所有线程；</li>
<li>提高性能：提升系统响应速度，假如创建线程用的时间为 <code>T1</code>，执行任务用的时间为<code>T2</code>，销毁线程用的时间为 <code>T3</code>，那么使用线程池就免去了 <code>T1</code> 和 <code>T3</code> 的时间。创建和销毁线程都是相对昂贵的操作，特别是在高并发场景下，频繁地创建和销毁线程会极大地降低程序的性能。通过线程池预先创建一定数量的线程并保存在内存中，可以避免频繁地创建和销毁线程，从而提高程序的性能。</li>
<li>资源管理：线程是操作系统级别的资源，如果线程数量过多，可能会导致系统资源的过度消耗，甚至可能导致系统崩溃。通过线程池，可以控制同时运行的线程数量，避免资源过度消耗。</li>
<li>任务调度：线程池可以更方便地进行任务的调度。通过线程池，可以将任务分配给不同的线程执行，实现并行处理，提高程序的执行效率。</li>
<li>简化编程：使用线程池可以简化多线程编程的复杂性。程序员只需要将任务提交给线程池，而不需要关心线程的创建、管理和销毁等细节，降低了多线程编程的难度。</li>
</ul>
<p>因此，C++线程池的出现是为了解决在高并发场景下创建和销毁线程的开销问题，提高程序的性能和并发处理能力，简化多线程编程的复杂性。</p>
<p><strong>在项目中如何使用线程池？</strong></p>
<p>以一个添加订单功能为例，我们需要查询用户的收获地址和商品信息。在单线程的代码中，我们需要按照顺序进行查询；而在多线程的代码中，我们在保证两个功能没有依赖关系的情况下可以同时查询（即不需要先查询用户的收获地址，再根据收获地址查询商品信息）。</p>
<p>顺序执行的速度是 <code>503 ms</code>，而多线程执行的速度是 <code>329 ms</code>，能明显提高运行速度（效率提升幅度在 50%~60%）。</p>
<h4 id="11-3-线程池的两种模式"><a href="#11-3-线程池的两种模式" class="headerlink" title="11.3 线程池的两种模式"></a>11.3 线程池的两种模式</h4><h5 id="11-3-1-fixed-模式线程池"><a href="#11-3-1-fixed-模式线程池" class="headerlink" title="11.3.1 fixed 模式线程池"></a>11.3.1 <code>fixed</code> 模式线程池</h5><p><code>fixed</code> 模式线程池里面的线程个数是固定不变的，一般是 <code>ThreadPool</code> 创建时，根据当前机器的 <code>CPU</code> 核心数量进行指定。</p>
<h5 id="11-3-2-cache-模式线程池"><a href="#11-3-2-cache-模式线程池" class="headerlink" title="11.3.2 cache 模式线程池"></a>11.3.2 <code>cache</code> 模式线程池</h5><p>假设一个线程池内有四个线程，然后此时出现了四个非常耗时的 <code>I/O</code> 操作任务，此时每个线程分配了一个任务，导致四个线程都被占用阻塞在这里了。此时又出现了一些任务，但是由于线程池中的线程长时间阻塞，所以新的任务可能迟迟得不到处理，此时新的任务堵在任务队列中，相当于整个程序卡死在了这里。在这种情况下，我们希望我们线程池的大小是可以动态改变的，这就是 <code>cache</code> 模式的线程池。</p>
<p><code>cache</code>模式的线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。</p>
<h4 id="11-4-线程池的架构、流程和使用方式"><a href="#11-4-线程池的架构、流程和使用方式" class="headerlink" title="11.4 线程池的架构、流程和使用方式"></a>11.4 线程池的架构、流程和使用方式</h4><img src="./Cpp_Muti_Threaded/ThreadPoolStructure.png">

<p>由图所示，我们的线程池主要需要完成以下几个操作：</p>
<ul>
<li>创建线程池、设置线程池模式、启动线程池</li>
<li>提交异步任务：<code>Result result = pool.submitTask(concreteTask);</code></li>
<li>保证可以接受各种各样的任务</li>
<li>获取异步任务的处理结果（这里需要用到 <code>Any</code> 上帝类）</li>
<li>实现任务队列，这里任务队列要保证线程安全，且任务队列的任务数不宜过多（过多会导致大量的内存占用）</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ailumiyana/p/10016965.html">基于C++11实现线程池的工作原理 - 靑い空゛ - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44667165/article/details/135287449">C++线程池的原理（画图）及简单实现+例子（加深理解）_C++ 线程池原理 - CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000044967349">C++: 每一个C++程序员都应该知道的RAII - 个人文章 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhongzhaoxie/p/13630795.html">C++线程池 - BrianX - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gnivor/p/15919850.html">C++笔记-Atomic原子操作&#x2F;CAS(Compare and Swap) - 流了个火 - 博客园 (cnblogs.com)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-23T04:27:44.000Z" title="2024/6/23 12:27:44">2024-06-23</time>发表</span><span class="level-item"><time dateTime="2024-06-24T08:40:14.154Z" title="2024/6/24 16:40:14">2024-06-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/Gaming/">Gaming</a></span><span class="level-item">5 分钟读完 (大约756个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/23/CppGamingDEV-PVZ-BASE-EASYX/">CppGamingDEV_PVZ_BASE_EASYX</a></p><div class="content"><h2 id="🎮-从零开始进行-C-游戏开发"><a href="#🎮-从零开始进行-C-游戏开发" class="headerlink" title="🎮 从零开始进行 C++ 游戏开发"></a>🎮 从零开始进行 C++ 游戏开发</h2><p>[TOC]</p>
<h3 id="游戏场景概念"><a href="#游戏场景概念" class="headerlink" title="游戏场景概念"></a>游戏场景概念</h3><ul>
<li><strong>什么是场景?</strong><br>如果将要游戏程序比作是一场有玩家参与的盛大演出，那场景就是演出过程中的一幕。在不同的幕中，会有不同的剧本逻辑，也可能会有不同的角色登场，这些角色即游戏开发中常提到的 <code>GameObject</code> 的概念。<br>不论是玩家、敌人还是子弹、道具等，这些从概念上讲都是 <code>GameObject</code> 的范畴。他们接受着不同的场景剧本的指挥，进行着不同逻辑的演出。<br>了解了这些，我们就可以对程序的流程进行宏观的划分，游戏的主菜单是一个场景，玩家角色选择界面也是一个场景，游戏局内的逻辑也需要放置在一个单独的场景中。<br>所以我们就可以定义一个 <code>Scene</code> 场景基类，<strong>主菜单</strong>、<strong>角色选择</strong>、<strong>局内游戏</strong> 作为新类分别继承 <code>Scene</code> 类。</li>
</ul>
<h3 id="游戏主循环框架概念"><a href="#游戏主循环框架概念" class="headerlink" title="游戏主循环框架概念"></a>游戏主循环框架概念</h3><ul>
<li><strong>什么是游戏主循环框架?</strong><br>游戏程序的主体是一个永不停歇的死循环。在每次循环中，我们读取玩家的操作信息，并根据这些操作，处理玩家数据更新，在最后的绘图阶段将游戏画面根据这些更新后的数据渲染出来。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    读取操作();</span><br><span class="line">    处理数据();</span><br><span class="line">    绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">施放资源;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++ 头文件"></a>C++ 头文件</h3><ul>
<li>为什么需要头文件卫士?<br>如果不使用头文件卫士，可能会导致出现重定义的问题。例如，我们有一个头文件 <code>A.h</code> ，有一个头文件 <code>B.h</code>，头文件 <code>B.h</code> 中使用了 <code>A.h</code> 的内容。当我们在主函数里面使用了 <code>A.h</code> 和 <code>B.h</code> 的时候，使用 <code>#include</code> 时会将头文件中的内容全部<strong>复制</strong>到 <code>#include</code> 的部分。这样的话如果不加头文件卫士，就会导致重定义的问题，如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span>      <span class="comment">// int a;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span>      <span class="comment">// int a;</span></span></span><br><span class="line">                    <span class="comment">// int b;</span></span><br><span class="line">                    <span class="comment">// 出现重定义错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误信息如下</span></span><br><span class="line">In file included from B.h:<span class="number">1</span>,</span><br><span class="line">             from main.cpp:<span class="number">2</span>:</span><br><span class="line">A.h:<span class="number">1</span>:<span class="number">5</span>: error: redefinition of <span class="string">&#x27;int a&#x27;</span></span><br><span class="line">    <span class="number">1</span> | <span class="type">int</span> a;</span><br><span class="line">      |     ^</span><br><span class="line">In file included from main.cpp:<span class="number">1</span>:</span><br><span class="line">A.h:<span class="number">1</span>:<span class="number">5</span>: note: <span class="string">&#x27;int a&#x27;</span> previously declared here</span><br><span class="line">    <span class="number">1</span> | <span class="type">int</span> a;</span><br><span class="line">      |     ^</span><br></pre></td></tr></table></figure>
在 <code>MSVC</code> 编译器中，头文件卫士如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>
在其他的一些编译器中，常写为这样：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HEADER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HEADER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="场景管理器"><a href="#场景管理器" class="headerlink" title="场景管理器"></a>场景管理器</h3><p>游戏程序是一个巨大的死循环，也是一个巨大的状态机。不同的游戏场景代表着不同的状态，管理着这些状态的“状态机”，在游戏开发中有一个特殊的名字——场景管理器。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T13:50:18.000Z" title="2024/5/22 21:50:18">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-07-29T07:32:26.196Z" title="2024/7/29 15:32:26">2024-07-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CppDev/">CppDev</a><span> / </span><a class="link-muted" href="/categories/CppDev/QT6/">QT6</a></span><span class="level-item">23 分钟读完 (大约3452个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Better-QT/">Better QT</a></p><div class="content"><p>[TOC]</p>
<h2 id="🍞-Better-QT"><a href="#🍞-Better-QT" class="headerlink" title="🍞 Better QT"></a>🍞 Better QT</h2><h3 id="🍦-1-Qt-的一些常用技巧"><a href="#🍦-1-Qt-的一些常用技巧" class="headerlink" title="🍦 1. Qt 的一些常用技巧"></a>🍦 1. Qt 的一些常用技巧</h3><h4 id="1-1-快捷键"><a href="#1-1-快捷键" class="headerlink" title="1.1 快捷键"></a>1.1 快捷键</h4><ul>
<li>快捷键 <code>Ctrl + Tab</code> 可以切换文件；</li>
<li>快捷键 <code>Alt + ENTER</code> 弹出代码生成提示，可以快速提示错误修改方案，类似于 IDEA 的 <code>Alt + ENTER</code>；</li>
<li>快捷键 <code>Alt + 鼠标</code> 同时输入；</li>
<li>快捷键 <code>Ctrl + R</code> 运行程序；</li>
<li>快捷键 <code>Ctrl + M</code> 创建书签（Bookmark），或者直接在某行代码前右键添加书签；</li>
<li>快捷键 <code>Ctrl + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + Shift + ENTER</code> 在当前行下方插入空行；</li>
<li>快捷键 <code>Ctrl + I</code> 代码对齐；</li>
<li>快捷键 <code>Ctrl + ;</code> 格式化代码；</li>
<li>快捷键 <code>Shift + Delete</code> 剪切当前行，可以当删除用；</li>
<li>快捷键 <code>Ctrl + Shift + R</code> 局部变量统一修改；</li>
<li>快捷键 <code>Ctrl + Shift + V</code> 复制历史；</li>
<li>用键盘模拟鼠标操作：  <table>
    <tr>
        <td colspan="3">功能键</td> 
        <td colspan="3">方向键</td> 
        <td>备注</td>
    </tr>
    <tr>
          <td>Ctrl</td>
          <td>Shift</td>
          <td>Alt</td>
          <td>左/右</td>
          <td>上/下</td>
          <td>Home/End</td>
          <td>方向键具有移动光标的作用</td>
    </tr>
    <tr>
          <td>×</td>
          <td>×</td>
          <td>×</td>
          <td>字符</td>
          <td>字符</td>
          <td>行首/行尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>×</td>
          <td>单词</td>
          <td>滚动条</td>
          <td>文件头/尾</td>
          <td>-</td>
    </tr>
    <tr>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>单词</td>
          <td>移动</td>
          <td>行首/行尾</td>
          <td>Shift具有选中文本的作用</td>
    </tr>
    <tr>
          <td>√</td>
          <td>×</td>
          <td>√</td>
          <td>-</td>
          <td>向上/下复制选中部分</td>
          <td>-</td>
          <td>-</td>
    </tr>
  </table></li>
<li>快捷键 <code>F1</code> 查看帮助、文档</li>
<li>快捷键 <code>F2</code> 快速到变量或者函数间切换</li>
<li>快捷键 <code>F4</code> 快速在<code>.cpp</code>文件和<code>.h</code>文件间切换</li>
<li>快捷键 <code>Ctrl + Shift + U</code> 查找所有使用该符号的地方</li>
<li>快捷键 <code>Ctrl + K</code> 打开定位器</li>
<li>快捷键 <code>Ctrl + L</code> 跳转到某一行</li>
<li>快捷键 <code>Ctrl + [Shift] + F</code> 查找&#x2F;替换当前文件[项目]当前选中的内容</li>
<li>快捷键 <code>[Shift] + F3</code> 查找下[上]一个</li>
<li>快捷键 <code>Ctrl + B</code> 编译工程</li>
<li>快捷键 <code>Ctrl + R</code> 运行工程</li>
<li>快捷键 <code>F5</code> 调试运行</li>
<li>快捷键 <code>Ctrl + Shift + F5</code> 重启调试</li>
<li>快捷键 <code>F9</code> 设置和取消断点</li>
<li>快捷键 <code>F10</code> 单步跳过</li>
<li>快捷键 <code>F11</code> 单步进入</li>
</ul>
<h4 id="1-2-Creator-片段"><a href="#1-2-Creator-片段" class="headerlink" title="1.2 Creator 片段"></a>1.2 Creator 片段</h4><p>片段简单理解一下就是已经写好的一些模式化的代码，用户可以使用内置片段或者根据自己的需要自定义片段。</p>
<ol>
<li>自带片段示例<br><img src="/./BetterQT/QtQuickSnippets.png" alt="Qt Quick Part"></li>
<li>自定义片段<br>一个用户的自定义片段需要以下几个内容：<br>$$片段 &#x3D; 一级标题 + 二级标题 + 片段文本$$<br>需要通过：编辑（Edit）→首选项（Preferences）→文本编辑器（Text Editor）→片段（Snippets）进行设置<br><img src="/./BetterQT/Qt_Custom_Snippets.png" alt="Qt Custom Snippets"><br>比如我要添加一个自定义片段 <code>note</code>，用来表示文件注释，可以选择 <code>Group</code> 为 <code>C++</code>，然后选择 <code>Add</code>，添加指定的内容：<br><img src="/./BetterQT/AddCustomSnippets.png" alt="Add Custom Snippets"></li>
</ol>
<h3 id="🍦-2-Qt-代码-文件解释"><a href="#🍦-2-Qt-代码-文件解释" class="headerlink" title="🍦 2. Qt 代码&#x2F;文件解释"></a>🍦 2. Qt 代码&#x2F;文件解释</h3><p>Qt的源代码和文件解释</p>
<h4 id="2-1-Qt-代码"><a href="#2-1-Qt-代码" class="headerlink" title="2.1 Qt 代码"></a>2.1 Qt 代码</h4><ul>
<li><p><code>hellocosbrowser.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLOCOSBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOCOSBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloCOSBrowser</span> : <span class="keyword">public</span> QWidget  <span class="comment">// QWidget 是所有应用程序窗口的基类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// Qt的宏, 支持 Qt 的特性, 如信号与槽、对象树、元对象等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里 HelloCOSBrowser 指定父窗口指针为 nullptr, 则它会作为一个独立的窗口进行展示, 否则则会作为父窗口的一个控件</span></span><br><span class="line">    <span class="comment">// 关于这个父窗口指针, 一个很典型的应用就是 微信</span></span><br><span class="line">    <span class="comment">// 当我们创建新窗口的时候, 如果不指定父窗口, 就会弹出一个独立的新窗口, 即电脑任务栏的图标会多出来一个</span></span><br><span class="line">    <span class="comment">// 如果指定了父窗口, 则不会创建一个独立的窗口, 即电脑任务栏处的图标不会增加</span></span><br><span class="line">    <span class="built_in">HelloCOSBrowser</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">HelloCOSBrowser</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::HelloCOSBrowser *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLOCOSBROWSER_H</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-Qt-工程文件解释"><a href="#2-2-Qt-工程文件解释" class="headerlink" title="2.2 Qt 工程文件解释"></a>2.2 Qt 工程文件解释</h4><p>文件列表</p>
<table>
<thead>
<tr>
<th align="center">文件名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>pro</code> 文件</td>
<td align="center">该文件是 Qt 的项目文件，qmake工具可以根据此文件生成 Makefile</td>
</tr>
<tr>
<td align="center"><code>pro.user</code> 文件</td>
<td align="center">该文件包含和用户相关的项目信息（用户不需要关注此文件）</td>
</tr>
<tr>
<td align="center"><code>ui</code> 文件</td>
<td align="center">Qt 的设计师界面文件</td>
</tr>
<tr>
<td align="center"><code>.cpp</code> 文件</td>
<td align="center">C++ 源文件</td>
</tr>
<tr>
<td align="center"><code>.h</code> 文件</td>
<td align="center">C++ 头文件</td>
</tr>
</tbody></table>
<h3 id="🍦-3-MOC编译器"><a href="#🍦-3-MOC编译器" class="headerlink" title="🍦 3. MOC编译器"></a>🍦 3. MOC编译器</h3><p>MOC(Meta-Object Compiler)编译器<br>C++ 编译器本身不支持 Qt 的某些机制，Qt 希望对 C++ 代码进行自动扩展，这里就需要用到宏（例如：<code>Q_Object</code>）和继承。<br>此外为了方便用户使用，希望用户无感知，可以将这一操作直接集成到框架中。</p>
<h4 id="3-1-Qt-编译过程"><a href="#3-1-Qt-编译过程" class="headerlink" title="3.1 Qt 编译过程"></a>3.1 Qt 编译过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 目标</span><br><span class="line">  ↑</span><br><span class="line">  +-------------------------+</span><br><span class="line">                            ↑</span><br><span class="line">拓展代码 -&gt; MOC编译器 -&gt; 新CPP代码</span><br></pre></td></tr></table></figure>
<p>通过上述方式，实现 Qt 的某些特性。我们可以发现，当我们写完代码进行编译后，会产生一个 <code>debug</code> 文件夹，此时我们进入该文件夹，会看到一些元对象编译器编译的文件，如 <code>moc_xxxx.cpp</code> 或 <code>moc_xxx.h</code> 等文件。</p>
<h4 id="3-2-MOC-的使用方法"><a href="#3-2-MOC-的使用方法" class="headerlink" title="3.2 MOC 的使用方法"></a>3.2 MOC 的使用方法</h4><ol>
<li>MOC 编译工具由 Qt 框架自动调用</li>
<li>扫描 C++ 头文件，寻找 <code>Q_OBJECT</code> 宏</li>
<li>生成拓展 C++ 代码，再进行预编译</li>
<li>程序员在使用时，需要继承 QObject 类或者是 QObject 子类，并且包含 <code>Q_OBJECT</code> 宏。</li>
</ol>
<h3 id="🍦-4-Qt应用程序开发"><a href="#🍦-4-Qt应用程序开发" class="headerlink" title="🍦 4. Qt应用程序开发"></a>🍦 4. Qt应用程序开发</h3><h4 id="4-1-Qt-Designer-设计师界面使用"><a href="#4-1-Qt-Designer-设计师界面使用" class="headerlink" title="4.1 Qt Designer 设计师界面使用"></a>4.1 Qt Designer 设计师界面使用</h4><p><img src="/./BetterQT/Qt_Designer.png" alt="Qt Designer"><br>① Qt 控件编辑模式<br>② Qt 信号与槽编辑模式<br>③ Qt 伙伴关系编辑模式<br>④ Qt Tab 顺序编辑模式：可以设置按下 Tab 键的高亮顺序</p>
<h4 id="4-2-Qt-核心——信号与槽"><a href="#4-2-Qt-核心——信号与槽" class="headerlink" title="4.2 Qt 核心——信号与槽"></a>4.2 Qt 核心——信号与槽</h4><p><strong>信号与槽的基本概念</strong><br><img src="/./BetterQT/QtSignalsSlots.drawio.png" alt="Qt Signals and Slots"></p>
<ul>
<li>Qt 中的信号和槽是支持多对多的，即一个信号可以对应多个槽，一个槽可以由多个信号触发。</li>
<li>Qt 中的信号无需实现，可以由函数（普通函数或者槽函数）通过 <code>emit</code> 关键字发送信号传递参数。</li>
</ul>
<h5 id="4-2-1-Qt中如何定义信号"><a href="#4-2-1-Qt中如何定义信号" class="headerlink" title="4.2.1 Qt中如何定义信号"></a>4.2.1 Qt中如何定义信号</h5><ol>
<li>继承 <code>QObject</code> 类或其派生类，同时包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>signals</code> 声明函数信号函数，不需要具体实现信号函数</li>
<li>使用 <code>emit</code> 关键字发送信号</li>
</ol>
<h5 id="4-2-2-Qt中如何定义槽函数"><a href="#4-2-2-Qt中如何定义槽函数" class="headerlink" title="4.2.2 Qt中如何定义槽函数"></a>4.2.2 Qt中如何定义槽函数</h5><ol>
<li>必须包含 <code>Q_OBJECT</code> 宏</li>
<li>使用关键字 <code>[public/protected/private] slots</code> 声明函数</li>
<li>需要具体实现声明的槽函数</li>
</ol>
<h5 id="4-2-3-Qt中如何连接信号与槽（三种写法）"><a href="#4-2-3-Qt中如何连接信号与槽（三种写法）" class="headerlink" title="4.2.3 Qt中如何连接信号与槽（三种写法）"></a>4.2.3 Qt中如何连接信号与槽（三种写法）</h5><ol>
<li><code>SIGNAL/SLOT</code> 宏写法：<br><code>QObject::connect(this, SIGNAL(...), this, SLOT(...));</code></li>
<li>函数指针写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, &amp;SlotFunction)</code></li>
<li>lambda 表达式写法：<br><code>QObject::connect(this, &amp;SignalFunction, this, [=]() &#123; qDebug() &lt;&lt; &quot;...&quot;; &#125;)</code></li>
</ol>
<p>三种写法的比较：</p>
<table>
    <tr>
        <td rowspan="2" colspan="3">连接信号与槽</td> 
        <td colspan="2">宏</td>
        <td colspan="2">函数指针</td>
    </tr>
    <tr>
        <td>编译</td>
        <td>运行</td>
        <td>编译</td>
        <td>运行</td>
    </tr>
    <tr>
        <td rowspan="4">参数类型</td>
        <td colspan="2">完全相同</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td rowspan="2">隐式转换</td>
        <td>向上</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td>向下</td>
        <td>√</td>
        <td>×</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">不可以隐式转换</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
        <tr>
        <td rowspan="3">参数个数</td>
        <td colspan="2">信号=槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号>槽</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
    </tr>
    <tr>
        <td colspan="2">信号<槽</td>
        <td>√</td>
        <td>×</td>
        <td>×</td>
        <td>×</td>
    </tr>
</table>

<ul>
<li>这样看来好像宏写法相对于函数指针的写法来说，可能会带来一些问题，因为有时候宏写法通过编译后，在运行阶段可能会出现一些问题；而函数指针写法可以在出现这一问题之前（编译阶段）提前发现这一问题，使得程序无法通过编译。</li>
<li>但是事实上，宏写法还是存在一定的好处，当信号函数出现重载时，使用函数指针时，无法直接进行连接（会产生报错），只能使用类型转换来进行函数指针类型的转换，如<code>static_cast&lt;void QSpinBox::*)(int)&gt;</code>。</li>
<li>一般情况下，推荐使用函数指针方式连接信号与槽。</li>
<li>当面对信号与槽函数有重载的情况时，推荐使用宏方式连接。</li>
<li>对于短小的槽函数的调用且功能不被复用时，推荐使用 lambda 方式连接。</li>
</ul>
<h5 id="4-2-4-其他连接信号与槽的方式"><a href="#4-2-4-其他连接信号与槽的方式" class="headerlink" title="4.2.4 其他连接信号与槽的方式"></a>4.2.4 其他连接信号与槽的方式</h5><ul>
<li>使用 Qt Designer 连接信号与槽<br><img src="/./BetterQT/Designer_Connect.png" alt="Qt Designer Connect"></li>
<li>使用”转到槽”方式</li>
<li>信号与槽自动绑定<br>使用 <code>void on_&lt;对象名&gt;_&lt;信号名&gt;(信号参数);</code> 时可以不使用 <code>connect</code> 进行连接，但是当对象名、信号名或参数发生变化时，连接将会失效，且编译不会有错误提示。</li>
</ul>
<h4 id="4-3-Qt-窗口"><a href="#4-3-Qt-窗口" class="headerlink" title="4.3 Qt 窗口"></a>4.3 Qt 窗口</h4><h5 id="4-3-1-窗口的类型"><a href="#4-3-1-窗口的类型" class="headerlink" title="4.3.1 窗口的类型"></a>4.3.1 窗口的类型</h5><p><strong>顶层窗口、次级窗口（父、子窗口）</strong><br><img src="/./BetterQT/Qt_Windows.png" alt="Qt Windows"><br>在该图中，①可以称为顶层窗口（父窗口），②可以称为次级窗口（子窗口）。窗口中的某些按钮、输入框…等就是控件。</p>
<h5 id="4-3-2-设置窗口标志"><a href="#4-3-2-设置窗口标志" class="headerlink" title="4.3.2 设置窗口标志"></a>4.3.2 设置窗口标志</h5><p>在 Qt 中可以使用 <code>setWindowFlags()</code> 来设置窗口标志</p>
<ol>
<li><p>设置窗口无标题栏<br><img src="/./BetterQT/Window_With_No_Title.png" alt="Window With No Title"></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint);</span><br></pre></td></tr></table></figure></li>
<li><p>设置窗口无边框<br><img src="/./BetterQT/Window_With_No_Frame.png" alt="Window With No Frame"></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure></li>
<li><p>设置窗口置顶</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
<p> 如果按照上述方式依次设置窗口标志，我们会发现当设置第 $3$ 步时前面两步的操作都失效了，这是因为设置窗口置顶时，会覆盖前面的设置。我们可以使用“或”符连接这些标志，解决这一问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::CustomizeWindowHint | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-4-窗口坐标系与几何布局"><a href="#4-4-窗口坐标系与几何布局" class="headerlink" title="4.4 窗口坐标系与几何布局"></a>4.4 窗口坐标系与几何布局</h4><h5 id="4-4-1-窗口的坐标系"><a href="#4-4-1-窗口的坐标系" class="headerlink" title="4.4.1 窗口的坐标系"></a>4.4.1 窗口的坐标系</h5><img src="./BetterQT/CoordinateSystem.png" alt="Window Coordinate System" style="zoom:50%;" />

<h5 id="4-4-2-窗口的几何布局"><a href="#4-4-2-窗口的几何布局" class="headerlink" title="4.4.2 窗口的几何布局"></a>4.4.2 窗口的几何布局</h5><img src="./BetterQT/WindowLayout.png" alt="Window Layout" style="zoom:50%;" />

<h4 id="4-5-添加图标"><a href="#4-5-添加图标" class="headerlink" title="4.5 添加图标"></a>4.5 添加图标</h4><h5 id="4-5-1-为窗口添加图标"><a href="#4-5-1-为窗口添加图标" class="headerlink" title="4.5.1 为窗口添加图标"></a>4.5.1 为窗口添加图标</h5><ol>
<li>准备图标文件</li>
<li>调用 <code>setWindowIcon</code> 方法</li>
</ol>
<h5 id="4-5-2-为应用程序添加图标（一般使用这种方式）"><a href="#4-5-2-为应用程序添加图标（一般使用这种方式）" class="headerlink" title="4.5.2 为应用程序添加图标（一般使用这种方式）"></a>4.5.2 为应用程序添加图标（一般使用这种方式）</h5><ol>
<li>准备图标文件 <code>logo.ico</code></li>
<li>修改 pro 工程文件 <code>RC_ICONS = &lt;Path&gt;</code></li>
<li>通过此种方式修改图标，可执行程序 <code>.exe</code> 的图标会修改，且不需要额外单独设置窗口图标。</li>
</ol>
<h4 id="4-6-部署产品的三种方式"><a href="#4-6-部署产品的三种方式" class="headerlink" title="4.6 部署产品的三种方式"></a>4.6 部署产品的三种方式</h4><ol>
<li><p>手动部署（不常用，比较繁琐）<br>进入 <code>.exe</code> 文件所在的文件夹（<code>debug</code>目录），双击运行 <code>.exe</code> 文件，会提示缺少的文件（包括<code>dll</code>动态库、<code>plugin</code>插件等），然后找到对应的文件移动到 <code>.exe</code> 文件的同级目录下即可，如下：<br><img src="/./BetterQT/EXE_File_Dictionary.png" alt="EXE File Dictionary"><br>如果配置了环境变量则大概率不会出现报错提示缺少库的问题，那么这种方式就会失效。</p>
</li>
<li><p>使用 windeployqt 部署<br>① 查找 <code>windeployqt.exe</code> 程序<br>② 将 <code>windeployqt.exe</code> 加入环境变量<br>③ 再命令行界面执行命令 <code>windeployqt.exe &lt;exe_file_dir&gt;</code> 完成操作<br><img src="/./BetterQT/WIN_DEPLOY_QT_1.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_2.png" alt="WIN DEPLOY QT"><br><img src="/./BetterQT/WIN_DEPLOY_QT_3.png" alt="WIN DEPLOY QT"></p>
</li>
<li><p>使用creator 部署<br>① 项目导航窗口→运行→部署→添加自定义部署<br><img src="/./BetterQT/CREATOR_DEPLOY_1.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_2.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_3.png" alt="CREATOR DEPLOY"><br>② 输入 <code>windeployqt.exe</code> 程序及对应的命令行参数<br><img src="/./BetterQT/CREATOR_DEPLOY_4.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_5.png" alt="CREATOR DEPLOY"><br>③ 执行部署命令<br><img src="/./BetterQT/CREATOR_DEPLOY_6.png" alt="CREATOR DEPLOY"><br><img src="/./BetterQT/CREATOR_DEPLOY_OK.png" alt="CREATOR DEPLOY OK"></p>
</li>
</ol>
<h3 id="🍦-5-Qt-常用控件"><a href="#🍦-5-Qt-常用控件" class="headerlink" title="🍦 5. Qt 常用控件"></a>🍦 5. Qt 常用控件</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/index.html">Qt 6.7</a></p>
<p>一个不错的 Qt 中文文档：<a target="_blank" rel="noopener" href="http://qt5.digitser.top/5.15/zh-CN/">Qt 中文文档 5.15.1 版本</a></p>
<h4 id="5-1-QLabel-标签控件"><a href="#5-1-QLabel-标签控件" class="headerlink" title="5.1 QLabel 标签控件"></a>5.1 <code>QLabel</code> 标签控件</h4><p><code>QLabel</code> 的本质其实就是显示数据。其可以显示文本数据、图片数据。</p>
<img src="./BetterQT/QLabelShowData.png" style="zoom: 20%;" >

<p>了解了这些我们再来看 <code>QLabel</code> 的一些常用属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#text-prop"><code>text</code></a></strong><code>: QString</code></td>
<td align="left">文本内容：纯文本</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#openExternalLinks-prop"><code>openExternalLinks</code></a></strong><code>:bool</code></td>
<td align="left">文本内容：超链接</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#textFormat-prop"><code>textFormat</code></a></strong> <code>: Qt::TextFormat</code></td>
<td align="left">文本内容：不同类型的文本，如富文本等</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#alignment-prop"><code>alignment</code></a></strong><code>: Qt::Alignment</code></td>
<td align="left">文本格式：对齐方式</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#indent-prop"><code>indent</code></a></strong><code>: int</code></td>
<td align="left">文本格式：缩进</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#margin-prop"><code>margin</code></a></strong><code> : int</code></td>
<td align="left">文本格式：边距</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#wordWrap-prop"><code>wordWrap</code></a></strong><code>: bool</code></td>
<td align="left">文本格式：换行</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#pixmap-prop"><code>pixmap</code></a></strong><code>: QPixmap</code></td>
<td align="left">图片内容：显示图片</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#hasSelectedText-prop"><code>hasSelectedText</code></a></strong><code>: const bool</code></td>
<td align="left">方法：文本是否被选中</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#scaledContents-prop"><code>scaledContents</code></a></strong><code>: bool</code></td>
<td align="left">方法：是否缩放内容</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#selectedText-prop"><code>selectedText</code></a></strong><code>: const QString</code></td>
<td align="left">方法：获取选中的内容</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlabel.html#textInteractionFlags-prop"><code>textInteractionFlags</code></a></strong><code>: Qt::TextInteractionFlags</code></td>
<td align="left">方法：指定标签应如何与用户输入交互，若它显示文本</td>
</tr>
</tbody></table>
<h4 id="5-2-QLineEdit-单行输入框控件"><a href="#5-2-QLineEdit-单行输入框控件" class="headerlink" title="5.2 QLineEdit 单行输入框控件"></a>5.2 <code>QLineEdit</code> 单行输入框控件</h4><p><code>QLineEdit</code> 的本质是用于不确定的输入，如用户的手机号、用户的密码。这样就给了用户一定的自由，但是我们同时需要制定一系列的规则，以校验用户的输入。例如用户输入手机号，我们需要制定一个长度为 <code>11</code> 位的规则，并且输入字符中不包含字母等，以方便开发人员进行校验。当然我们也可以配合一些其他操作来优化用户体验，如：清空（如：快速清空内容）、提示（如：提示输入格式）、记忆（如：记忆之前的输入）等。</p>
<img src="./BetterQT/QLineEditGetData.png" style="zoom: 20%;" >

<p>了解了这些我们可以看一下 <code>QLineEdit</code> 的一些常用属性（不完全，具体还是需要看文档）：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qlineedit.html#clearButtonEnabled-prop"><code>clearButtonEnabled</code></a></strong><code>: bool</code></td>
<td>清空文本框内容<br />该属性保存行编辑不为空时是否显示清除按钮。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlineedit.html#placeholderText-prop"><code>placeholderText</code></a></strong><code>: QString</code></td>
<td>占位符文本，可以用于提示输入内容。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qlineedit.html#inputMask-prop"><code>inputMask</code></a></strong><code>: QString</code></td>
<td>掩码</td>
</tr>
</tbody></table>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarMyself.jpg" alt="NilEra"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">NilEra</p><p class="is-size-6 is-block">C/C++ Developer!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jinan Shandong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">32</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/NilEra-K" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/NilEra-K" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://nano.chemtian.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Thymol Blue</span></span><span class="level-right"><span class="level-item tag">nano.chemtian.top</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CppDev/"><span class="level-start"><span class="level-item">CppDev</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/Gaming/"><span class="level-start"><span class="level-item">Gaming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/QT6/"><span class="level-start"><span class="level-item">QT6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">多线程编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="level-start"><span class="level-item">软件源</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">大数据技术</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/"><span class="level-start"><span class="level-item">ECharts</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/"><span class="level-start"><span class="level-item">HBase</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"><span class="level-start"><span class="level-item">数据可视化</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Axure-RP-9/"><span class="level-start"><span class="level-item">Axure RP 9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构/算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/"><span class="level-start"><span class="level-item">哈希(Hash)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/"><span class="level-start"><span class="level-item">栈(Stack)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/"><span class="level-start"><span class="level-item">树(Tree)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"><span class="level-start"><span class="level-item">PyTorch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/"><span class="level-start"><span class="level-item">闲聊</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/%E8%AE%A1%E5%88%92/"><span class="level-start"><span class="level-item">计划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-01T07:29:16.000Z">2024-08-01</time></p><p class="title"><a href="/2024/08/01/LLM-General-Education/">LLM_General_Education</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-30T14:55:47.000Z">2024-07-30</time></p><p class="title"><a href="/2024/07/30/MyBatisPlus/">MyBatisPlus</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-30T14:36:18.000Z">2024-07-30</time></p><p class="title"><a href="/2024/07/30/SpringCloud/">SpringCloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-29T07:32:17.000Z">2024-07-29</time></p><p class="title"><a href="/2024/07/29/Cpp-Muti-Threaded/">Cpp_Muti_Threaded</a></p><p class="categories"><a href="/categories/CppDev/">CppDev</a> / <a href="/categories/CppDev/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-29T07:29:04.000Z">2024-07-29</time></p><p class="title"><a href="/2024/07/29/Cpp-Network-Programming/">Cpp_Network_Programming</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">八月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Axure-RP-9/"><span class="tag">Axure RP 9</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CppDev/"><span class="tag">CppDev</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECharts/"><span class="tag">ECharts</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EasyX/"><span class="tag">EasyX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GameDev/"><span class="tag">GameDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaDev/"><span class="tag">JavaDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kaggle/"><span class="tag">Kaggle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis-Plus/"><span class="tag">MyBatis-Plus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QT6/"><span class="tag">QT6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/R/"><span class="tag">R</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tomcat/"><span class="tag">Tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"><span class="tag">多线程编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="tag">大数据技术</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E5%88%92/"><span class="tag">计划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="tag">软件源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%B2%E8%81%8A/"><span class="tag">闲聊</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE/"><span class="tag">项目</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a><p class="is-size-7"><span>&copy; 2024 NilEra</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024 前方⚡高能</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdnjs.loli.net/ajax/libs/algoliasearch/4.0.3/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdnjs.loli.net/ajax/libs/instantsearch.js/4.3.1/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"2TB5ZZYPCO","apiKey":"00a43f1d62ca7b24c8b78d5f0223c065","indexName":"dev_nilera_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>