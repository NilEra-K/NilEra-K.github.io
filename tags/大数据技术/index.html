<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>标签: 大数据技术 - Hello, NilEra :-)</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hello, NilEra :-)"><meta name="msapplication-TileImage" content="/img/StarLogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hello, NilEra :-)"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="努力做自己喜欢的事"><meta property="og:type" content="blog"><meta property="og:title" content="Hello, NilEra :-)"><meta property="og:url" content="https://hello-nilera.com/"><meta property="og:site_name" content="Hello, NilEra :-)"><meta property="og:description" content="努力做自己喜欢的事"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hello-nilera.com/img/og_image.png"><meta property="article:author" content="NilEra"><meta property="article:tag" content="Hello NilEra"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hello-nilera.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hello-nilera.com"},"headline":"Hello, NilEra :-)","image":["https://hello-nilera.com/img/og_image.png"],"author":{"@type":"Person","name":"NilEra"},"publisher":{"@type":"Organization","name":"Hello, NilEra :-)","logo":{"@type":"ImageObject","url":"https://hello-nilera.com/img/StarLogo.svg"}},"description":"努力做自己喜欢的事"}</script><link rel="icon" href="/img/StarLogo.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?249654dcf9a3bf70708fdfc6e2b1ec2b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="F6BD78C6BD0096D2218CF88334111125"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/me">我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">大数据技术</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-12T07:13:57.000Z" title="2024/6/12 15:13:57">2024-06-12</time>发表</span><span class="level-item"><time dateTime="2024-06-17T08:13:32.360Z" title="2024/6/17 16:13:32">2024-06-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/">Spark</a></span><span class="level-item">32 分钟读完 (大约4742个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/12/SparkQuickIN/">SparkQuickIN</a></p><div class="content"><h2 id="快速入门-Spark"><a href="#快速入门-Spark" class="headerlink" title="快速入门 Spark"></a>快速入门 Spark</h2><p>[TOC]</p>
<h3 id="⛳︎-1-开始-Spark"><a href="#⛳︎-1-开始-Spark" class="headerlink" title="⛳︎ 1. 开始 Spark"></a>⛳︎ 1. 开始 Spark</h3><p><strong>Spark官网</strong>：<a target="_blank" rel="noopener" href="https://spark.apache.org/">Apache Spark™ - Unified Engine for large-scale data analytics</a></p>
<h4 id="1-1-什么是Spark"><a href="#1-1-什么是Spark" class="headerlink" title="1.1 什么是Spark"></a>1.1 什么是Spark</h4><p>Spark官网的解释：Apache Spark™ is a unified analytics engine for large-scale data processing.</p>
<p><strong>Apache Spark</strong> 是专为大规模数据处理而设计的快速通用的计算引擎。<code>Spark</code>是加州大学伯克利分校的 <em><strong>AMP实验室</strong></em> 所开源的类 <code>Hadoop MapReduce</code> 的通用并行计算框架，<code>Spark</code> 拥有 <code>Hadoop MapReduce</code> 所具有的优点，但不同于 <code>MapReduce</code> 的是：<code>Job</code> 中间输出结果可以缓存在内存中，从而不再需要读写 <code>HDFS</code>，减少磁盘数据交互，因此 <code>spark</code> 能更好地适用于数据挖掘与机器学习等需要迭代的算法。</p>
<p><code>Spark</code>是 <code>Scala</code> 编写，方便快速编程。</p>
<p><strong>其特点是</strong>：高速、使用简单、通用、可以在多处运行。</p>
<h4 id="1-2-总体技术栈讲解"><a href="#1-2-总体技术栈讲解" class="headerlink" title="1.2 总体技术栈讲解"></a>1.2 总体技术栈讲解</h4><img src="./SparkQuickIN/TechStack.png" style="zoom: 33%;" />

<p><code>Spark</code> 提供了 <code>Sparkcore RDD</code>、<code>Spark SQL</code>、<code>Spark Streaming</code>、<code>Spark MLlib</code>、<code>Spark GraphX</code>等技术组件，可以一站式的完成大数据领域的离线批处理、交互式查询、流式计算、机器学习、图计算等常见的任务。这就是<code>Spark</code>一站式开发的特点。</p>
<h4 id="1-3-Spark-和-MapReduce-的区别"><a href="#1-3-Spark-和-MapReduce-的区别" class="headerlink" title="1.3 Spark 和 MapReduce 的区别"></a>1.3 <code>Spark</code> 和 <code>MapReduce</code> 的区别</h4><h5 id="1-3-1-MapReduce-的原理"><a href="#1-3-1-MapReduce-的原理" class="headerlink" title="1.3.1 MapReduce 的原理"></a>1.3.1 MapReduce 的原理</h5><p><code>MapReduce</code> 在运算时需要多次进行磁盘 I&#x2F;O。下面是一个简单的 <code>MapReduce</code> 过程：</p>
<p>视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TB4y1i7kk/">https://www.bilibili.com/video/BV1TB4y1i7kk/</a></p>
<p>在这个视频中，可以看出<code>MapReduce</code> 过程中需要多次磁盘 I&#x2F;O，落地到<code>HDFS</code>上。</p>
<h5 id="1-3-2-Spark-是如何做的"><a href="#1-3-2-Spark-是如何做的" class="headerlink" title="1.3.2 Spark 是如何做的"></a>1.3.2 Spark 是如何做的</h5><img src="./SparkQuickIN/MapReduce_VS_Spark.png" style="zoom: 40%;" >

<p>可以看到，<code>MapReduce</code> 的多个 <code>Job</code> 之间相互独立，每个 <code>Job</code> 完成后的数据都需要存储到文件系统中。每个 <code>Job</code> 中也可能会存在大量的磁盘 I&#x2F;O ，这样会使得 <code>MapReduce</code> 的速度很慢。相比于 <code>MapReduce</code>，<code>Spark</code>使用了 <code>DAG</code> 有向无环图。使多个任务串联起来，将结果存储在内存中（当然内存不够还是要将数据缓存在磁盘中）直接进行运算，避免了大量的磁盘I&#x2F;O。</p>
<h5 id="1-3-3-Spark-和-MapReduce-的一些联系"><a href="#1-3-3-Spark-和-MapReduce-的一些联系" class="headerlink" title="1.3.3 Spark 和 MapReduce 的一些联系"></a>1.3.3 <code>Spark</code> 和 <code>MapReduce</code> 的一些联系</h5><p><code>Spark</code> 和 <code>MapReduce</code> 都是分布式计算框架，<code>Spark</code> 计算中间结果基于内存缓存，<code>MapReduce</code> 基于<code>HDFS</code>存储。也正因此，<code>Spark</code>处理数据的能力一般是 <code>MapReduce</code>的三到五倍以上，<code>Spark</code> 中除了基于内存计算这一个计算快的原因，还有<code>DAG(DAG Schedule)</code>有向无环图来切分任务的执行先后顺序。</p>
<h4 id="1-4-Spark-API"><a href="#1-4-Spark-API" class="headerlink" title="1.4 Spark API"></a>1.4 Spark API</h4><p>Spark API 有多种语言支持，分别包括：<code>Scala</code>、<code>Java</code>、<code>Python</code>、<code>R</code>、<code>SQL</code> 等。</p>
<h4 id="1-5-Spark-的运行模式"><a href="#1-5-Spark-的运行模式" class="headerlink" title="1.5 Spark 的运行模式"></a>1.5 Spark 的运行模式</h4><ul>
<li><code>Local</code>：多用于本地测试，如在：<code>Eclipse</code>、<code>IDEA</code> 中编写测试程序等。</li>
<li><code>Standalone</code>：<code>Spark</code> 自带的资源调度框架，它支持完全分布式。<code>Standalone</code>模式也叫作<strong>独立模式</strong>，<strong>其自带完整的服务，可单独部署到一个集群中，无序依赖任何其他资源管理系统。</strong> 从一定程度上来说，该模式是 <code>Local</code> 模式和 <code>Yarn</code> 模式的基础。</li>
<li><code>Yarn</code>： Hadoop 生态圈里的一种资源调度框架，<code>Spark</code>也是可以基于 <code>Yarn</code> 来计算的。 若要使用 <code>Yarn</code> 来进行资源调度，必须实现<code>ApplicationMaster</code> 接口，<code>Spark</code> 实现了这个接口，所以可以基于 <code>Yarn</code> 来进行资源调度。</li>
<li><code>Mesos</code>：也是一种资源调度框架（了解即可）。</li>
</ul>
<h3 id="🥑-2-SparkCore"><a href="#🥑-2-SparkCore" class="headerlink" title="🥑 2. SparkCore"></a>🥑 2. SparkCore</h3><h4 id="2-1-RDD"><a href="#2-1-RDD" class="headerlink" title="2.1 RDD"></a>2.1 RDD</h4><h5 id="2-1-1-RDD-的概念"><a href="#2-1-1-RDD-的概念" class="headerlink" title="2.1.1 RDD 的概念"></a>2.1.1 RDD 的概念</h5><p><code>RDD(Resilient Distribute Dataset)</code>：弹性分布式数据集。</p>
<p><code>RDD</code> → <code>算子</code> → <code>Other RDD</code>，<code>RDD</code> 经过算子的运算会变成其他的 <code>RDD</code>。</p>
<p>（重点）<code>RDD</code>的特点：① 分区的；② 并行操作的；③ 不可变的。</p>
<h5 id="2-1-2-RDD-的五大特性"><a href="#2-1-2-RDD-的五大特性" class="headerlink" title="2.1.2 RDD 的五大特性"></a>2.1.2 RDD 的五大特性</h5><ol>
<li>每个<code>RDD</code> 由一系列的 <code>Partition</code> 组成。</li>
<li>函数是作用在每一个 <code>Partition (Split)</code> 上的。</li>
<li><code>RDD</code> 中有一系列的依赖关系，或者说每个<code>RDD</code>都会依赖其他一系列的<code>RDD</code>。</li>
<li>分区器是作用在 <code>&lt;K, V&gt;</code> 格式的 <code>RDD</code> 上，即：<code>&lt;K, V&gt;</code> 的 <code>RDD</code> 可以通过 <code>Partition</code> 进行自定义分区。</li>
<li><code>RDD</code>提供一系列的最佳计算位置。数据在哪里，计算就在哪里，移动数据不如移动计算。</li>
</ol>
<h5 id="2-1-3-RDD-理解图"><a href="#2-1-3-RDD-理解图" class="headerlink" title="2.1.3 RDD 理解图"></a>2.1.3 RDD 理解图</h5><img src="./SparkQuickIN/SparkRDD.png" style="zoom:40%;" >



<p><code>Spark</code> 中读取文件是使用 <code>SparkContext</code> 对象调用 <code>textFile</code> 方法，实际上底层和 <code>MapReduce</code> 读取 <code>HDFS</code> 文件的方式是相同的，读取之前先要进行 <code>split</code> 切片。默认情况下 <code>Split</code> 的大小和 <code>Block</code> 块的大小相同。</p>
<p>一些问题：</p>
<ol>
<li><p><code>RDD</code>的分布式体现在那些方面？</p>
<p><code>RDD</code> 由一系列的 <code>Partition</code> 构成，并且 <code>Partition</code> 是分布在不同的节点上的。这就体现了 <code>RDD</code> 的分布式。</p>
</li>
<li><p>哪里体现了 <code>RDD</code> 的弹性？</p>
<p><code>RDD</code> 由一系列的 <code>Partition</code> 组成，其大小和数量都是可以改变的。默认情况下，<code>Partition</code> 的个数和 <code>Block</code> 块的个数相同。</p>
</li>
<li><p>哪里体现了 <code>RDD</code> 的容错？</p>
<p><code>RDD</code> 之间存在一系列的依赖关系，<code>子RDD</code> 可以找到对应的<code>父RDD</code> ，然后通过一系列计算得到得出响应的结果，这就是容错的体现。</p>
<p><code>RDD</code> 提供计算最佳位置，体现了数据本地化，体现了大数据中<strong>”移动数据不如移动计算“</strong>的理念。</p>
</li>
</ol>
<p>一些注意事项：</p>
<ol>
<li><code>textFile</code> 方法底层封装的是 <code>MapReduce</code> 读取文件的方式，读取文件之前先进行 <code>Split</code> 切片，默认 <code>Split</code>  大小是一个 <code>Block</code> 的大小。</li>
<li><code>RDD</code> 实际上不存储数据，但是为了方便理解，可以理解为存储数据。</li>
<li>什么是 <code>&lt;K, V&gt;</code> 格式的 <code>RDD</code>，如果 <code>RDD</code> 里面存储的数据都是二元组对象，那么这个 <code>RDD</code> 我们就叫做 <code>&lt;K, V&gt;</code> 格式的 <code>RDD</code>。</li>
</ol>
<h5 id="2-1-4-SparkRDD-编程模型"><a href="#2-1-4-SparkRDD-编程模型" class="headerlink" title="2.1.4 SparkRDD 编程模型"></a>2.1.4 SparkRDD 编程模型</h5><ol>
<li><p>创建 <code>SparkContext</code> 对象</p>
</li>
<li><p>创建 <code>RDD</code></p>
</li>
<li><p>计算 <code>RDD</code></p>
</li>
<li><p>输出结果（如控制台打印测试，存储等）</p>
</li>
<li><p>关闭 <code>SparkContext</code></p>
</li>
</ol>
<h5 id="2-1-5-WordCount-案例"><a href="#2-1-5-WordCount-案例" class="headerlink" title="2.1.5 WordCount 案例"></a>2.1.5 <code>WordCount</code> 案例</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 第一步: 创建 SparkContext 对象</span></span><br><span class="line">        <span class="comment">// 对于每个 Spark 程序来说, 最重要的就是两个对象: SparkConf 和 SparkContext</span></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="type">SparkConf</span>()</span><br><span class="line">        conf.setAppName(<span class="string">&quot;WordCount&quot;</span>).setMaster(<span class="string">&quot;Local&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sparkContext = <span class="type">SparkContext</span>(conf)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 RDD</span></span><br><span class="line">        <span class="keyword">val</span> line: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;files/order.csv&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 RDD</span></span><br><span class="line">        <span class="keyword">val</span> word: <span class="type">RDD</span>[<span class="type">String</span>] = sc.flatMap(x =&gt; x.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> pair: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = word.map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// val result: RDD[(String, Int)] = pair.reduceByKey((x, y) =&gt; &#123;x + y&#125;)</span></span><br><span class="line">        <span class="keyword">val</span> result: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = pair.reduceByKey((x, y) =&gt; &#123;</span><br><span class="line">            println(x + <span class="string">&quot;:&quot;</span> + y)</span><br><span class="line">            x + y</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 RDD</span></span><br><span class="line">        result.foreach(println)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭 SparkContext</span></span><br><span class="line">        sparkContext.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Spark-任务执行原理"><a href="#2-2-Spark-任务执行原理" class="headerlink" title="2.2 Spark 任务执行原理"></a>2.2 Spark 任务执行原理</h4><p>从下图中，我们可以看到 <strong>Spark</strong> 的主要角色：</p>
<img src="./SparkQuickIN/SparkExecutor.png" alt="SparkExecutor" style="zoom:33%;" />

<p>一些名词的解释：</p>
<ul>
<li><code>Master Node</code> 主节点</li>
<li><code>Worker Node</code> 从节点</li>
<li><code>Driver</code> 驱动程序</li>
<li><code>Executor</code> 执行节点</li>
<li><code>Cluster Manager</code> 集群管理者</li>
</ul>
<h5 id="2-2-1-Spark-架构的类比"><a href="#2-2-1-Spark-架构的类比" class="headerlink" title="2.2.1 Spark 架构的类比"></a>2.2.1 Spark 架构的类比</h5><p>我们可以简单的将这个架构和 <strong>YARN</strong> 对比一下：<code>Master</code> 就相当于 <code>YARN</code> 中的 <code>ResourceManager</code>，<code>Worker</code> 就相当于 <code>YARN</code> 中的 <code>NodeManager</code>，<code>Driver</code> 相当于 <code>YARN</code> 中的 <code>Application</code>。</p>
<h5 id="2-2-2-Spark-执行原理详细说明"><a href="#2-2-2-Spark-执行原理详细说明" class="headerlink" title="2.2.2 Spark 执行原理详细说明"></a>2.2.2 Spark 执行原理详细说明</h5><ol>
<li><p><code>Master</code> 和 <code>Worker</code> 节点</p>
<p>搭建 <strong>Spark</strong> 集群的时候我们就已经设置好了 <code>Master</code> 节点和 <code>Worker</code> 节点，一个集群有多个<code>Master</code>节点和多个<code>Worker</code>节点。</p>
<ul>
<li><p><code>Master</code> 节点常驻 <code>Master</code> 守护进程，负责管理 <code>Worker</code> 节点，我们从 <code>Master</code> 节点提交应用。</p>
</li>
<li><p><code>Worker</code> 节点常驻 <code>Worker</code> 守护进程，与 <code>Master</code> 节点通信，并且管理 <code>Executor</code> 进程。</p>
</li>
</ul>
<p>一台机器可以同时作为 <code>Master</code> 和 <code>Worker</code> 节点（e.g. 有四台机器，可以选择一台设置为 <code>Master</code>节点，然后剩下三台设为 <code>Worker</code>节点，也可以把四台都设为 <code>Worker</code> 节点，这种情况下，有一个机器既是 <code>Master</code> 节点又是 <code>Worker</code> 节点）。</p>
<p>一个 <code>Spark</code> 应用程序分为一个驱动程序 <code>Driver</code> 和多个执行程序 <code>Executors</code> 两种。</p>
</li>
<li><p><code>Driver</code> 和 <code>Executor</code> 进程<br><code>Driver</code> 进程就是应用的 <code>main()</code> 函数并且构建 <code>SparkContext</code> 对象，当我们提交了应用之后，便会启动一个对应的 <code>Driver</code> 进程，<code>Driver</code> 本身会根据我们设置的参数占有一定的资源（主要指 <em><strong>CPU Core</strong></em> 和 <em><strong>Memory</strong></em>）。</p>
<p>根据部署模式的不同，<code>Driver</code> 可以运行在 <code>Master</code> 上，也可以运行 <code>Worker</code>上，<code>Driver</code> 与集群节点之间有频繁的通信。上图展示了 <code>Driver</code> 在 <code>Master</code> 上的部署的情况。</p>
<ul>
<li><p>如上图所示，<code>Driver</code>首先会向**集群管理者<code>Cluster Manager</code>**，如<code>Standalone</code>、<code>Yarn</code>、<code>Mesos</code> 申请 <strong>Spark</strong> 应用所需的资源，也就是<code>Executor</code>，然后集群管理者会根据 <strong>Spark</strong> 应用所设置的参数在各个 <code>Worker</code> 上分配一定数量的 <code>Executor</code>，每个 <code>Executor</code> 都占用一定数量的 <code>CPU</code>和 <code>Memory</code>。</p>
</li>
<li><p>在申请到应用所需的资源以后，<code>Driver</code> 就开始调度和执行我们编写的应用代码了。<code>Driver</code> 进程会将我们编写的 <code>Spark</code> 应用代码拆分成多个 <code>Stage</code>，每个<code>Stage</code> 执行一部分代码片段，并为每个 <code>Stage</code> 创建一批 <code>Tasks</code>，然后将这些 <code>Tasks</code>分配到各个 <code>Executor</code>中执行。这一步即 <code>Driver ---Task--&gt; Worker</code>。</p>
</li>
<li><p><code>Executor</code> 进程宿主在 <code>worker</code> 节点上，一个 <code>Worker</code>可以有多个 <code>Executor</code>。每个 <code>Executor</code> 持有一个线程池，每个线程可以执行一个 <code>Task</code>，<code>Executor</code> 执行完 <code>Task</code> 以后将结果返回给 <code>Driver</code>，每个 <code>Executor</code> 执行的 <code>Task</code> 都属于同一个应用。此外 <code>Executor</code> 还有一个功能就是为应用程序中要求缓存的 <code>RDD</code> 提供内存式存储，<code>RDD</code> 是直接缓存在 <code>Executor</code>进程内的，因此任务可以在运行时充分利用缓存数据加速运算。这一步即 <code>Worker ---Result--&gt; Driver</code>。</p>
</li>
<li><p><code>Driver</code> 负责<strong>任务 <code>Tasks</code> 的分发</strong>和<strong>结果<code>Results</code>的回收</strong>，即任务的调度。如果 <code>Task</code> 的计算结果非常大就不要回收了，会造成<code>OOM</code>（我们在执行程序时可以通过参数指定 <code>Driver</code> 的内存大小，如 <code>1G</code>，如果一个 <code>Worker</code> 的结果是 <code>510M</code>，那么两个接节点上的结果就会超过 <code>1G</code>，导致 <code>OOM</code>）。</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-RDD-算子"><a href="#2-2-RDD-算子" class="headerlink" title="2.2 RDD 算子"></a>2.2 RDD 算子</h4><p><strong>RDD有两种操作算子：</strong>分别为<strong>转换算子(Transformation)</strong> 和 **行动算子(Action)**。算子其实就是函数，只不过在 <strong>Scala</strong> 中称为算子。</p>
<p>下面表格列出了部分 <strong>RDD 算子</strong>，完整内容可以查看 <em><strong>[SparkRDD](<a target="_blank" rel="noopener" href="https://spark.apache.org/docs/3.0.1/rdd-programming-guide.html">RDD Programming Guide - Spark 3.0.1 Documentation (apache.org)</a>)</strong></em> 文档。</p>
<img src="D:\Blog\source\_posts\SparkQuickIN\DocLocation.jpg"  />

<table>
    <tr>
        <th>算子类型</th>
        <th>算子方法</th>
        <th>算子转换</th>
    </tr>
    <tr>
        <td rowspan="14">Transformations</td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">map(f: T=>U)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[U]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">filter(f: T=>Bool)</code>
        </td>
         <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[T]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">flatMap(f: T=>Seq[U])</code> 
        </td>
         <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[U]</code> 
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">sample(fraction: Float)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => RDD[T](Deterministic sampling)</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">groupByKey()</code>
        </td>
          <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, Seq[V])]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">reduceByKey(f: (V, V)=>V)</code>
        </td>
         <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, V)]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">union()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[T], RDD[T]) => RDD[T]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">join()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[(K, V)], RDD[(K, W)]) => RDD[(K, (V, W))]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">cogroup()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[(K, V)], RDD[(K, W)]) => RDD([K, (Seq[V], Seq[W])])</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">crossProduct()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">(RDD[T], RDD[U]) => (RDD[(T, U)])</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">mapValues(f: V=>W)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, W)](Preserves Partitioning)</code>
        </td>        
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">sort(c: Comparator[K])</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, V)]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">partitionBy(p: Partitioner[K])</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => RDD[(K, V)]</code>
        </td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td rowspan="7">Actions</td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">count()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => Long</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">collect()</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => Seq[T]</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">reduce(f: (T, T)=>T)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[T] => T</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">lookup(k: K)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">RDD[(K, V)] => Seq[V](On hash/range partitioned RDDs)</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">save(path: String)</code>
        </td>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">Outputs RDD to a Storage System, e.g. HDFS</code>
        </td>
    </tr>
    <tr>
        <td>
            <code style="font-family: Consolas; font-size: 14px;">foreach(func)</code>
        </td>
        <td>-</td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
</table>

<h5 id="2-2-1-Transformation-转换算子"><a href="#2-2-1-Transformation-转换算子" class="headerlink" title="2.2.1 Transformation 转换算子"></a>2.2.1 Transformation 转换算子</h5><p>点击快速跳转到转换算子列表：<a target="_blank" rel="noopener" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#transformations">Transformations</a></p>
<p><strong>Transformation 转换算子</strong>有延迟执行的特点，具有**懒加载(Lazy)**的特性。</p>
<p>下面列出常用的行动算子及用法：</p>
<ul>
<li><code>map(func)</code> 返回一个新的分布式数据集，由每个原元素经过<code>func</code>函数转换后组成。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;MapDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list, <span class="number">5</span>)</span><br><span class="line">        listRDD.foreach(println)</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">val</span> retRDD = listRDD.map(num =&gt; num * <span class="number">7</span>)</span><br><span class="line">        retRDD.foreach(num =&gt; println(num))</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mapPartition(func)</code> 将函数用在每个<code>RDD</code>的分区上</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MapPartitionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;MapPartitionDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list, <span class="number">3</span>)	<span class="comment">// 设置三个分区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对比 map 和 mapPartition 的区别</span></span><br><span class="line">        listRDD.map( x =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;Map 执行一次&quot;</span>)</span><br><span class="line">            x + <span class="number">1</span></span><br><span class="line">        &#125;).foreach(println)</span><br><span class="line"></span><br><span class="line">        println()</span><br><span class="line"></span><br><span class="line">        listRDD.mapPartitions( x =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;MapPartition 执行一次&quot;</span>)</span><br><span class="line">            x.map(x =&gt; &#123;println(<span class="string">&quot;mapPartition 里的map&quot;</span>); x + <span class="number">1</span>&#125;)  <span class="comment">// 这个 map 不是 RDD 里的 map, 而是 Iterator 中的 map</span></span><br><span class="line">        &#125;).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filter(func)</code>返回一个新的数据集，由经过<code>func</code>函数后返回值为<code>true</code>的元素组成。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FilterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;FilterDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list)</span><br><span class="line">        <span class="keyword">val</span> retRDD = listRDD.filter(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        retRDD.foreach(println)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flatMap(func)</code>类似于<code>map</code>，但是每一个输入元素，会被映射为 <code>0</code> 到多个输出元素（因此，<code>func</code> 函数的返回值是一个 <code>Seq</code>，而不是单一元素）。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FlatMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;FlatMapDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="string">&quot;hello you&quot;</span>, <span class="string">&quot;hello he&quot;</span>, <span class="string">&quot;hello me&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list)</span><br><span class="line">        <span class="keyword">val</span> wordsRDD = listRDD.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        wordsRDD.foreach(println)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sample(withReplacement, frac, seed)</code>根据给定的随机种子 <code>seed</code>，随机抽样出数量为 <code>frac</code> 的数据。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>union(otherDataset)</code>返回一个新的数据集，由原数据集和参数联合而成。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>groupByKey([numTasks])</code>在一个由 <code>&lt;K, V&gt;</code> 对组成的数据集上调用，返回一个 <code>&lt;K, Seq[V]&gt;</code> 对的数据集。注意：默认情况下，使用 <code>8</code> 个并行任务进行分组，你可以传入 <code>numTask</code> 可选参数，根据数据量设置不同数目的 <code>Task</code>。使用该算子可以将相同<code>Key</code>的元素聚集到一起，最终把所有相同<code>Key</code>的元素合并成一个元素，该元素的<code>Key</code>不变，<code>Value</code>则聚集到一个集合中。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>reduceByKey(func, [numTasks])</code>在一个<code>&lt;K, V&gt;</code>对的数据集上使用，返回一个<code>&lt;K, V&gt;</code>对的数据集，<code>key</code>相同的值，都被使用指定的<code>reduce</code>函数聚合到一起。和 <code>groupByKey</code>类似，任务的个数是可以通过第二个可选参数来配置的。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>join(otherDataset, [numTasks])</code>在类型为<code>&lt;K, V&gt;</code>和<code>&lt;K, W&gt;</code>类型的数据集上调用，返回一个<code>&lt;K, &lt;V, W&gt;&gt;</code>对，每个<code>key</code>中的所有元素都在一起的数据集。</li>
<li><code>sortByKey()</code> 和 <code>sortBy()</code>，<code>sortByKey()</code> 函数需要在类型为 <code>&lt;K, V&gt;</code> 类型的数据集上调用。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SortByKeyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;SortByKeyDemo&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(</span><br><span class="line">            <span class="string">&quot;1,李  磊,22,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;2,刘银鹏,23,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3,齐彦鹏,22,180&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4,杨  柳,22,168&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5,敦  鹏,20,175&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> listRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.parallelize(list)</span><br><span class="line">        listRDD.foreach(println)</span><br><span class="line">        println()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3,齐彦鹏,22,180</span></span><br><span class="line">        <span class="comment">// 1,李磊,22,175</span></span><br><span class="line">        <span class="comment">// 2,刘银鹏,23,175</span></span><br><span class="line">        <span class="keyword">val</span> resultRDD = listRDD.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields = x.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            println(fields(<span class="number">0</span>) + <span class="string">&quot; &quot;</span> + fields(<span class="number">1</span>) + <span class="string">&quot; &quot;</span> + fields(<span class="number">2</span>) + <span class="string">&quot; &quot;</span> + fields(<span class="number">3</span>) + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            (fields(<span class="number">0</span>), fields(<span class="number">1</span>), fields(<span class="number">2</span>), fields(<span class="number">3</span>))</span><br><span class="line">        &#125;).map(x =&gt; &#123;(x._3, x._1)&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分区数会影响最终打印结果, 设置分区为 2, 所有分区最终会聚合为两个分区, 打印时显示每个分区的排序</span></span><br><span class="line">        <span class="comment">// 这就可能导致打印输出时出现不同分区排序数据交叉的情况。</span></span><br><span class="line">        <span class="comment">// 所以我们一般设置分区为 1, 表示排序结果聚合到一个分区</span></span><br><span class="line">        resultRDD.sortByKey(<span class="literal">true</span>, <span class="number">2</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">val</span> sortBy_RDD = listRDD.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> fields = x.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="comment">// println(fields(0) + &quot; &quot; + fields(1) + &quot; &quot; + fields(2) + &quot; &quot; + fields(3) + &quot; &quot;)</span></span><br><span class="line">            (fields(<span class="number">0</span>), fields(<span class="number">1</span>), fields(<span class="number">2</span>), fields(<span class="number">3</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">        println(<span class="string">&quot;SortBy_001&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._1, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;SortBy_002&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._2, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;SortBy_003&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._3, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;SortBy_004&quot;</span>)</span><br><span class="line">        sortBy_RDD.sortBy(_._4, <span class="literal">true</span>, <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-Action-行动算子"><a href="#2-2-2-Action-行动算子" class="headerlink" title="2.2.2 Action 行动算子"></a>2.2.2 Action 行动算子</h5><p><strong>Action 行动算子</strong>具有触发执行的特点，一个 <code>Application</code> 应用程序有几个 <code>Action</code> 类算子执行，就有几个 <code>Job</code> 运行。</p>
<p>点击快速跳转到 SparkRDD Action 列表： <a target="_blank" rel="noopener" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#actions">Actions</a></p>
<p>下面列出常用的行动算子及用法：</p>
<ul>
<li><p><code>reduce(func)</code> 通过函数 <code>func</code> 聚集数据集中的所有元素。<code>func</code> 函数接受 <code>2</code> 个参数，返回 <code>1</code> 个值。这个函数必须是关联性的，确保可以被正确的并发执行。关于 <code>reduce</code> 的执行过程，可以对比 <strong>Scala</strong> 中类似的 <code>reduce</code>函数。</p>
<p>不同于 <code>Transformation</code> 算子，执行后结果是<code>RDD</code>，执行 <code>Action</code> 算子之后，其结果不再是 <code>RDD</code>，而是一个<strong>标量</strong>。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Action_Reduce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;Action_Reduce&quot;</span>)</span><br><span class="line">        <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">        <span class="comment">// val list = List(0, 5, 15, 20, 25, 30) // 如果用这个 list 输出为: 95</span></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(</span><br><span class="line">            <span class="string">&quot;1,李  磊,22,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;2,刘银鹏,23,175&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3,齐彦鹏,22,180&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4,杨  柳,22,168&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5,敦  鹏,20,175&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> listRDD = sc.parallelize(list)</span><br><span class="line">        listRDD.foreach(println)</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">val</span> ret = listRDD.reduce(</span><br><span class="line">            (v1, v2) =&gt; &#123;</span><br><span class="line">                println(<span class="string">&quot;[LOGS] v1      &gt; &quot;</span> + v1 + <span class="string">&quot; &quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;[LOGS] v2      &gt; &quot;</span> + v2 + <span class="string">&quot; &quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;[LOGS] v1 + v2 &gt; &quot;</span> + (v1 + v2))</span><br><span class="line">                v1 + v2</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;ret: &quot;</span> + ret)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输出如下：</span><br><span class="line">3,齐彦鹏,22,180</span><br><span class="line">1,李  磊,22,175</span><br><span class="line">4,杨  柳,22,168</span><br><span class="line">2,刘银鹏,23,175</span><br><span class="line">5,敦  鹏,20,175</span><br><span class="line"></span><br><span class="line">[LOGS] v1      &gt; 3,齐彦鹏,22,180 </span><br><span class="line">[LOGS] v2      &gt; 4,杨  柳,22,168 </span><br><span class="line">[LOGS] v1 + v2 &gt; 3,齐彦鹏,22,1804,杨  柳,22,168</span><br><span class="line">[LOGS] v1      &gt; 3,齐彦鹏,22,1804,杨  柳,22,168 </span><br><span class="line">[LOGS] v2      &gt; 5,敦  鹏,20,175 </span><br><span class="line">[LOGS] v1 + v2 &gt; 3,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175</span><br><span class="line">[LOGS] v1      &gt; 1,李  磊,22,175 </span><br><span class="line">[LOGS] v2      &gt; 2,刘银鹏,23,175 </span><br><span class="line">[LOGS] v1 + v2 &gt; 1,李  磊,22,1752,刘银鹏,23,175</span><br><span class="line">[LOGS] v1      &gt; 1,李  磊,22,1752,刘银鹏,23,175 </span><br><span class="line">[LOGS] v2      &gt; 3,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175 </span><br><span class="line">[LOGS] v1 + v2 &gt; 1,李  磊,22,1752,刘银鹏,23,1753,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175</span><br><span class="line">ret: 1,李  磊,22,1752,刘银鹏,23,1753,齐彦鹏,22,1804,杨  柳,22,1685,敦  鹏,20,175</span><br></pre></td></tr></table></figure>



<ul>
<li><code>collect</code> 在 <code>Driver</code> 的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用 <code>filter</code> 或者其它操作后，返回一个足够小的数据子集再使用，直接将整个 <code>RDD</code> 集 <code>Collect</code>返回，很可能会让 <code>Driver</code> 程序 <code>OOM</code>，这点尤其需要注意。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>count</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>take</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>saveAsTextFile</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>foreach</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>saveAsNewAPIHadoopFile</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-其他算子"><a href="#2-2-3-其他算子" class="headerlink" title="2.2.3 其他算子"></a>2.2.3 其他算子</h5><p>Spark中还有许多其他种类的算子，体现了 <code>Spark</code> 算子的灵活性，其中包括将数据进行持久化的算子。</p>
<ul>
<li><code>cache</code>：懒加载执行的，必须有一个 <code>Action</code> 触发算子触发执行。 </li>
<li><code>persist</code>：懒加载执行的，必须有一个 <code>Action</code> 触发算子触发执行。 </li>
<li><code>checkpoint</code>：算子不仅能将 <code>RDD</code> 持久化到磁盘，还能切断 <code>RDD</code> 之间的依赖关系。</li>
</ul>
<h5 id="2-2-3-宽依赖和窄依赖"><a href="#2-2-3-宽依赖和窄依赖" class="headerlink" title="2.2.3 宽依赖和窄依赖"></a>2.2.3 宽依赖和窄依赖</h5><ol>
<li><p>宽依赖</p>
<p>① 子 <code>RDD</code> 的每个分区依赖于所有的父 <code>RDD</code> 分区 </p>
<p>② 对单个 <code>RDD</code> 基于 <code>Key</code>进行重组和 <code>Reduce</code>，如 <code>groupByKey</code>、<code>reduceByKey</code></p>
<p>③ 对两个 <code>RDD</code> 基于 <code>Key</code> 进行 <code>join</code> 和重组，如 <code>join</code></p>
<p>④ 经过大量 <code>shuffle</code> 生成的 <code>RDD</code>，建议进行缓存。这样避免失败后重新计算带来的开销。</p>
</li>
<li><p>窄依赖</p>
<p>① 子<code>RDD</code>的每个分区依赖于常数个父分区（与数据规模无关）</p>
<p>② 输入输出一对一的算子，且结果<code>RDD</code>的分区结构不变。主要是<code>map/flatmap</code></p>
<p>③ 输入输出一对一的算子，但结果<code>RDD</code>的分区结构发生了变化，如<code>union/coalesce</code></p>
<p>④ 从输入中选择部分元素的算子，如 <code>filter</code>、<code>distinct</code>、<code>substract</code>、<code>sample</code></p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-11T08:03:22.000Z" title="2024/6/11 16:03:22">2024-06-11</time>发表</span><span class="level-item"><time dateTime="2024-06-21T07:31:50.570Z" title="2024/6/21 15:31:50">2024-06-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/">项目</a></span><span class="level-item">1 小时读完 (大约10206个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/11/OnlineTravelBigdataPlatform/">OnlineTravelBigdataPlatform</a></p><div class="content"><h2 id="🌳-在线旅游大数据平台项目"><a href="#🌳-在线旅游大数据平台项目" class="headerlink" title="🌳 在线旅游大数据平台项目"></a>🌳 在线旅游大数据平台项目</h2><p>
    <label for="file">完成度：</label>
    <progress max="100" value="100"> 100% </progress>
</p>


<p><strong>日期任务清单</strong></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
项目开始日期: 2024-06-11</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解项目的背景以及整个系统的架构</li>
<li><input checked="" disabled="" type="checkbox"> 了解系统需要完成的主要功能</li>
<li><input checked="" disabled="" type="checkbox"> 了解系统整个架构</li>
<li><input checked="" disabled="" type="checkbox"> 完成数据服务端的部署</li>
<li><input checked="" disabled="" type="checkbox"> 完成数据客户端的部署</li>
<li><input checked="" disabled="" type="checkbox"> 了解数据集</li>
<li><input checked="" disabled="" type="checkbox"> 认识消息队列 Kafka</li>
<li><input checked="" disabled="" type="checkbox"> 完成消息队列 Kafka 的部署</li>
<li><input checked="" disabled="" type="checkbox"> 了解消息队列 Kafka 的基本应用</li>
<li><input checked="" disabled="" type="checkbox"> 使用 Flume 收集数据到 Kafka</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-12</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解实时数据分析所用到的技术</li>
<li><input checked="" disabled="" type="checkbox"> 了解 <code>SparkStreaming</code> 和 <code>Flink</code></li>
<li><input checked="" disabled="" type="checkbox"> 了解 <code>SparkStreaming</code> 的核心概念</li>
<li><input checked="" disabled="" type="checkbox"> 了解数据源</li>
<li><input checked="" disabled="" type="checkbox"> 借助<code>netcat</code>实践<code>Kafka</code></li>
<li><input checked="" disabled="" type="checkbox"> 了解转换操作</li>
<li><input checked="" disabled="" type="checkbox"> 具体实施任务：处理数据</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-13 </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解数据库连接池</li>
<li><input checked="" disabled="" type="checkbox"> 了解如何向 MySQL 数据库中写入数据</li>
<li><input checked="" disabled="" type="checkbox"> 借助 <code>alibaba Druid</code> 库实现一个数据库连接工具类 </li>
<li><input checked="" disabled="" type="checkbox"> 编写案例：<code>WordCount</code></li>
<li><input checked="" disabled="" type="checkbox"> 具体实施任务，将代码中生成的数据写入<code>MySQL</code>。</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-14</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 了解什么是 Kafka Offset</li>
<li><input checked="" disabled="" type="checkbox"> 维护 Kafka Offset</li>
<li><input checked="" disabled="" type="checkbox"> 具体实施任务，将 Kafka 的 Offset 配合 <code>MySQL</code> 用代码进行维护。</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-17</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 进行后端开发</li>
<li><input checked="" disabled="" type="checkbox"> 进行前端开发</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-18</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 进行热力图的绘制</li>
<li><input checked="" disabled="" type="checkbox"> 进行人流量柱状图的绘制</li>
<li><input checked="" disabled="" type="checkbox"> 进行人流量趋势图的绘制</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
2024-06-19 项目结束日期</p>
</li>
</ul>
<p><strong>文件目录</strong></p>
<p>[TOC]</p></div><a class="article-more button is-small is-size-7" href="/2024/06/11/OnlineTravelBigdataPlatform/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-10T09:32:28.000Z" title="2024/6/10 17:32:28">2024-06-10</time>发表</span><span class="level-item"><time dateTime="2024-06-13T13:02:31.867Z" title="2024/6/13 21:02:31">2024-06-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/">Scala</a></span><span class="level-item">30 分钟读完 (大约4554个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/10/ScalaQuickIN/">ScalaQuickIN</a></p><div class="content"><h2 id="快速入门-Scala"><a href="#快速入门-Scala" class="headerlink" title="快速入门 Scala"></a>快速入门 Scala</h2><p>[TOC]</p>
<h3 id="1-学习目标"><a href="#1-学习目标" class="headerlink" title="1. 学习目标"></a>1. 学习目标</h3><img src="./ScalaQuickIN/SCALA.png" style="zoom:33%;" />

<h3 id="2-Scala-介绍"><a href="#2-Scala-介绍" class="headerlink" title="2. Scala 介绍"></a>2. Scala 介绍</h3><h4 id="2-1-Scala-简介"><a href="#2-1-Scala-简介" class="headerlink" title="2.1 Scala 简介"></a>2.1 Scala 简介</h4><p>Scala 创始人为 <em>Martin Odersky</em>，<em>马丁·奥德斯基</em>。JDK5 和 JDK8 版本的Java编译器 <code>javac</code> 都是由他和他的团队编写的。</p>
<h4 id="2-2-Scala-的六大特征"><a href="#2-2-Scala-的六大特征" class="headerlink" title="2.2 Scala 的六大特征"></a>2.2 Scala 的六大特征</h4><p>一句话总结：Scala 是一门以 JVM 为运行环境的静态类型编程语言，具备面向对象及函数是编程的特性。下面是官网对Scala特性的介绍：</p>
<p>① <strong>SEAMLESS JAVA INTEROP</strong> 无缝与 JAVA互操作</p>
<p>Java 和 Scala 可以混编，在写 Scala 代码时可以引用 Java 的类。</p>
<p>Scala 运行在 JVM 上，所以 Java 和 Scala 可以自由的混合使用。这也就是在日常编写代码的过程中，经常看到Scala引用了很多Java包的原因。</p>
<p>② <strong>TYPE INFERENCE</strong> 类型推断（自动推测类型）</p>
<p>使类型系统不是那么的死板（静态）。不要为了类型系统工作，而是让类型系统为你工作。</p>
<p>Scala是一种弱类型语言，即它在编写代码时，不需要像强类型语言（如 Java、C++等）定义变量的类别。</p>
<p>Scala有<code>Int</code>、<code>Long</code>、<code>Short</code>、<code>Byte</code>、<code>Float</code>、<code>Double</code>、<code>Char</code>、<code>Boolean</code>这些基础数据类型。但与 Java 不同，在定义变量时，Scala用 <code>var/val</code> 来定义，让其自主判断数据类型。 </p>
<p>其中<code>val</code>是常量，<code>var</code>是变量，一般来说，用<code>val</code>比较多（涉及资源的利用）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中定义一个变量</span></span><br><span class="line"><span class="type">String</span> name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scala 中定义一个变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>③ <strong>CONCURRENCY &amp; DISTRIBUTION</strong> 并发和分布式（Actor）</p>
<p>Scala 在操作集合时使用了数据并行操作。并且使用Actor（Actor是一种不共享数据，依赖于消息传递的并发编程模式， 有效的避免了死锁、资源争夺等情况）来解决并发和分布式中的一些问题。或者使用 <code>futures</code> 类进行异步编程。</p>
<p>使用 Scala 进行并发以及分布式场景下的开发时有得天独厚的优势。</p>
<p>④ <strong>TRAITS</strong> 特性</p>
<p>将 <strong>Java 风格接口的灵活性</strong>与<strong>类的强大功能</strong>相结合。认为是一种多重继承。</p>
<p>其实这就相当于 Java 的接口，但实际上它比接口还功能强大。 与接口不同的是，它还可以定义属性和方法的实现。</p>
<p>简单来说：<em><strong>TRAITS &#x3D; Interface + Abstract</strong></em>。</p>
<p>⑤ <strong>PATTERN MATCHING</strong> 模式匹配</p>
<p>更强大的 <code>Switch</code>，它可以匹配类的层级结构、序列以及更多。</p>
<p>⑥ <strong>HIGHER-ORDER FUNCTIONS</strong> 高阶函数</p>
<p>函数是一级对象。在保证类型安全的情况下编写它们。在任何地方使用它们，传递给任何东西，即函数可以作为参数传递到函数中。</p>
<h4 id="2-3-具体应用"><a href="#2-3-具体应用" class="headerlink" title="2.3 具体应用"></a>2.3 具体应用</h4><ul>
<li>Kafka：分布式消息队列，内部代码经常用来处理并发的问题，用 Scala 可以大大简化其代码。</li>
<li>Spark：方便处理多线程场景，另外Spark主要用作内存计算，经常要用来实现复杂的算法，利用Scala这种函数式编程语言可以大大简化代码。</li>
</ul>
<h3 id="3-Scala-的安装和使用"><a href="#3-Scala-的安装和使用" class="headerlink" title="3. Scala 的安装和使用"></a>3. Scala 的安装和使用</h3><h4 id="3-1-Windows-下安装-Scala"><a href="#3-1-Windows-下安装-Scala" class="headerlink" title="3.1 Windows 下安装 Scala"></a>3.1 Windows 下安装 Scala</h4><p>Scala下载地址：<a target="_blank" rel="noopener" href="https://www.scala-lang.org/">The Scala Programming Language (scala-lang.org)</a></p>
<p>① 进入下载地址后，选择合适的Scala版本进行安装。记住安装的路径，方便配置环境变量。</p>
<p>② 配置环境变量 <code>SCALA_HOME</code></p>
<p>③ 验证是否安装成功：进入命令行<code>CMD</code>，输入 <code>scala -version</code>，显示版本号及表明配置成功。</p>
<h4 id="3-2-IDEA-2022-中配置-Scala-插件"><a href="#3-2-IDEA-2022-中配置-Scala-插件" class="headerlink" title="3.2 IDEA 2022 中配置 Scala 插件"></a>3.2 IDEA 2022 中配置 Scala 插件</h4><p>① 进入IDEA，Files→Settings→Plugins</p>
<p>② 进入Marketolace界面，直接搜索<code>Scala</code>，安装即可。</p>
<p>③ 在编写 Scala 代码时，双击 <code>Shift</code>，选择 <code>Add Framework</code> 后，添加 Scala 框架，即可编写 Scala 代码。</p>
<h3 id="4-Scala-基础"><a href="#4-Scala-基础" class="headerlink" title="4. Scala 基础"></a>4. Scala 基础</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Byte</code></td>
<td>8-bit 的有符号数字，范围在 -128 ~ 127</td>
</tr>
<tr>
<td><code>Short</code></td>
<td>16-bit 的有符号数字，范围在 -32768 ~ 32767</td>
</tr>
<tr>
<td><code>Int</code></td>
<td>32-bit 的有符号数字，范围在 -2147483648 ~ 2147483647</td>
</tr>
<tr>
<td><code>Long</code></td>
<td>64-bit 的有符号数字，范围在 -9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td><code>Float</code></td>
<td>32-bit IEEE 754 单精度浮点数</td>
</tr>
<tr>
<td><code>Double</code></td>
<td>64-bit IEEE 754 双精度浮点数</td>
</tr>
<tr>
<td><code>Char</code></td>
<td>16-bit Unicode 字符，范围 U+0000 ~ U+FFFF</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔类型</td>
</tr>
<tr>
<td><code>Unit</code></td>
<td>表示空值，与其他语言中的 <code>void</code> 相同</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>空值或者空引用</td>
</tr>
<tr>
<td><code>Nothing</code></td>
<td>所有其他类型的子类型，表示没有值</td>
</tr>
<tr>
<td><code>Any</code></td>
<td>所有类型的超类，任何类型都属于<code>Any</code></td>
</tr>
<tr>
<td><code>AnyRef</code></td>
<td>所有引用类型的超类</td>
</tr>
<tr>
<td><code>AnyVal</code></td>
<td>所有值类型的超类</td>
</tr>
<tr>
<td><code>Nil</code></td>
<td>表示长度为0的List</td>
</tr>
</tbody></table>
<p>比较特殊的 <code>None</code>，是<code>Option</code>的两个子类之一，另一个是<code>Some</code>，用于安全的函数返回值。</p>
<p>Scala 推荐在可能返回空的方法使用 <code>Option[X]</code> 作为返回类型。如果有值就返回 <code>Some[X]</code>，否则返回 <code>None</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(key: <span class="type">A</span>): option[<span class="type">B</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (contains(key))</span><br><span class="line">    	<span class="type">Some</span>(getValue(key))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="type">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-变量和常量的声明"><a href="#4-2-变量和常量的声明" class="headerlink" title="4.2 变量和常量的声明"></a>4.2 变量和常量的声明</h4><ul>
<li><p>变量用 <code>var</code> 定义，可修改</p>
</li>
<li><p>常量用 <code>val</code> 定义，不可修改</p>
</li>
<li><p>定义变量或常量的时候，也可以写上返回值的类型，一般省略，如 <code>val a: Int = 10</code></p>
</li>
<li><p>常量不可以再赋值</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">println(name)		<span class="comment">// zhangsan</span></span><br><span class="line">name = <span class="string">&quot;lisi&quot;</span></span><br><span class="line">println(name)		<span class="comment">// lisi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> gender = <span class="string">&quot;m&quot;</span></span><br><span class="line">gender = <span class="string">&quot;m&quot;</span>		<span class="comment">// [Error] 不可以给常量赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-键盘标准输入"><a href="#4-3-键盘标准输入" class="headerlink" title="4.3 键盘标准输入"></a>4.3 键盘标准输入</h4><p>编程中可以通过键盘输入语句来接收用户输入的数据（也就是 Java 中的 Scanner 对象）。<br>在 Scala 中只需要导入对应的包，比 Java 还要简单，不需要实例化对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Please Input Your Name: &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> name = <span class="type">StdIn</span>.readLine()</span><br><span class="line">        println(<span class="string">&quot;Please Input Your Age: &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">        printf(<span class="string">&quot;Your Name is %s, Your Age is %d&quot;</span>, name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码一样，<code>printf()</code> 的用法和 Java 中一样，为格式化输出。注意使用规范即可。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>%d</code></td>
<td>十进制数字</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>字符</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>指数浮点数</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点数</td>
</tr>
</tbody></table>
<h4 id="4-4-类Class-和-对象Object"><a href="#4-4-类Class-和-对象Object" class="headerlink" title="4.4 类Class 和 对象Object"></a>4.4 类<code>Class</code> 和 对象<code>Object</code></h4><ul>
<li>在编写 Scala 代码时，一般不加分号<code>;</code>，如果一行中有多条语句，则可以用分号隔开，如：<code>var a = 10; var b = 20</code>。</li>
<li><code>class</code> 默认实现了 <code>getter/setter</code> 方法。</li>
<li><code>class</code> 中如果有参数传入，那么这个构造器就是这个类的默认构造器。</li>
<li><code>class</code> 在被 <code>new</code> 新建对象的时候，除了方法内部不执行，其他地方的代码都会执行，类似于Java中的工具类。</li>
<li><code>Object</code> 里面不能传递参数，<code>Object</code> 里面的属性和方法都是静态的，类似于 Java 中 <code>static</code> 修饰的东西，类似于 Java 中的工具类。</li>
<li>伴生类和伴生对象，在一个 Scala 文件中，如果 <code>Class</code> 和 <code>Object</code> 的名字一样，则互为伴生类和伴生对象。他们可以互相访问到互相的私有成员变量。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">xname:<span class="type">String</span>, xage: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name  = xname</span><br><span class="line">    <span class="keyword">val</span> age   = xage</span><br><span class="line">    <span class="keyword">var</span> money = <span class="number">100</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写构造器, 必须调用类的默认构造器</span></span><br><span class="line"><span class="comment">     * @param xname</span></span><br><span class="line"><span class="comment">     * @param xage</span></span><br><span class="line"><span class="comment">     * @param xmoney</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(xname: <span class="type">String</span>, xage: <span class="type">Int</span>, xmoney: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>(xname, xage)</span><br><span class="line">        money = xmoney</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Checkpoint&quot;</span>)			<span class="comment">// `class` 在被 `new` 新建对象的时候，除了方法内部不执行，其他地方的代码都会执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Inside Function&quot;</span>)	<span class="comment">// 方法内部不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Checkpoint&quot;</span>)			<span class="comment">// `class` 在被 `new` 新建对象的时候，除了方法内部不执行，其他地方的代码都会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> person1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">        println(person.name + <span class="string">&quot;:&quot;</span> + person.age)		<span class="comment">// 默认实现了 getter/setter 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-IF-ELSE-语句"><a href="#4-5-IF-ELSE-语句" class="headerlink" title="4.5 IF-ELSE 语句"></a>4.5 IF-ELSE 语句</h4><p>Scala 中的条件判断语句同 Java 中的条件判断语句，语法结构基本一致。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;请输入年龄&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;请输入 0 ~ 100 的数字&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-Loop-循环语句"><a href="#4-6-Loop-循环语句" class="headerlink" title="4.6 Loop 循环语句"></a>4.6 Loop 循环语句</h4><ul>
<li><code>to</code> 和 <code>until</code> 语句的区别</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ToUntilDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="number">1</span> to <span class="number">10</span>)		<span class="comment">// to    表示 [1, 10], 输出: Range(1, 2, 3, ..., 10)</span></span><br><span class="line">        println(<span class="number">1</span> until <span class="number">10</span>)		<span class="comment">// until 表示 [1, 10), 输出: Range(1, 2, 3, ...,  9)</span></span><br><span class="line">        println(<span class="number">1</span> to (<span class="number">10</span>, <span class="number">2</span>))	<span class="comment">// 表示按照步长为`2`来输出数据, 输出: Range(1, 3, 5, 7, 9)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for</code> 循环</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">            print(i + &#x27; &#x27;)		<span class="comment">// 输出: 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Scala 中的 `for` 循环可以将 if 语句直接写在 for 循环中</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; <span class="keyword">if</span> i &gt; <span class="number">5</span>; <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d &quot;</span>, i)	<span class="comment">// 输出: 6 8 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上面的写法可以等同于下面的写法</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">5</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双重 for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>; j &lt;- <span class="number">1</span> to <span class="number">5</span>) &#123;</span><br><span class="line">            println(i + <span class="string">&quot;:&quot;</span> + j)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上面的写法可以等同于下面的写法</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to <span class="number">5</span>) &#123;</span><br><span class="line">                println(i + <span class="string">&quot;:&quot;</span> + j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Scala 中不能使用类似于 <code>x++</code>、<code>x--</code> 的操作，需要使用 <code>x += 1</code> 或者 <code>x -= 1</code> 来完成自增或者自减操作。</li>
<li><code>for</code> 循环使用 <code>yield</code> 关键字返回一个集合，<code>for &#123; 子句 &#125; yield &#123;变量或表达式&#125;</code>，<code>for</code> 循环中的 <code>yield</code> 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala 中 <code>for</code> 循环是有返回值的。如果被循环的是 <code>Map</code>，返回的就是 <code>Map</code>，被循环的是 <code>List</code>，返回的就是 <code>List</code>，以此类推。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Loop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    	<span class="keyword">val</span> range = <span class="number">1</span> to <span class="number">10</span>;</span><br><span class="line">    	<span class="keyword">for</span> (num &lt;- range <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">if</span> num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      		printf(<span class="string">&quot;%d&quot;</span>, num);	<span class="comment">// 6 8 10 </span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result_1 = <span class="keyword">for</span> (num&lt;-range <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">if</span> num &gt; <span class="number">5</span>)  <span class="keyword">yield</span> num		<span class="comment">// yield 变量</span></span><br><span class="line">    	println(result_1) 		<span class="comment">// Vector(6, 8, 10)</span></span><br><span class="line">        <span class="keyword">val</span> result_2 = <span class="keyword">for</span> (num&lt;-range <span class="keyword">if</span> num &gt; <span class="number">5</span>)  				<span class="keyword">yield</span> num % <span class="number">2</span>	<span class="comment">// yield 表达式</span></span><br><span class="line">    	println(result_2) 		<span class="comment">// Vector(0, 1, 0, 1, 0)</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>while</code> 和 <code>do...while</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Loop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;第&quot;</span> + index + <span class="string">&quot;次循环&quot;</span>)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            println(<span class="string">&quot;第&quot;</span> + index + <span class="string">&quot;次循环&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">while</span>(index &lt; <span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Scala-函数-方法"><a href="#5-Scala-函数-方法" class="headerlink" title="5. Scala 函数(方法)"></a>5. Scala 函数(方法)</h3><h4 id="5-1-函数的定义"><a href="#5-1-函数的定义" class="headerlink" title="5.1 函数的定义"></a>5.1 函数的定义</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数(方法) 的定义</span></span><br><span class="line"><span class="comment">// def 函数名(参数x: 参数类型, 参数y: 参数类型): 返回类型 = &#123;</span></span><br><span class="line"><span class="comment">//     函数体</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span></span>(x: <span class="type">Int</span>, y: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    function_body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>Scala 使用 <code>def</code> 关键字告诉编译器这是一个函数（方法）</li>
<li>我们可以通过在参数列表后面加一个<strong>冒号<code>:</code><strong>和</strong>类型</strong>来显式地指定返回类型。</li>
<li>函数可以写<code>返回类型</code>，也可以不写，会自动推断（最后一行是什么类型，就被推断成什么类型）。有时候不能省略，必须写，比如在<strong>递归函数中</strong>或者<strong>函数的返回值是函数类型</strong>的时候。</li>
<li>Scala 中函数有返回值时，可以写 <code>return</code>，也可以不写 <code>return</code>，不写 <code>return</code> 时会把函数中最后一行当做结果返回。当写 <code>return</code> 时，必须要写函数的<code>返回类型</code>。</li>
<li>传递给方法的参数可以在方法中使用，并且 Scala 规定：方法的传过来的参数为常量 <code>val</code> 而不是变量 <code>var</code> 。</li>
<li>如果去掉函数体前面的等号<code>=</code>，那么这个函数返回类型必定是 <code>Unit</code>。这种说法无论函数体里面什么逻辑都成立，Scala 可以把任意类型转换为 <code>Unit</code>。假设，函数里面的逻辑最后返回了一个 <code>String</code>，那么这个返回值会被转换成 <code>Unit</code>，原本逻辑的值会被丢弃。这种方法往往适用于无返回值的函数中。</li>
</ol>
<h4 id="5-2-递归函数"><a href="#5-2-递归函数" class="headerlink" title="5.2 递归函数"></a>5.2 递归函数</h4><img src="./ScalaQuickIN/ScalaGNUFunction.png" style="zoom: 67%;" />

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归函数:</span></span><br><span class="line"><span class="comment">     * 关键点在于递归的定义, 终止条件(避免无休止的递归, 导致栈溢出问题)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">        num * f1(num<span class="number">-1</span>)		<span class="comment">// f1(5) = 5*f1(4) = 5*4*f1(3) = 5*4*3*f1(2) = 5*4*3*2*f1(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(f1(<span class="number">5</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-包含参数默认值的函数"><a href="#5-3-包含参数默认值的函数" class="headerlink" title="5.3 包含参数默认值的函数"></a>5.3 包含参数默认值的函数</h4><ul>
<li>和其他语言没有任何区别</li>
<li>默认值的函数中，如果传入的参数个数与函数定义相同，则传入的数值会覆盖默认值。</li>
<li>如果不想覆盖默认值，且传入的参数个数小于定义的函数的参数，则需要指定参数名称。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含参数默认值的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(x: <span class="type">Int</span>=<span class="number">5</span>, y: <span class="type">Int</span>=<span class="number">10</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(f2())			<span class="comment">// 输出: 15</span></span><br><span class="line">        println(f2(<span class="number">10</span>, <span class="number">20</span>))		<span class="comment">// 输出: 30</span></span><br><span class="line">        println(f2(<span class="number">10</span>))			<span class="comment">// 输出: 20</span></span><br><span class="line">        println(f2(y=<span class="number">30</span>))		<span class="comment">// 输出: 35</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-可变参数个数的函数"><a href="#5-4-可变参数个数的函数" class="headerlink" title="5.4 可变参数个数的函数"></a>5.4 可变参数个数的函数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可变参数个数的函数</span></span><br><span class="line"><span class="comment">     * 传入多个参数时, 多个参数之间用逗号分隔</span></span><br><span class="line"><span class="comment">     * 传入的参数其实就是不定长数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>(elements: <span class="type">Int</span>*): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (element &lt;- elements) &#123;</span><br><span class="line">            sum += element</span><br><span class="line">        &#125;</span><br><span class="line">        sum</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(f3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))	<span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-匿名函数"><a href="#5-5-匿名函数" class="headerlink" title="5.5 匿名函数"></a>5.5 匿名函数</h4><p>匿名函数有以下几种：</p>
<ul>
<li>有参匿名函数</li>
<li>无参匿名函数</li>
<li>有返回值的匿名函数</li>
</ul>
<p>在定义和使用匿名函数时：</p>
<ul>
<li>可以将匿名函数返回给 <code>val</code> 定义的值</li>
<li>匿名函数不能显示声明函数的返回类型</li>
</ul>
<p>在 Scala 中 ，<strong>大多数情况</strong>下 <code>=&gt;</code> 是匿名函数的显著标志。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匿名函数: 经常和高阶函数一起使用</span></span><br><span class="line"><span class="comment">     * 1. 有参匿名函数</span></span><br><span class="line"><span class="comment">     * 2. 无参匿名函数</span></span><br><span class="line"><span class="comment">     * 3. 有返回值的匿名函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 有参数匿名函数</span></span><br><span class="line">        <span class="keyword">val</span> value1 = (a: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">            println(a)</span><br><span class="line">        &#125;</span><br><span class="line">        value1(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参数匿名函数</span></span><br><span class="line">        <span class="keyword">val</span> value2 = () =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;无参数匿名函数&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        value2()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有返回值的匿名函数</span></span><br><span class="line">        <span class="keyword">val</span> value3 = (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">            a + b</span><br><span class="line">        &#125;</span><br><span class="line">        println(value3(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-嵌套函数"><a href="#5-6-嵌套函数" class="headerlink" title="5.6 嵌套函数"></a>5.6 嵌套函数</h4><p>嵌套函数其实就是函数里套了函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f5</span> </span>(num: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="meta">@tailrec</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">                b</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f6(a<span class="number">-1</span>, a*b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f6(num, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        f5(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-7-偏应用函数"><a href="#5-7-偏应用函数" class="headerlink" title="5.7 偏应用函数"></a>5.7 偏应用函数</h4><p>偏应用函数是一种表达式，不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctionDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 这里只是一个普通的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, log: <span class="type">String</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Date is &quot;</span> + date + <span class="string">&quot;, Log is &quot;</span> + log)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照普通函数的方法使用</span></span><br><span class="line">        <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>()		<span class="comment">// 与 Java 混编</span></span><br><span class="line">        log(date, <span class="string">&quot;log1&quot;</span>)</span><br><span class="line">        log(date, <span class="string">&quot;log2&quot;</span>)</span><br><span class="line">        log(date, <span class="string">&quot;log3&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们发现, 上面的程序除了 log 参数在改变, date 参数没有变化</span></span><br><span class="line">        <span class="comment">// 此时我们可以使用偏应用函数来优化</span></span><br><span class="line">        <span class="comment">// _ 下划线可以理解为一个变化的参数, 而 date 可以理解为一个固定的参数(他本身可能是变化的)</span></span><br><span class="line">        <span class="keyword">val</span> logWithDate = log(date, _:<span class="type">String</span>)</span><br><span class="line">        logWithDate(<span class="string">&quot;log_11&quot;</span>)</span><br><span class="line">        logWithDate(<span class="string">&quot;log_12&quot;</span>)</span><br><span class="line">        logWithDate(<span class="string">&quot;log_13&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-8-高阶函数"><a href="#5-8-高阶函数" class="headerlink" title="5.8 高阶函数"></a>5.8 高阶函数</h4><p><strong>高阶函数：</strong>函数的<code>参数</code>是函数，或者函数的<code>返回类型</code>是函数，或者<strong>函数的<code>参数</code>和函数的<code>返回类型</code>是函数</strong>的函数。</p>
<p>函数的格式为 <code>(A)=&gt;B</code>,  后面没有函数体, 此函数接收类型 <code>A</code> 的参数, 返回类型 <code>B</code> 的函数。</p>
<ul>
<li>函数的<code>参数</code>是函数：其实就是定义一个传入<code>参数</code>和<code>返回类型</code>的<strong>模板参数</strong>，但是这个模板需要从其他地方实现。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的参数是函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f7</span></span>(a: <span class="type">Int</span>, func: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = func(<span class="number">1</span>, <span class="number">2</span>)		<span class="comment">// 这里将函数作为参数传入 f7, 而 result 使用了这个函数</span></span><br><span class="line">    							<span class="comment">// 这里我理解为模板, result 使用了一个 参数为(Int, Int), 返回类型为 Int 的函数模板</span></span><br><span class="line">    							<span class="comment">// 那么这个模板的具体实现是什么, 则需要从其他地方实现</span></span><br><span class="line">    a * result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f8</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;	<span class="comment">// 这里就是对于模板的一种实现</span></span><br><span class="line">	x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(f7(<span class="number">5</span>, f8))				<span class="comment">// 使用这种方式将 f8 传入, 并且打印输出, 结果为: 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然我们也可以结合匿名函数一起实现</span></span><br><span class="line">println(f7(<span class="number">5</span>, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;x + y&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的<code>返回类型</code>是函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的返回类型是函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f9</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): (<span class="type">String</span>, <span class="type">String</span>) =&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f10</span></span>(c: <span class="type">String</span>, d: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        a + <span class="string">&quot; &quot;</span> + b + <span class="string">&quot; &quot;</span> + c + <span class="string">&quot; &quot;</span> + d</span><br><span class="line">    &#125;</span><br><span class="line">    f10		<span class="comment">// 返回一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像这种括号连着括号的`()()`, 往往代表着出现了函数的返回类型是函数的函数</span></span><br><span class="line">println(f9(<span class="number">1</span>, <span class="number">2</span>)(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>)) 	<span class="comment">// 输出: 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的<code>参数</code>和函数的<code>返回类型</code>是函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f11</span></span>(x: <span class="type">Int</span>, f: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(f11(<span class="number">1</span>, (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; &#123; a + b &#125; ) (<span class="number">100</span>, <span class="number">200</span>))	<span class="comment">// 输出: 300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _ 类似于 Java 中的 *. 通配符, 变量只使用一次的时候可以简写如下:</span></span><br><span class="line">println(f11(<span class="number">1</span>, (_ + _))(<span class="number">100</span>, <span class="number">200</span>))							<span class="comment">// 输出: 300</span></span><br></pre></td></tr></table></figure>

<h4 id="5-9-柯里化函数"><a href="#5-9-柯里化函数" class="headerlink" title="5.9 柯里化函数"></a>5.9 柯里化函数</h4><p>柯里化函数，或称<strong>颗粒化函数</strong>，将参数变成颗粒散落简而言之就是将参数不断拆分。柯里化函数基本是在做这么一件事情：只传递给函数一部分参数来调用它，让它<strong>返回一个函数</strong>去处理剩下的参数。如果写成公式文字就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn(a, b, c, d) =&gt; fn(a)(b)(c)(d)</span><br><span class="line">fn(a, b, c, d) =&gt; fn(a)(b, c, d)</span><br><span class="line">fn(a, b, c, d) =&gt; fn(a, b)(c)(d)</span><br><span class="line">fn(a, b, c, d) =&gt; fn(a, b, c)(d)</span><br></pre></td></tr></table></figure>

<p>可以理解为高阶函数的简化，类似于返回类型为函数的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f12</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>, d: <span class="type">Int</span>) = &#123;</span><br><span class="line">    a + b + c + d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数: 可以理解为高阶函数的简化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f13</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>)(c: <span class="type">Int</span>, d: <span class="type">Int</span>) = &#123;</span><br><span class="line">    a + b + c + d    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Scala-字符串"><a href="#6-Scala-字符串" class="headerlink" title="6. Scala 字符串"></a>6. Scala 字符串</h3><p><code>Scala</code>  中的字符串和 <code>Java</code> 中的字符串用法几乎完全相同。</p>
<p><code>String</code> 和 <code>StringBuilder</code>的区别：<code>String</code> 不可修改，<code>StringBuilder</code> 可修改。</p>
<h4 id="6-1-String"><a href="#6-1-String" class="headerlink" title="6.1 String"></a>6.1 String</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.szy.inspur.subowen.rdd.base</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> str_1: <span class="type">String</span> = <span class="string">&quot;aabbccdd&quot;</span></span><br><span class="line">        println(str_1.indexOf(<span class="string">&quot;a&quot;</span>))                 <span class="comment">// 输出: 0</span></span><br><span class="line">        println(str_1.indexOf(<span class="number">98</span>))                  <span class="comment">// 输出: 2, 这里输入的整数是 ASCII 码</span></span><br><span class="line">        <span class="keyword">val</span> str_2: <span class="type">String</span> = <span class="string">&quot;AABBCCDD&quot;</span></span><br><span class="line">        println(str_1 == str_2)                     <span class="comment">// 输出: false</span></span><br><span class="line">        println(str_1.compareToIgnoreCase(str_2))   <span class="comment">// 输出: 0, 如果 str != str_2, 则输出 `-1`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-StringBuilder"><a href="#6-2-StringBuilder" class="headerlink" title="6.2 StringBuilder"></a>6.2 StringBuilder</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.szy.inspur.subowen.rdd.base</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> stringBuilder = <span class="keyword">new</span> mutable.<span class="type">StringBuilder</span></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        println(stringBuilder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result = <span class="number">1</span> .+ (<span class="number">2</span>)                       <span class="comment">// Scala 中的运算操作其实都是调用函数</span></span><br><span class="line">                                                    <span class="comment">// 因此, `result 1 .+ (2)` 其实和 result = 1 + 2 一样</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// StringBuilder 可以 `+=` Char 类型, 而不能 `+=` String 类型</span></span><br><span class="line">        <span class="comment">// 普通的 `+` 只有 Char 类型追加在后面</span></span><br><span class="line">        stringBuilder ++= <span class="string">&quot;c&quot;</span>;  println(stringBuilder)      <span class="comment">// 输出: abcc</span></span><br><span class="line">        stringBuilder += &#x27;d&#x27;;   println(stringBuilder)      <span class="comment">// 输出: abccd</span></span><br><span class="line">        <span class="comment">// stringBuilder += &quot;e&quot;;   println(stringBuilder)   // [ERROR]</span></span><br><span class="line">        <span class="comment">// stringBuilder ++= &#x27;f&#x27;;  println(stringBuilder)   // [ERROR]</span></span><br><span class="line">        stringBuilder + &#x27;e&#x27;;    println(stringBuilder)      <span class="comment">// 输出: abccde</span></span><br><span class="line">        stringBuilder + <span class="string">&quot;f&quot;</span>;    println(stringBuilder)      <span class="comment">// 输出: abccde, 可以看到 &quot;f&quot; 没有被添加到字符串后面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-String-的操作方法"><a href="#6-3-String-的操作方法" class="headerlink" title="6.3 String 的操作方法"></a>6.3 String 的操作方法</h4><p>万金油<code>append</code>，<code>append()</code>不受类型的限制。</p>
<h3 id="7-集合"><a href="#7-集合" class="headerlink" title="7. 集合"></a>7. 集合</h3><h4 id="7-1-数组"><a href="#7-1-数组" class="headerlink" title="7.1 数组"></a>7.1 数组</h4><h5 id="7-1-1-创建数组"><a href="#7-1-1-创建数组" class="headerlink" title="7.1.1 创建数组"></a>7.1.1 创建数组</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建数组的两种方式</span></span><br><span class="line"><span class="comment"> * 1. new Array[String](3)</span></span><br><span class="line"><span class="comment"> * 2. 直接 Array</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>







</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-22T02:13:00.000Z" title="2024/5/22 10:13:00">2024-05-22</time>发表</span><span class="level-item"><time dateTime="2024-05-22T04:33:42.112Z" title="2024/5/22 12:33:42">2024-05-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/">ECharts</a></span><span class="level-item">5 分钟读完 (大约751个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/22/Build-Tomcat/">IDEA 2022 搭建 Tomcat 环境</a></p><div class="content"><p>[TOC]</p>
<h2 id="Tomcat-环境的搭建"><a href="#Tomcat-环境的搭建" class="headerlink" title="Tomcat 环境的搭建"></a>Tomcat 环境的搭建</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/what_how_why2020/article/details/114100385">参考教程</a></p>
<h3 id="下载-Tomcat"><a href="#下载-Tomcat" class="headerlink" title="下载 Tomcat"></a>下载 Tomcat</h3><p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/index.html">Tomcat官网地址</a><br><img src="https://img-blog.csdnimg.cn/direct/d5e359b939c040b8978dc243e260f662.png#pic_center" alt="Tomcat官网"><br>在 Tomcat 官网中下载指定版本的 Tomcat，左侧 Download 处有相应版本，这里推荐 Tomcat 9 版本（因为Tomcat 10 在配置时会出现一定的问题）。<br><img src="https://img-blog.csdnimg.cn/direct/30b899f91e23440abc83c30ac92a1ccd.png#pic_center" alt="TomcatDownload"><br>下载后解压到指定位置即可。</p>
<h3 id="配置环境变量即可"><a href="#配置环境变量即可" class="headerlink" title="配置环境变量即可"></a>配置环境变量即可</h3><p>配置 Tomcat 环境变量前一定要配置好 Java 的环境变量，尤其是JAVA_HOME，这里我一开始并没有配置 <code>JAVA_HOME</code>，我的环境变量是<code>JAVA_HOME_180=xxx</code>，这种方式Tomcat是找不到<code>JAVA_HOME</code>的，因此我又重新配置了<code>JAVA_HOME</code>。<br>我的 <code>JAVA_HOME</code> 环境变量为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=D:\JDK\jdk1.8.0_231</span><br></pre></td></tr></table></figure>
<p>下面是 Tomcat 的环境变量配置：<br>新建 <code>CATALINA_HOME</code> 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_HOME=D:\tomcat\apache-tomcat-9.0.89</span><br></pre></td></tr></table></figure>
<p>修改<code>Path</code>，在 <code>Path</code> 后添加（新建）如下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%CATALINA_HOME%\lib</span><br><span class="line">%CATALINA_HOME%\bin</span><br><span class="line">%CATALINA_HOME%\lib\servlet-api.jar</span><br></pre></td></tr></table></figure>

<h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>在命令行中，执行命令：<code>startup.bat</code>，若正常打印相关配置变量、且 Tomcat 进程被阻塞，即证明环境搭建成功。访问<code>localhost:8080</code>，出现以下界面即证明成功搭建。<br><img src="https://img-blog.csdnimg.cn/direct/28287d7ab3a145e396be286cc559d6e8.png#pic_center" alt="TomcatSuccess"><br>使用 <code>shutdown.bat</code> 命令即可使阻塞的 Tomcat 进程被关闭，推荐使用这种方式关闭 Tomcat。</p>
<h3 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h3><ol>
<li>协议处理程序初始化失败：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_59125846/article/details/122178889">参考教程</a><br>这个问题有可能是由于8080端口被占用了，在Windows中可以使用如下命令查看端口的占用情况： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|<span class="built_in">findstr</span> &quot;<span class="number">8080</span>&quot;</span><br></pre></td></tr></table></figure>
 如果确实被占用了，可以使用如下命令杀死端口号为 <code>&lt;PIDNUM&gt;</code> 的进程。 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> -PID &lt;PIDNUM&gt; -F</span><br></pre></td></tr></table></figure></li>
<li>闪退<br>可能原因是：环境变量配置不正确，仔细检查环境变量的配置。</li>
<li>乱码<br>问题描述：打开startup.bat后汉字乱码<br>解决方法：在.\apache-tomcat-9.0.43\conf下打开logging.properties文件<br>将<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>替换为<code>java.util.logging.ConsoleHandler.encoding = GBK</code></li>
</ol>
<h2 id="社区版-IDEA-如何配置-Tomcat"><a href="#社区版-IDEA-如何配置-Tomcat" class="headerlink" title="社区版 IDEA 如何配置 Tomcat"></a>社区版 IDEA 如何配置 Tomcat</h2><p>CSDN 上大多数教程使用 Maven 创建 Tomcat 项目，但是这种方法实在是过于麻烦，社区版和专业版又有些不同，找不到很多东西。</p>
<p>如何配置 IDEA 2022 社区版中的 Tomcat</p>
<ol>
<li>安装插件<br>在 File → Settings → Plugin 中安装插件，搜索 Tomcat，安装插件。<br><img src="https://img-blog.csdnimg.cn/direct/240fa059550945a28d84ff346ecfb0f7.png#pic_center" alt="SmartTomcat"></li>
<li>配置Tomcat路径<br>安装插件后，在 File → Settings → Plugin → Tomcat Server<br>添加配置如下：<br><img src="https://img-blog.csdnimg.cn/direct/0c4778a942504a91b01fcfbb42555f29.png#pic_center" alt="SmartTomcatConfig"></li>
<li>完成</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-04T01:43:02.000Z" title="2024/5/4 09:43:02">2024-05-04</time>发表</span><span class="level-item"><time dateTime="2024-05-04T01:48:58.610Z" title="2024/5/4 09:48:58">2024-05-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a><span> / </span><a class="link-muted" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/">HBase</a></span><span class="level-item">2 分钟读完 (大约348个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/04/Hadoop2HBase/">在 Hadoop 高可用的基础上搭建 HBase 高可用</a></p><div class="content"><h1 id="在-Hadoop-高可用的基础上搭建-HBase-高可用"><a href="#在-Hadoop-高可用的基础上搭建-HBase-高可用" class="headerlink" title="在 Hadoop 高可用的基础上搭建 HBase 高可用"></a>在 Hadoop 高可用的基础上搭建 HBase 高可用</h1><p>当Hadoop高可用搭建完成后，需要进一步再Hadoop高可用集群上搭建HBase高可用时，过程如下：</p>
<ol>
<li><p>前提说明：</p>
<p>我的集群为三台机器，每台机器上都有ZooKeeper，使用用户名和主机名（<code>Username@Hostname</code>）分别如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master@master</span><br><span class="line">master@slaver01</span><br><span class="line">master@slaver02</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先保证 <strong>ZooKeeper</strong> 正常部署</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要保证<strong>Hadoop</strong>正常部署</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[master@master ~]$ start-dfs.sh</span><br><span class="line">[master@slaver01 ~]$ start-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压HBase</p>
</li>
<li><p>配置环境变量</p>
</li>
<li><p>生效环境变量</p>
</li>
<li><p>修改配置文件</p>
<ul>
<li><p>修改 <code>hbase-site.xml</code> 文件</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HBase数据在HDFS中的存放的路径 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里 ns 是 Hadoop 的 nameservice的值, 指向的是一个高可用的通道 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HBase 的运行模式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- false是单机模式, 若为 false, HBase 和 ZooKeeper 会运行在同一个 JVM 里面 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- true是分布式模式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master,slaver01,slaver02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ZooKeeper快照的存储位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/zookeeper-3.4.6/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- V2.1版本，在伪分布式情况下, 设置为 false --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当使用 hdfs 时, 设置为 true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  需要注意的是：</p>
<p>  这里使用了<code>ns</code>这个高可用通道，因此需要将Hadoop的 <code>core-site.xml</code> 与 <code>hdfs-site.xml</code>移动到<code>/opt/module/hbase-2.1.0/conf</code>下</p>
</li>
<li><p>修改 <code>regionserver</code> 文件</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">slaver01</span><br><span class="line">slaver02</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
</ol>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatarMyself.jpg" alt="NilEra"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">NilEra</p><p class="is-size-6 is-block">C/C++ Developer!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jinan Shandong</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">25</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/NilEra-K" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/NilEra-K" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://nano.chemtian.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Thymol Blue</span></span><span class="level-right"><span class="level-item tag">nano.chemtian.top</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CppDev/"><span class="level-start"><span class="level-item">CppDev</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/CppDev/QT6/"><span class="level-start"><span class="level-item">QT6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="level-start"><span class="level-item">软件源</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">大数据技术</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/ECharts/"><span class="level-start"><span class="level-item">ECharts</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/HBase/"><span class="level-start"><span class="level-item">HBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Axure-RP-9/"><span class="level-start"><span class="level-item">Axure RP 9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构/算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C-Hash/"><span class="level-start"><span class="level-item">哈希(Hash)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%88-Stack/"><span class="level-start"><span class="level-item">栈(Stack)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/%E6%A0%91-Tree/"><span class="level-start"><span class="level-item">树(Tree)</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/"><span class="level-start"><span class="level-item">PyTorch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/"><span class="level-start"><span class="level-item">闲聊</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%81%8A/%E8%AE%A1%E5%88%92/"><span class="level-start"><span class="level-item">计划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-12T07:13:57.000Z">2024-06-12</time></p><p class="title"><a href="/2024/06/12/SparkQuickIN/">SparkQuickIN</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Spark/">Spark</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-11T08:03:22.000Z">2024-06-11</time></p><p class="title"><a href="/2024/06/11/OnlineTravelBigdataPlatform/">OnlineTravelBigdataPlatform</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-10T09:32:28.000Z">2024-06-10</time></p><p class="title"><a href="/2024/06/10/ScalaQuickIN/">ScalaQuickIN</a></p><p class="categories"><a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a> / <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-02T14:43:53.000Z">2024-06-02</time></p><p class="title"><a href="/2024/06/02/QuickPassHBase/">QuickPassHBase</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-27T10:18:43.000Z">2024-05-27</time></p><p class="title"><a href="/2024/05/27/Evaluation-Indicators-in-AI/">Evaluation Indicators in AI</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Axure-RP-9/"><span class="tag">Axure RP 9</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CppDev/"><span class="tag">CppDev</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECharts/"><span class="tag">ECharts</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kaggle/"><span class="tag">Kaggle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QT6/"><span class="tag">QT6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tomcat/"><span class="tag">Tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"><span class="tag">大数据技术</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E5%88%92/"><span class="tag">计划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/"><span class="tag">软件源</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%B2%E8%81%8A/"><span class="tag">闲聊</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A1%B9%E7%9B%AE/"><span class="tag">项目</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/StarLogo.svg" alt="Hello, NilEra :-)" height="28"></a><p class="is-size-7"><span>&copy; 2024 NilEra</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024 前方⚡高能</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/NilEra-K"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdnjs.loli.net/ajax/libs/algoliasearch/4.0.3/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdnjs.loli.net/ajax/libs/instantsearch.js/4.3.1/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"2TB5ZZYPCO","apiKey":"00a43f1d62ca7b24c8b78d5f0223c065","indexName":"dev_nilera_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>